<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj3083 遥远的国度 题解]]></title>
    <url>%2F2018%2F02%2F08%2Fbzoj3083-%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9B%BD%E5%BA%A6-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：题目描述zcwwzdjn在追杀十分sb的zhx，而zhx逃入了一个遥远的国度。当zcwwzdjn准备进入遥远的国度继续追杀时，守护神RapiD阻拦了zcwwzdjn的去路，他需要zcwwzdjn完成任务后才能进入遥远的国度继续追杀。 问题是这样的：遥远的国度有n个城市，这些城市之间由一些路连接且这些城市构成了一颗树。这个国度有一个首都，我们可以把这个首都看做整棵树的根，但遥远的国度比较奇怪，首都是随时有可能变为另外一个城市的。遥远的国度的每个城市有一个防御值，有些时候RapiD会使得某两个城市之间的路径上的所有城市的防御值都变为某个值。 RapiD想知道在某个时候，如果把首都看做整棵树的根的话，那么以某个城市为根的子树的所有城市的防御值最小是多少。 由于RapiD无法解决这个问题，所以他拦住了zcwwzdjn希望他能帮忙。但zcwwzdjn还要追杀sb的zhx，所以这个重大的问题就被转交到了你的手上。 输入输出格式输入格式： 第1行两个整数n m，代表城市个数和操作数。 第2行至第n行，每行两个整数 u v，代表城市u和城市v之间有一条路。 第n+1行，有n个整数，代表所有点的初始防御值。 第n+2行一个整数 id，代表初始的首都为id。 第n+3行至第n+m+2行，首先有一个整数opt，如果opt=1，接下来有一个整数id，代表把首都修改为id；如果opt=2，接下来有三个整数p1 p2 v，代表将p1 p2路径上的所有城市的防御值修改为v；如果opt=3，接下来有一个整数 id，代表询问以城市id为根的子树中的最小防御值。 输出格式： 对于每个opt=3的操作，输出一行代表对应子树的最小点权值。 输入输出样例输入样例#1： 1234567891011123 71 21 31 2 313 12 1 1 63 12 2 2 53 12 3 3 43 1 输出样例#1： 12341234 题解：先考虑没有换根操作，这时候就是裸的树剖。 如果有换根操作呢，分类讨论： 1.x == rt，这时候我们就是找1-n的最小值。 2.lca(x, rt) == x，即x在现根到原根的链上时，我们发现x的子树就是整棵树减去x向下一个节点的子树 3.除以上两种情况，x的子树不变。 然后套上裸的树链剖分就好了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;const LL MAXN = 2e5 + 15;struct Edge&#123;LL to, nxt;&#125;g[MAXN &lt;&lt; 1];LL head[MAXN], size[MAXN], dep[MAXN], s[MAXN &lt;&lt; 2], fa[MAXN], son[MAXN], top[MAXN], f[MAXN][25], w[MAXN], col[MAXN], wt[MAXN], id[MAXN], cnt = 0, tt = 0, n;LL min(LL a, LL b)&#123;return a &gt; b ? b : a;&#125;void add(LL u, LL v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_edge(LL u, LL v)&#123;add(u, v); add(v, u);&#125;void up(LL o)&#123;s[o] = min(s[lson], s[rson]);&#125;void down(LL o, LL l, LL r)&#123;if(col[o])&#123;col[lson] = col[rson] = col[o]; s[lson] = s[rson] = col[o]; col[o] = 0;&#125;&#125;LL lca(LL x, LL y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); LL t = dep[x] - dep[y]; for(LL i = 0; i &lt;= 17; i ++)&#123; if(t &amp; (1 &lt;&lt; i)) x = f[x][i]; &#125; for(LL i = 17; i &gt;= 0; i --)&#123; if(f[x][i] != f[y][i])&#123; x = f[x][i]; y = f[y][i]; &#125; &#125; if(x == y) return x; return f[x][0];&#125;void calc()&#123; for(LL j = 1; (1 &lt;&lt; j) &lt;= n; j ++) for(LL i = 1; i &lt;= n; i ++)&#123; if(f[i][j - 1]) f[i][j] = f[f[i][j - 1]][j - 1]; &#125;&#125;LL jump(LL x, LL dd)&#123; for(LL i = 0; i &lt;= 17; i ++)&#123; if(dd &amp; (1 &lt;&lt; i)) x = f[x][i]; &#125; return x;&#125;void build(LL o, LL l, LL r)&#123; if(l == r)&#123;s[o] = wt[l]; return ;&#125; LL mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); up(o);&#125;void modify(LL o, LL l, LL r, LL x, LL y, LL c)&#123; if(x &lt;= l &amp;&amp; r &lt;= y)&#123;s[o] = col[o] = c; return ;&#125; LL mid = l + r &gt;&gt; 1; down(o, l, r); if(x &lt;= mid) modify(lson, l, mid, x, y, c); if(y &gt; mid) modify(rson, mid + 1, r, x, y, c); up(o);&#125;LL query(LL o, LL l, LL r, LL x, LL y)&#123; if(x &lt;= l &amp;&amp; r &lt;= y) return s[o]; LL mid = l + r &gt;&gt; 1, ret = INF; if(x &lt;= mid) ret = min(ret, query(lson, l, mid, x, y)); if(y &gt; mid) ret = min(ret, query(rson, mid + 1, r, x, y)); return ret;&#125;void dfs1(LL u, LL fafa, LL deep)&#123; size[u] = 1; f[u][0] = fa[u] = fafa; dep[u] = deep; for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(v == fafa) continue; dfs1(v, u, deep + 1); size[u] += size[v]; if(size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;void dfs2(LL u, LL topf)&#123; top[u] = topf; id[u] = ++ tt; wt[id[u]] = w[u]; if(son[u]) dfs2(son[u], topf); for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(v == son[u] || v == fa[u]) continue; dfs2(v, v); &#125;&#125;void change(LL x, LL y, LL c)&#123; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); modify(1, 1, n, id[top[x]], id[x], c); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) swap(x, y); modify(1, 1, n, id[x], id[y], c);&#125;void work()&#123; n = read(); LL T = read(), rt; //memset(s, 0x3f, sizeof(s)); for(LL i = 1; i &lt; n; i ++)&#123; LL u = read(), v = read(); add_edge(u, v); &#125; for(LL i = 1; i &lt;= n; i ++) w[i] = read(); rt = read(); dfs1(1, 0, 1); dfs2(1, 1); build(1, 1, n); calc(); while(T --)&#123; LL opt = read(); if(opt == 1) rt = read(); else if(opt == 2)&#123; LL x = read(), y = read(), c = read(); change(x, y, c); &#125; else if(opt == 3)&#123; LL x = read(); if(x == rt) printf("%lld\n", query(1, 1, n, 1, n)); else if(lca(x, rt) == x)&#123; LL hh = jump(rt, dep[rt] - dep[x] - 1); printf("%lld\n", min(query(1, 1, n, 1, id[hh] - 1), query(1, 1, n, id[hh] + size[hh], n))); &#125; else printf("%lld\n", query(1, 1, n, id[x], id[x] + size[x] - 1)); &#125; &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束学习笔记]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[讲解：先安利一篇blog：传送门 然后我也不写了，大致总结一下： 差分约束系统就是给你一串不等式组，然后然你求$x_n-x_0$的最大值之类的问题，我们可以巧妙地把它转化成一个有向图来解决这个问题。 它的经典应用还是挺多的。线性约束、区间约束（这个千万不让忘了自己本身的一些约束条件）、未知条件约束（这个比较难，我们需要枚举，如果满足单调性还可二分）。 习题：1.bzoj1731题意： 当排队等候喂食时，奶牛喜欢和它们的朋友站得靠近些。FJ有N（2&lt;=N&lt;=1000）头奶牛，编号从1到N，沿一条直线站着等候喂食。奶牛排在队伍中的顺序和它们的编号是相同的。因为奶牛相当苗条，所以可能有两头或者更多奶牛站在同一位置上。即使说，如果我们想象奶牛是站在一条数轴上的话，允许有两头或更多奶牛拥有相同的横坐标。一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数L。另一方面，一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数D。给出ML条关于两头奶牛间有好感的描述，再给出MD条关于两头奶牛间存有反感的描述。（1&lt;=ML,MD&lt;=10000，1&lt;=L,D&lt;=1000000）你的工作是：如果不存在满足要求的方案，输出-1；如果1号奶牛和N号奶牛间的距离可以任意大，输出-2；否则，计算出在满足所有要求的情况下，1号奶牛和N号奶牛间可能的最大距离。 题解：这道题就是差分约束的模板题。我们都要转化成小于等于的形式。注意还有一个隐藏条件，就是d[i + 1] - d[i] &gt;= 0。然后SPFA判环，跑最短路即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt; #define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt) #define clr(x, y) memset(x, y, sizeof(x));#define INF 10000000 using namespace std; typedef long long LL;typedef double LF; LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125; const int MAXN = 1e4 + 15; struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, ct = 0, tag[MAXN], dist[MAXN], n, ml, md;bool vis[MAXN]; queue &lt;int&gt; q; void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void spfa()&#123; for(int i = 1; i &lt;= n; i ++) dist[i] = INF; dist[1] = 0; q.push(1); vis[1] = 1; tag[1] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(dist[v] &gt; dist[u] + g[i].dis)&#123; dist[v] = dist[u] + g[i].dis; if(!vis[v])&#123; tag[v] ++; if(tag[v] &gt; n)&#123;printf("-1\n"); return ;&#125; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125; if(dist[n] == INF)&#123;printf("-2\n"); return ;&#125; printf("%d\n", dist[n]);&#125; void work()&#123; n = read(), ml = read(), md = read(); for(int i = 1; i &lt;= ml; i ++)&#123; int x = read(), y = read(), z = read(); add(x, y, z); &#125; for(int i = 1; i &lt;= md; i ++)&#123; int x = read(), y = read(), z = read(); add(y, x, -z); &#125; for(int i = 2; i &lt;= n; i ++) add(i, i - 1, 0); spfa();&#125; int main()&#123; work(); return 0;&#125; 2.bzoj2330题意：幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 题解：这道题也不难，就是根据输入的建边，然后我们设一个虚点0，向i(1&lt;=i&lt;=n)连一条dis为1的边(即满足x[i]-x[0]&gt;=1，保证每个人都有糖果)，然后！！！关键问题，0向所有点的边不能按1-n的顺序建，得倒着建，看到hzwer的blog我才恍然大悟，如果是一条链的话，1-n的顺序就会T了。出题人好不良心啊。。。或者说我们每个点刚开始就加进queue里也可以，这样跟好一点。还有，别忘了答案是long long 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e6 + 15;struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, tag[MAXN], n, k;LL dist[MAXN];bool vis[MAXN]; queue &lt;int&gt; q;inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void spfa()&#123; q.push(0), tag[0] ++, vis[0] = 1; while(!q.empty())&#123; int u = q.front(); vis[u] = 0; q.pop(); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(dist[v] &lt; dist[u] + g[i].dis)&#123; dist[v] = dist[u] + g[i].dis; if(!vis[v])&#123; tag[v] ++; if(tag[v] &gt; n)&#123;printf("-1\n"); return ;&#125; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125; LL ans = 0; for(int i = 1; i &lt;= n; i ++) ans += dist[i]; printf("%lld\n", ans);&#125;void work()&#123; n = read(), k = read(); for(int i = 1; i &lt;= k; i ++)&#123; int opt = read(), x = read(), y = read(); if(opt == 1) add(x, y, 0), add(y, x, 0); else if(opt == 2)&#123;if(x == y)&#123;printf("-1\n"); return ;&#125; add(x, y, 1);&#125; else if(opt == 3) add(y, x, 0); else if(opt == 4)&#123;if(x == y)&#123;printf("-1\n"); return ;&#125; add(y, x, 1);&#125; else if(opt == 5) add(x, y, 0); &#125; for(int i = n; i &gt;= 1; i --) add(0, i, 1); spfa();&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1067 降雨量 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1067-%E9%99%8D%E9%9B%A8%E9%87%8F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：​ 我们常常会说这样的话：“X年是自Y年以来降雨量最多的”。它的含义是X年的降雨量不超过Y年，且对于任意Y＜Z＜X，Z年的降雨量严格小于X年。例如2002，2003，2004和2005年的降雨量分别为4920，5901，2832和3890，则可以说“2005年是自2003年以来最多的”，但不能说“2005年是自2002年以来最多的”由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。 题解：首先我们考虑什么时候会是true、false、maybe（我用x’,y’表示其降雨量） 首先y&gt;x直接false true： x，y已知，y’&lt;=x’，x+1至y-1的降雨量全都已知且&lt;y’ maybe： 1.x，y已知，y’&lt;=x’，x+1至y-1的降雨量有未知，但已知的都&lt;y’ 2.x已知，y未知，x+1至y-1的降雨量已知的必须都&lt;x’ 3.x未知，y已知，x+1至y-1的降雨量已知的必须都&lt;y’ 4.x为已知中的最大年份，y&gt;x 5.y位已知中的最小年份，x&lt;y 6.x，y均未知 然后接下来的就好办了，线段树维护一下即可。 false： 以上未出现的情况均为false 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1const int MAXN = 5e5 + 15;struct Node&#123;int len, start, end, maxn;&#125;s[MAXN &lt;&lt; 2];struct Input&#123;int y, r;&#125;a[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void up(int o)&#123; s[o] = (Node)&#123;s[lson].len &amp; s[rson].len, s[lson].start, s[rson].end, max(s[lson].maxn, s[rson].maxn)&#125;; if(s[lson].end + 1 != s[rson].start) s[o].len = 0;&#125;void build(int o, int l, int r)&#123; if(l == r)&#123; s[o] = (Node)&#123;1, a[l].y, a[l].y, a[l].r&#125;; return ; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); up(o);&#125;int find(int o, int x)&#123; if(s[o].start == s[o].end)&#123; if(s[o].start != x) return 0; return s[o].maxn; &#125; if(x &lt;= s[lson].end &amp;&amp; x &gt;= s[lson].start) find(lson, x); else if(x &gt;= s[rson].start &amp;&amp; x &lt;= s[rson].end) find(rson, x); else return 0;&#125; int query(int o, int x, int y)&#123; //cout&lt;&lt;s[o].start&lt;&lt;" "&lt;&lt;s[o].end&lt;&lt;endl; if(x &lt;= s[o].start &amp;&amp; s[o].end &lt;= y) return s[o].maxn; int ret = 0; if(x &lt;= s[lson].end) ret = max(ret, query(lson, x, y)); if(y &gt;= s[rson].start) ret = max(ret, query(rson, x, y)); return ret;&#125;int consec(int o, int x, int y)&#123; if(x &lt;= s[o].start &amp;&amp; s[o].end &lt;= y) return s[o].len; int ret = 1, flag = -1; if(x &lt;= s[lson].end) ret = ret &amp; consec(lson, x, y), flag ++; if(y &gt;= s[rson].start) ret = ret &amp; consec(rson, x, y), flag ++; if(flag == 1)&#123;if(s[lson].end + 1 != s[rson].start) ret = 0;&#125; return ret;&#125;void work()&#123; int n = read(), mm = 1e9 + 7, mx = -1e9 - 7; for(int i = 1; i &lt;= n; i ++) a[i].y = read(), a[i].r = read(), mm = min(mm, a[i].y), mx = max(mx, a[i].y); build(1, 1, n); int m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int x = read(), y = read(); if(x &gt; y)&#123;printf("false\n"); continue;&#125; if(x == y)&#123;printf("true\n"); continue;&#125; //以下为x&lt;y的 if(x == mx)&#123;printf("maybe\n"); continue;&#125; //maybe4 if(y == mm)&#123;printf("maybe\n"); continue;&#125; //maybe5 int l = find(1, x), r = find(1, y); if(!l &amp;&amp; !r)&#123;printf("maybe\n"); continue;&#125; //maybe6 else if((l &amp;&amp; !r) || (!l &amp;&amp; r))&#123; int tmp1 = query(1, x + 1, y - 1), tmp2 = l + r; //cout&lt;&lt;tmp1&lt;&lt;" "&lt;&lt;tmp2&lt;&lt;endl; if(tmp1 &lt; tmp2)&#123;printf("maybe\n"); continue;&#125; //maybe2, 3 &#125; else &#123; int flag = consec(1, x, y), tmp = query(1, x + 1, y - 1); if(l &gt;= r &amp;&amp; tmp &lt; r &amp;&amp; flag)&#123;printf("true\n"); continue;&#125; //true else if(l &gt;= r &amp;&amp; tmp &lt; r &amp;&amp; !flag)&#123;printf("maybe\n"); continue;&#125; //maybe1 &#125; printf("false\n"); &#125;&#125;int main()&#123; //freopen("data1.in", "r", stdin); //freopen("data.out", "w", stdout); work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2014 usaco Chocolate Buying 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj2014-usaco-Chocolate-Buying-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意： 贝西和其他奶牛们都喜欢巧克力，所以约翰准备买一些送给她们。奶牛巧克力专卖店里 有N种巧克力，每种巧克力的数量都是无限多的。每头奶牛只喜欢一种巧克力，调查显示， 有Ci头奶牛喜欢第i种巧克力，这种巧克力的售价是P。 ​ 约翰手上有B元预算，怎样用这些钱让尽量多的奶牛高兴呢？ 题解：直接贪心。按单价从小到大排序，搞事情。 代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e5 + 15;struct Node&#123;LL p, c;&#125;a[MAXN];LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;bool cmp(Node a, Node b)&#123;return a.p &lt; b.p;&#125;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; LL n = read(), b = read(); for(LL i = 1; i &lt;= n; i ++) a[i].p = read(), a[i].c = read(); sort(a + 1, a + n + 1, cmp); LL ans = 0; for(LL i = 1; i &lt;= n; i ++)&#123; LL tmp = Min(a[i].c, b / a[i].p); ans += tmp; b -= tmp * a[i].p; &#125; printf("%lld\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3400 usaco Cow Frisbee Team 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj3400-usaco-Cow-Frisbee-Team-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意： 农夫顿因开始玩飞盘之后，约翰也打算让奶牛们享受飞盘的乐趣．他要组建一只奶牛飞盘队．他的N(1≤N≤2000)只奶牛，每只部有一个飞盘水准指数Ri(1≤Ri≤100000)．约翰要选出1只或多于1只奶牛来参加他的飞盘队．由于约翰的幸运数字是F(1≤F≤1000)，他希望所有奶牛的飞盘水准指数之和是幸运数字的倍数． 帮约翰算算一共有多少种组队方式． 题解：dp。 $f_{i,j}$表示前i个牛，可以达到的水准和%f==j的方案数，然后就很显然了。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 2e3 + 15;const int MOD = 1e8;int f[MAXN][MAXN], a[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(), m = read(); for(int i = 1; i &lt;= n; i ++) a[i] = read(), f[i][a[i] % m] = 1; for(int i = 1; i &lt;= n; i ++) for(int j = 0; j &lt; m; j ++)&#123; (f[i][j] += f[i - 1][j]) %= MOD; (f[i][(j + a[i]) % m] += f[i - 1][j]) %= MOD; &#125; printf("%d\n", f[n][0]);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1655 usaco Dollar Dayz 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1655-usaco-Dollar-Dayz-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：约翰到奶牛商场里买工具．商场里有K(1≤K≤100).种工具，价格分别为1，2，…，K美元．约翰手里有N(1≤N≤1000)美元，必须花完．那他有多少种购买的组合呢？ 题解：首先f[j]表示当前有j美元能够购买的组合方案数，那么f[j] = f[j] + f[j - i]，其中i为当前枚举到的美元面值。 然后你这样写完之后，发现WA了。。。呵呵，高精度 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 515;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;struct Node&#123; int a[MAXN], len; Node()&#123;clr(a, 0); len = 0;&#125; Node operator +=(Node f)&#123; int tmp = max(len, f.len); for(int i = 1; i &lt;= tmp; i ++)&#123; a[i] += f.a[i]; a[i + 1] += a[i] / 10; a[i] %= 10; &#125; if(a[tmp + 1]) len = tmp + 1; else len = tmp; &#125;&#125;x[1015];void work()&#123; int n = read(), k = read(); x[0].a[1] = 1; x[0].len = 1; for(int i = 1; i &lt;= min(n, k); i ++) for(int j = i; j &lt;= n; j ++) x[j] += x[j - i]; for(int i = x[n].len; i; i --) printf("%d", x[n].a[i]); printf("\n");&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3410 usaco Selfish Grazing 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj3410-usaco-Selfish-Grazing-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：约翰有N(1≤N≤50000)头牛，约翰的草地可以认为是一条直线．每只牛只喜欢在某个特定的范围内吃草．第i头牛喜欢在区间(Si，Ei)吃草，1≤Si&lt;Ei≤1,000,000,00. 奶牛们都很自私，他们不喜欢和其他奶牛共享自己喜欢吃草的领域，因此约翰要保证任意两头牛都不会共享他们喜欢吃草昀领域．如果奶牛i和奶牛J想要同时吃草，那么要满足：Si&gt;=Ej或者Ei≤Sj．约翰想知道在同一时刻，最多可以有多少头奶牛同时吃草？ 题解：跟借教室一样。考虑贪心，按右端点从小到大排序，然后判断是否可行即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1const int MAXN = 1e5 + 15;struct Node&#123;int s, t;&#125;a[MAXN];bool cmp(Node x, Node y)&#123;return x.t &lt; y.t;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(); for(int i = 1; i &lt;= n; i ++) a[i].s = read(), a[i].t = read(); sort(a + 1, a + n + 1, cmp); int now = 0, cnt = 1, ans = 0; while(cnt &lt;= n)&#123; while(a[cnt].s &lt; now &amp;&amp; cnt &lt;= n) cnt ++; if(cnt &gt; n) break; ans ++; now = a[cnt].t; &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1689 usaco Muddy roads 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1689-usaco-Muddy-roads-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：牧场里下了一场暴雨，泥泞道路上出现了许多水坑，约翰想用一批长度为L的木板将这些水坑盖住. 牧场里的道路可以看成一根数轴，每个水坑可以用数轴上的两个坐标表示，如(3，6)表示从3到6有一个长度为3的水坑．所有的水坑都是不重叠的，(3，6)和(6，9)可以出现在同一个输入数据中，因为它们是两个连续的水坑，但不重叠． 请你帮助约翰计算最少要用多少块木板才能将所有水坑盖住 题解：考虑贪心（我最开始居然贪错了！！！我真是蠢到没救了） 按左端点从小到大排序，然后计算就成了 代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1const int MAXN = 1e5 + 15;struct Node&#123;int s, t;&#125;a[MAXN];bool cmp(Node x, Node y)&#123;return x.s &lt; y.s;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(), l = read(); for(int i = 1; i &lt;= n; i ++) a[i].s = read(), a[i].t = read(); sort(a + 1, a + n + 1, cmp); int now = 0, ans = 0; for(int i = 1; i &lt;= n; i ++)&#123; if(now &gt; a[i].t) continue; now = max(now, a[i].s); while(now &lt; a[i].t)&#123;ans ++; now += l;&#125; &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3389 usaco Cleaning Shifts 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj3389-usaco-Cleaning-Shifts-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：一天有T(1≤T≤10^6)个时段．约翰正打算安排他的N(1≤N≤25000)只奶牛来值班，打扫打扫牛棚卫生．每只奶牛都有自己的空闲时间段Si，Ei，只能把空闲的奶牛安排出来值班．而且，每个时间段必需有奶牛在值班． 那么，最少需要动用多少奶牛参与值班呢？如果没有办法安排出合理的方案，就输出-1. 题解：这道题我们考虑贪心，以左端点从小到大为第一关键字、右端点从小到大为第二关键字排序，然后对于当前可以覆盖到的第now段时间，我们把开头&lt;=now+1的全都拿出来，然后把now和这些的右端点取个max即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e6 + 15;struct Node&#123;int s, e;&#125;a[MAXN];bool cmp(Node x, Node y)&#123; if(x.s == y.s) return x.e &lt; y.e; return x.s &lt; y.s;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(), t = read(); for(int i = 1; i &lt;= n; i ++) a[i].s = read(), a[i].e = read(); sort(a + 1, a + n + 1, cmp); int now = 0, tmp, tot = 0, ans = 0; while(now &lt; t)&#123; tmp = now; while(tot &lt; n &amp;&amp; a[tot + 1].s &lt;= tmp + 1)&#123; tot ++; now = max(now, a[tot].e); &#125; if((tot == n &amp;&amp; now &lt; t) || a[tot + 1].s &gt; now + 1)&#123;printf("-1\n"); return ;&#125; ans ++; &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1643 usaco Bessie's Secret Pasture 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1643-usaco-Bessie-s-Secret-Pasture-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：农夫约翰已经从他的牧场中取得了数不清块数的正方形草皮，草皮的边长总是整数（有时农夫约翰割草皮的刀法不合适，甚至切出了边长为0的正方形草皮），他已经把草皮放在了一个奶牛贝茜已经知道的地方。 贝茜总是希望把美味的草皮放到她的秘密庄园里，她决定从这些草皮中取出恰好4块搬到她的秘密庄园中，然后把它们分成1×1的小块，组成一个面积为N(1&lt;=N&lt;=10,000)个单位面积的部分。 贝茜对选出这样四块草皮的方法数很感兴趣，如果她得到了一个4个单位面积的部分，那么她可以有5中不同的方法选4块草皮：(1,1,1,1),(2,0,0,0),(0,2,0,0),(0,0,0,2).顺序是有效的：(4,3,2,1)和(1,2,3,4)是不同的方法。 题解：这个递推一下就完了。 $f{i,j}$表示面积为i，分成j份的方案数，枚举k，$f{i,j}+=f{i-k\times k,j-1}$ 代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1const int MAXN = 1e5 + 15;int f[MAXN][5];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(); f[0][0] = 1; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= 4; j ++) for(int k = 0; k * k &lt;= i; k ++) f[i][j] += f[i - k * k][j - 1]; printf("%d\n", f[n][1] + f[n][2] + f[n][3] + f[n][4]);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3391 usaco Tree Cutting 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj3391-usaco-Tree-Cutting-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：​ 约翰意识到贝茜建设网络花费了他巨额的经费，就把她解雇了．贝茜很愤怒，打算狠狠报复．她打算破坏刚建成的约翰的网络． 约翰的网络是树形的，连接着N(1≤N≤10000)个牛棚．她打算切断某一个牛棚的电源，使和这个牛棚相连的所有电缆全部中断．之后，就会存在若干子网络．为保证破坏够大，每一个子网的牛棚数不得超过总牛棚数的一半,那哪些牛棚值得破坏呢？ 题解：这个题啊，dfs一遍就好了，判断当前点u的每个儿子v为根节点的子树size[v] 和 n-size[u]是否都&lt;=n/2. 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e5 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, size[MAXN], n;bool ans[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v)&#123;add(u, v); add(v, u);&#125;void dfs(int u, int fafa)&#123; size[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v == fafa) continue; dfs(v, u); size[u] += size[v]; if(size[v] &gt; n / 2) ans[u] = 0; &#125; if(n - size[u] &gt; n / 2) ans[u] = 0;&#125;void work()&#123; n = read(); for(int i = 1; i &lt;= n; i ++) ans[i] = 1; for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(); add_edge(u, v); &#125; dfs(1, 0); int tot = 0; for(int i = 1; i &lt;= n; i ++) if(ans[i]) printf("%d\n", i), tot ++; if(!tot) printf("NONE\n");&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4747 usaco Counting Haybales 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj4747-usaco-Counting-Haybales-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：给出N（1≤N≤100,000）个数，和 Q（1≤Q≤100,000）个询问。每个询问包含两个整数A,B(0≤A≤B≤1,000,000,000）。对于每个询问，给出数值在A到B间的数有多少个（包含A与B）。 题解：裸的线段树，先从小到大排序，维护一下每个区间最小值、最大值、长度，瞎搞。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt; #define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt) #define clr(x, y) memset(x, y, sizeof(x));#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1 using namespace std; typedef long long LL;typedef double LF; LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125; const int MAXN = 1e5 + 15; struct Node&#123;int mn, mx, len;&#125;s[MAXN &lt;&lt; 2];int a[MAXN]; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; inline void up(int o)&#123;s[o] = (Node)&#123;min(s[lson].mn, s[rson].mn), max(s[lson].mx, s[rson].mx), s[lson].len + s[rson].len&#125;;&#125; void build(int o, int l, int r)&#123; if(l == r)&#123; s[o] = (Node)&#123;a[l], a[l], 1&#125;; return ; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); up(o);&#125; int query(int o, int x, int y)&#123; if(y &lt; s[o].mn || x &gt; s[o].mx) return 0; if(x &lt;= s[o].mn &amp;&amp; s[o].mx &lt;= y) return s[o].len; int ret = 0; if(x &lt;= s[lson].mx) ret += query(lson, x, y); if(y &gt;= s[rson].mn) ret += query(rson, x, y); return ret;&#125; void work()&#123; int n = read(), q = read(); for(int i = 1; i &lt;= n; i ++) a[i] = read(); sort(a + 1, a + n + 1); build(1, 1, n); //for(int i = 1; i &lt;= 5; i ++) cout&lt;&lt;s[i].mx&lt;&lt;" "&lt;&lt;s[i].mn&lt;&lt;" "&lt;&lt;s[i].len&lt;&lt;endl; while(q --)&#123; int x = read(), y = read(); printf("%d\n", query(1, x, y)); &#125;&#125; int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1699 usaco Balanced Lineup 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1699-usaco-Balanced-Lineup-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：每天,农夫 John 的N(1 &lt;= N &lt;= 50,000)头牛总是按同一序列排队. 有一天, John 决定让一些牛们玩一场飞盘比赛. 他准备找一群在对列中为置连续的牛来进行比赛. 但是为了避免水平悬殊,牛的身高不应该相差太大. John 准备了Q (1 &lt;= Q &lt;= 180,000) 个可能的牛的选择和所有牛的身高 (1 &lt;= 身高 &lt;= 1,000,000). 他想知道每一组里面最高和最低的牛的身高差别. 注意: 在最大数据上, 输入和输出将占用大部分运行时间. 题解：裸的线段树，还不用修改 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1const int MAXN = 1e5 + 15;const int INF = 2e9;struct Node&#123;int mx, mn;&#125;s[MAXN &lt;&lt; 2];int a[MAXN];inline void up(int o)&#123;s[o].mn = min(s[lson].mn, s[rson].mn); s[o].mx = max(s[lson].mx, s[rson].mx);&#125;void build(int o, int l, int r)&#123; if(l == r)&#123;s[o].mn = s[o].mx = a[l]; return ;&#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); up(o);&#125;int querymx(int o, int l, int r, int x, int y)&#123; if(x &lt;= l &amp;&amp; r &lt;= y) return s[o].mx; int mid = l + r &gt;&gt; 1, ret = 0; if(x &lt;= mid) ret = max(ret, querymx(lson, l, mid, x, y)); if(y &gt; mid) ret = max(ret, querymx(rson, mid + 1, r, x, y)); return ret;&#125;int querymn(int o, int l, int r, int x, int y)&#123; if(x &lt;= l &amp;&amp; r &lt;= y) return s[o].mn; int mid = l + r &gt;&gt; 1, ret = INF; if(x &lt;= mid) ret = min(ret, querymn(lson, l, mid, x, y)); if(y &gt; mid) ret = min(ret, querymn(rson, mid + 1, r, x, y)); return ret;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(), q = read(); for(int i = 1; i &lt;= n; i ++) a[i] = read(); build(1, 1, n); while(q --)&#123; int x = read(), y = read(); int tmp1 = querymx(1, 1, n, x, y), tmp2 = querymn(1, 1, n, x, y); printf("%d\n", tmp1 - tmp2); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1612 usaco Cow Contest 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1612-usaco-Cow-Contest-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：FJ的N(1 &lt;= N &lt;= 100)头奶牛们最近参加了场程序设计竞赛:)。在赛场上，奶牛们按1..N依次编号。每头奶牛的编程能力不尽相同，并且没有哪两头奶牛的水平不相上下，也就是说，奶牛们的编程能力有明确的排名。 整个比赛被分成了若干轮，每一轮是两头指定编号的奶牛的对决。如果编号为A的奶牛的编程能力强于编号为B的奶牛(1 &lt;= A &lt;= N; 1 &lt;= B &lt;= N; A != B) ，那么她们的对决中，编号为A的奶牛总是能胜出。 FJ想知道奶牛们编程能力的具体排名，于是他找来了奶牛们所有 M(1 &lt;= M &lt;= 4,500)轮比赛的结果，希望你能根据这些信息，推断出尽可能多的奶牛的编程能力排名。比赛结果保证不会自相矛盾。 题解：n只有100，我们考虑dfs。 对于一个确定的点，比它排名高的和比他排名低的牛肯定是确定的，而且其总数一定是n-1. 那么我们正反建图，然后dfs，对于当前判断是否可行的点i，除它以外的所有点都应该在正反dfs被遍历过，若没有，那么当前点的排名不确定。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 115;int e1[MAXN][MAXN], e2[MAXN][MAXN], n, m;bool vis[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void dfs1(int u)&#123; vis[u] = 1; for(int i = 1; i &lt;= n; i ++)&#123; if(!e1[u][i] || vis[i]) continue; dfs1(i); &#125;&#125;void dfs2(int u)&#123; vis[u] = 1; for(int i = 1; i &lt;= n; i ++)&#123; if(!e2[u][i] || vis[i]) continue; dfs2(i); &#125;&#125;bool pd(int x)&#123; clr(vis, 0); dfs1(x); dfs2(x); for(int i = 1; i &lt;= n; i ++) if(!vis[i]) return 0; return 1;&#125;void work()&#123; n = read(), m = read(); int ans = 0; for(int i = 1; i &lt;= m; i ++)&#123; int x = read(), y = read(); e1[x][y] = e2[y][x] = 1; &#125; for(int i = 1; i &lt;= n; i ++) if(pd(i)) ans ++; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4500 矩阵 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj4500-%E7%9F%A9%E9%98%B5-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：有一个n*m的矩阵，初始每个格子的权值都为0，可以对矩阵执行两种操作： 选择一行， 该行每个格子的权值加1或减1。 选择一列， 该列每个格子的权值加1或减1。 现在有K个限制，每个限制为一个三元组(x,y,c)，代表格子(x,y)权值等于c。问是否存在一个操作序列，使得操作完后的矩阵满足所有的限制。如果存在输出”Yes”，否则输出”No”。 题解：这道题，我们仔细想想，会发现，(x, y)这个格子的值一定等于第x行加的值+第y列加的值，所以我们很快就能想到这是一个n+m个点的差分约束问题，如果我们把列的值改为负的，那么对于一个三元组(x, y, c)，我们有x-y&gt;=c x-y&lt;=c。 然后我是都给它改成了&gt;=的形式，然后跑一边最长路判断是否可行即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 1e4 + 15;struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, dist[MAXN], tag[MAXN], n, m, k;bool vis[MAXN]; queue &lt;int&gt; q;inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void spfa()&#123; for(int i = 1; i &lt;= n * 2; i ++) q.push(i); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(dist[v] &lt; dist[u] + g[i].dis)&#123; dist[v] = dist[u] + g[i].dis; if(!vis[v])&#123; if(tag[v] == n * 2)&#123;printf("No\n"); return ;&#125; tag[v] ++; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125; printf("Yes\n");&#125;void work()&#123; int T = read(); while(T --)&#123; n = read(), m = read(), k = read(); cnt = 0; clr(tag, 0); clr(dist, 0); clr(head, 0); for(int i = 1; i &lt;= k; i ++)&#123; int x = read(), y = read() + n, c = read(); add(x, y, c); add(y, x, -c); &#125; spfa(); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3396 usaco Total Flow 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj3396-usaco-Total-Flow-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：传送门 题解：（根本不知道题目说那么多在干什么。。。误导人么。。。） 裸的最大流，不解释 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 1e3 + 15;const int INF = 2e9;struct Edge&#123;int to, nxt, f;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cur[MAXN], d[MAXN], cnt = -1, n, s, t, ans;queue &lt;int&gt; q;inline void add(int u, int v, int f)&#123;g[++ cnt] = (Edge)&#123;v, head[u], f&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int f)&#123;add(u, v, f); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].f &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].f &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].f)); g[i].f -= tmp; flow -= tmp; g[i ^ 1].f += tmp; ret += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void dinic()&#123; while(bfs())&#123; for(int i = 1; i &lt;= 52; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125;&#125;void work()&#123; clr(head, -1); n = read(); s = 1, t = 26; for(int i = 1; i &lt;= n; i ++)&#123; char ch[5]; int u, v, f; scanf("%s", ch); if(ch[0] &gt;= 'A' &amp;&amp; ch[0] &lt;= 'Z') u = ch[0] - 'A' + 1; else u = ch[0] - 'a' + 27; scanf("%s", ch); if(ch[0] &gt;= 'A' &amp;&amp; ch[0] &lt;= 'Z') v = ch[0] - 'A' + 1; else v = ch[0] - 'a' + 27; f = read(); add_edge(u, v, f); &#125; dinic(); printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1741 usaco Asteroids 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1741-usaco-Asteroids-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：贝茜想驾驶她的飞船穿过危险的小行星群．小行星群是一个NxN的网格(1≤N≤500)，在网格内有K个小行星(1≤K≤10000)． 幸运地是贝茜有一个很强大的武器，一次可以消除所有在一行或一列中的小行星，这种武器很贵，所以她希望尽量地少用．给出所有的小行星的位置，算出贝茜最少需要多少次射击就能消除所有的小行星． 题解：这道题，看起来就像网络流最小割的问题。 怎么建图呢？s-&gt;行号连一条容量为1的边，列号-&gt;t连一条容量为1的边，有小行星的点，其 行号-&gt;列号 连一条容量为INF的边，然后求最小割就可以了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 2e4 + 15;const int MAXM = 1e6 + 15;const int INF = 2e9;struct Edge&#123;int to, nxt, f;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], s, t;queue &lt;int&gt; q;inline void add(int u, int v, int f)&#123;g[++ cnt] = (Edge)&#123;v, head[u], f&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int f)&#123;add(u, v, f); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].f &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].f &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].f)); g[i].f -= tmp; flow -= tmp; g[i ^ 1].f += tmp; ret += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); int n = read(), k = read(); s = n * 2 + 1, t = n * 2 + 2; for(int i = 1; i &lt;= n; i ++) add_edge(s, i, 1), add_edge(i + n, t, 1); for(int i = 1; i &lt;= k; i ++)&#123; int x = read(), y = read(); add_edge(x, y + n, INF); &#125; int ans = 0; while(bfs())&#123; ans += dfs(s, INF); &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1626 Building Roads 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1626-Building-Roads-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：Farmer John最近得到了一些新的农场，他想新修一些道路使得他的所有农场可以经过原有的或是新修的道路互达（也就是说，从任一个农场都可以经过一些首尾相连道路到达剩下的所有农场）。有些农场之间原本就有道路相连。 所有N(1 &lt;= N &lt;= 1,000)个农场（用1..N顺次编号）在地图上都表示为坐标为(X_i, Y_i)的点(0 &lt;= X_i &lt;= 1,000,000；0 &lt;= Y_i &lt;= 1,000,000)，两个农场间道路的长度自然就是代表它们的点之间的距离。现在Farmer John也告诉了你农场间原有的M(1 &lt;= M &lt;= 1,000)条路分别连接了哪两个农场，他希望你计算一下，为了使得所有农场连通，他所需建造道路的最小总长是多少。 题解：这道题很水啊，然而爆int了我第一遍WA了。。。 这道题就是刚开始先把已经存在的边用并查集把它们放到一个集合，用坐标预处理出两点之间的距离，之后就是裸的kruskal。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double LF; #define clr(x, y) memset(x, y, sizeof(x)) const int MAXN = 1e6 + 15; struct Edge&#123;int from, to; LF dis;&#125;g[MAXN &lt;&lt; 1];int cnt = 0, fa[MAXN], x[MAXN], y[MAXN], tmp = 0; inline void add(int u, int v, LF dis)&#123;g[++ cnt] = (Edge)&#123;u, v, dis&#125;;&#125;LF getdis(int x1, int y1, int x2, int y2)&#123; LL x = (LL)(x1 - x2), y = (LL)(y1 - y2); return sqrt(x * x + y * y);&#125;int getfa(int x)&#123;return fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;bool cmp(Edge x, Edge y)&#123;return x.dis &lt; y.dis;&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void work()&#123; int n = read(), m = read(); for(int i = 1; i &lt;= n; i ++) fa[i] = i; for(int i = 1; i &lt;= n; i ++) x[i] = read(), y[i] = read(); for(int i = 1; i &lt;= m; i ++)&#123; int a = read(), b = read(); int f1 = getfa(a), f2 = getfa(b); if(f1 != f2) fa[f2] = f1, tmp ++; &#125; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt; i; j ++)&#123; LF dist = getdis(x[i], y[i], x[j], y[j]); add(i, j, dist); &#125; sort(g + 1, g + cnt + 1, cmp); LF ans = 0; int i = 0; while(tmp &lt; n - 1)&#123; i ++; int a = g[i].from, b = g[i].to; int f1 = getfa(a), f2 = getfa(b); if(f1 != f2) fa[f2] = f1, tmp ++, ans += g[i].dis; &#125; printf("%.2lf\n", ans);&#125; int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1638 usaco Cow Traffic 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1638-usaco-Cow-Traffic-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：农场中,由于奶牛数量的迅速增长,通往奶牛宿舍的道路也出现了严重的交通拥堵问题.FJ打算找出最忙碌的道路来重点整治. 这个牧区包括一个由M (1 ≤ M ≤ 50,000)条单行道路(有向)组成的网络,以及 N (1 ≤ N ≤ 5,000)个交叉路口(编号为1..N),每一条道路连接两个不同的交叉路口.奶牛宿舍位于第N个路口.每一条道路都由编号较小的路口通向编号较大的路口.这样就可以避免网络中出现环.显而易见,所有道路都通向奶牛宿舍.而两个交叉路口可能由不止一条边连接. 在准备睡觉的时候,所有奶牛都从他们各自所在的交叉路口走向奶牛宿舍,奶牛只会在入度为0的路口,且所有入度为0的路口都会有奶牛. 帮助FJ找出最忙碌的道路,即计算所有路径中通过某条道路的最大次数.答案保证可以用32位整数存储. 题解：这道题大概是silver里比较难的了吧。 首先，很显然的一件事就是对于u-&gt;v这条边，经过它的次数根据乘法原理可得就是1-&gt;u的次数*v-&gt;n的次数。所以我们先dp一次n-&gt;u的，再反向建图dp一次 入度为零的点-&gt;u的，然后取最大即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 5e4 + 15;const int MAXM = 5e4 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = 0, f1[MAXN], f2[MAXN], tmpu[MAXN], tmpv[MAXN], n, m;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void dp1(int u)&#123; //n-&gt;u if(!head[u])&#123;f1[u] = 1; return ;&#125; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!f1[v]) dp1(v); f1[u] += f1[v]; &#125;&#125;void dp2(int u)&#123; //i-&gt;u if(!head[u])&#123;f2[u] = 1; return ;&#125; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!f2[v]) dp2(v); f2[u] += f2[v]; &#125;&#125;void work()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; tmpu[i] = read(), tmpv[i] = read(); add(tmpu[i], tmpv[i]); &#125; for(int i = 1; i &lt;= n; i ++) if(!f1[i]) dp1(i); cnt = 0; memset(head, 0, sizeof(head)); for(int i = 1; i &lt;= m; i ++) add(tmpv[i], tmpu[i]); dp2(n); int ans = 0; //for(int i = 1; i &lt;= n; i ++) printf("%d ", f1[i]); printf("\n"); //for(int i = 1; i &lt;= n; i ++) printf("%d ", f2[i]); printf("\n"); for(int i = 1; i &lt;= m; i ++)&#123; int u = tmpu[i], v = tmpv[i]; ans = max(f1[v] * f2[u], ans); &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>乘法原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1577 usaco Fair Shuttle 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1577-usaco-Fair-Shuttle-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意:公交车一共经过N（1&lt;=N&lt;=20000）个站点，从站点1一直驶到站点N。K（1&lt;=K&lt;=50000)群奶牛希望搭乘这辆公交车。第i群牛一共有Mi（1&lt;=Mi&lt;=N)只.他们希望从Si到Ei去。 公交车只能座C（1&lt;=C&lt;=100）只奶牛。而且不走重复路线，请计算这辆车最多能满足多少奶牛听要求。注意：对于每一群奶牛，可以部分满足，也可以全部满足，也可以全部不满足。 题解：这道题我的第一反应是网络流，但是显然超时，然后我们会想到借教室这类问题，于是我果断的搞了个贪心，然后用线段树维护区间最大值即可。 至于这个贪心为什么是对的。额，我也不能证明，但是仔细想想就知道，我们得保证每个时刻车里“塞”得越满越好，然而按右端点从小到大排序能够保证多塞，所以我们这样搞个贪心就完了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 1e5 + 15;const int INF = 2e9;struct Node&#123;int s, t, m;&#125;a[MAXN];int k, n, c, s[MAXN &lt;&lt; 2], col[MAXN &lt;&lt; 2], ans = 0;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool cmp(Node x, Node y)&#123;return x.t &lt; y.t;&#125;inline void up(int o)&#123;s[o] = max(s[lson], s[rson]);&#125;inline void down(int o, int l, int r)&#123; if(!col[o]) return ; col[lson] += col[o]; col[rson] += col[o]; s[lson] += col[o]; s[rson] += col[o]; col[o] = 0;&#125;void modify(int o, int l, int r, int x, int y, int c)&#123; if(x &lt;= l &amp;&amp; r &lt;= y)&#123;s[o] += c; col[o] += c; return ;&#125; down(o, l, r); int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(lson, l, mid, x, y, c); if(y &gt; mid) modify(rson, mid + 1, r, x, y, c); up(o);&#125;int query(int o, int l, int r, int x, int y)&#123; if(x &lt;= l &amp;&amp; r &lt;= y) return s[o]; down(o, l, r); int mid = l + r &gt;&gt; 1, ret = 0; if(x &lt;= mid) ret = max(ret, query(lson, l, mid, x, y)); if(y &gt; mid) ret = max(ret, query(rson, mid + 1, r, x, y)); return ret;&#125;void work()&#123; k = read(), n = read(), c = read(); for(int i = 1; i &lt;= k; i ++) a[i].s = read(), a[i].t = read() - 1, a[i].m = read(); sort(a + 1, a + k + 1, cmp); for(int i = 1; i &lt;= k; i ++)&#123; int tmp = min(a[i].m, c - query(1, 1, n, a[i].s, a[i].t)); if(!tmp) continue; ans += tmp; modify(1, 1, n, a[i].s, a[i].t, tmp); &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1596 usaco 电话网络 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1596-usaco-%E7%94%B5%E8%AF%9D%E7%BD%91%E7%BB%9C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：Farmer John决定为他的所有奶牛都配备手机，以此鼓励她们互相交流。不过，为此FJ必须在奶牛们居住的N(1 &lt;= N &lt;= 10,000)块草地中选一些建上无线电通讯塔，来保证任意两块草地间都存在手机信号。所有的N块草地按1..N 顺次编号。 所有草地中只有N-1对是相邻的，不过对任意两块草地A和B(1 &lt;= A &lt;= N; 1 &lt;= B &lt;= N; A != B)，都可以找到一个以A开头以B结尾的草地序列，并且序列中相邻的编号所代表的草地相邻。无线电通讯塔只能建在草地上，一座塔的服务范围为它所在的那块草地，以及与那块草地相邻的所有草地。 请你帮FJ计算一下，为了建立能覆盖到所有草地的通信系统，他最少要建多少座无线电通讯塔。 题解：考虑树形dp，我们设： f表示最小覆盖数$f{u,0}$表示以u为子树的节点全覆盖，u放$f{u,1}$表示以u为子树的节点全覆盖，u不放$f_{u,2}$表示以u为子树的节点除u全覆盖 然后dfs状态转移一下即可，然后代码中的tmp一定要开LL，如果你的INF很大得话，因为到叶子节点的时候可能爆掉，不过我看黄学长的1e8就没炸，很玄学啊。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(LL i = a; i &lt;= b; i ++)#define REPG(i, x) for(LL i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const LL MAXN = 1e4 + 15;const LL INF = 1e9 + 7;struct Edge&#123;LL to, nxt;&#125;g[MAXN &lt;&lt; 1];LL head[MAXN], cnt = 0, f[MAXN][5];/*f表示最小覆盖数 f[u][0]表示以u为子树的节点全覆盖，u放f[u][1]表示以u为子树的节点全覆盖，u不放f[u][2]表示以u为子树的节点除u全覆盖 */inline void add(LL u, LL v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void add_edge(LL u, LL v)&#123;add(u, v); add(v, u);&#125;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void treedp(LL u, LL fafa)&#123; LL tmp = 0; f[u][0] = 1, f[u][1] = INF; for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(v == fafa) continue; treedp(v, u); f[u][0] += min(f[v][2], min(f[v][1], f[v][0])); f[u][2] += f[v][1]; tmp += min(f[v][0], f[v][1]); &#125; for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(v == fafa) continue; f[u][1] = min(f[u][1], tmp + f[v][0] - min(f[v][0], f[v][1])); &#125;&#125;void work()&#123; LL n = read(); for(LL i = 1; i &lt; n; i ++)&#123; LL u = read(), v = read(); add_edge(u, v); &#125; treedp(1, 0); printf("%lld\n", min(f[1][0], f[1][1])); &#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形动规</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1571 usaco ski 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1571-usaco-ski-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：Farmer John 想要带着 Bessie 一起在科罗拉多州一起滑雪。很不幸，Bessie滑雪技术并不精湛。 Bessie了解到，在滑雪场里，每天会提供S(0&lt;=S&lt;=100)门滑雪课。第i节课始于M_i(1&lt;=M_i&lt;=10000),上的时间为L_i(1&lt;=L_i&lt;=10000)。上完第i节课后，Bessie的滑雪能力会变成A_i(1&lt;=A_i&lt;=100). 注意：这个能力是绝对的，不是能力的增长值。 Bessie买了一张地图，地图上显示了N(1 &lt;= N &lt;= 10,000)个可供滑雪的斜坡，从第i个斜坡的顶端滑至底部所需的时长D_i(1&lt;=D_i&lt;=10000)，以及每个斜坡所需要的滑雪能力C_i(1&lt;=C_i&lt;=100)，以保证滑雪的安全性。Bessie的能力必须大于等于这个等级，以使得她能够安全滑下。 Bessie可以用她的时间来滑雪，上课，或者美美地喝上一杯可可汁，但是她必须在T(1&lt;=T&lt;=10000)时刻离开滑雪场。这意味着她必须在T时刻之前完成最后一次滑雪。 求Bessie在实现内最多可以完成多少次滑雪。这一天开始的时候，她的滑雪能力为1. 题解：这道题，很显然是个dp，不过不算特别好想。 首先，我们设$f_{i,j}$表示到第i个时刻，能力值达到j所能滑的最多的次数。 那么我们对于每次的$f_{i,j}$，应该怎么操作呢？ 1.$f{i,j}=f{i-1,j}$，表示什么都不做 2.如果有在i时刻结束的课程，那么我们可以选择其中开始时间最晚的课（这样可以有更长的时间滑雪，这个需要预处理出来），再和当前的$f_{i,j}$取个max 3.我们考虑当前刚滑完雪，我们肯定选择当前的能力值可以滑雪的地方中，耗时最短的，然后就是让$f{i-w[j],j}和f{i,j}$取个max 然后就没有然后了，这题也不算难，自己想想也应该能想明白。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e4 + 15;const int MAXM = 115;int f[MAXN][MAXM], h[MAXN][MAXM], g[MAXN], w[MAXM];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int t = read(), m = read(), n = read(); clr(w, 0x3f); clr(f, 0xc0); f[0][1] = 0; for(int i = 1; i &lt;= m; i ++)&#123; int x = read(), y = read() + x, z = read(); h[y][z] = max(h[y][z], x); //h[i][j]表示的是到i结束，能力达到z的最晚开始时间 &#125; for(int i = 1; i &lt;= n; i ++)&#123; int x = read(), y = read(); //x能力，y时间 for(int j = x; j &lt;= 100; j ++) w[j] = min(w[j], y); //w[i]表示能力值为i可滑雪的地方的最小消耗时间 &#125; for(int i = 1; i &lt;= t; i ++)&#123; for(int j = 1; j &lt;= 100; j ++)&#123; f[i][j] = f[i - 1][j]; //f[i][j]表示到第i时刻，能力达到j的最多滑雪次数 if(h[i][j]) f[i][j] = max(f[i][j], g[h[i][j]]); if(i - w[j] &gt;= 0) f[i][j] = max(f[i][j], f[i - w[j]][j] + 1); g[i] = max(g[i], f[i][j]); //g[i]表示到第i时刻，最多可以滑雪的次数 &#125; &#125; printf("%d\n", g[t]);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2101 usaco Treasure Chest 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj2101-usaco-Treasure-Chest-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：Bessie and Bonnie have found a treasure chest full of marvelous gold coins! Being cows, though, they can’t just walk into a store and buy stuff, so instead they decide to have some fun with the coins. The N (1 &lt;= N &lt;= 5,000) coins, each with some value C_i (1 &lt;= C_i &lt;= 5,000) are placed in a straight line. Bessie and Bonnie take turns, and for each cow’s turn, she takes exactly one coin off of either the left end or the right end of the line. The game ends when there are no coins left. Bessie and Bonnie are each trying to get as much wealth as possible for themselves. Bessie goes first. Help her figure out the maximum value she can win, assuming that both cows play optimally. Consider a game in which four coins are lined up with these values: 30 25 10 35 Consider this game sequence: Bessie Bonnie New Coin Player Side CoinValue Total Total Line Bessie Right 35 35 0 30 25 10 Bonnie Left 30 35 30 25 10 Bessie Left 25 60 30 10 Bonnie Right 10 60 40 — This is the best game Bessie can play. 贝西和邦妮找到了一个藏宝箱，里面都是金币！但是身为两头牛，她们不能到商店里把金币换成好吃的东西，于是她们只能用这些金币来玩游戏了。 ​ 藏宝箱里一共有N枚金币，第i枚金币的价值是Ci。贝西和邦妮把金币排成一条直线，她们轮流取金币，看谁取到的钱最多。贝西先取，每次只能取一枚金币，而且只能选择取直线两头的金币，不能取走中间的金币。当所有金币取完之后，游戏就结束了。 ​ 贝西和邦妮都是非常聪明的，她们会采用最好的办法让自己取到的金币最多。请帮助贝西计算一下，她最多能得到的金币的总价值是多少？ 题解：这道题看一看，就大概知道是dp（虽说我第一反应是博弈论吧。。。） 有一个二维的dp很好想，$f_{i,j}$表示i-j段，贝西先手可以拿到的最大价值，那么，转移方程式就是： $f{i,j}=max(sum{i,j}-f{i+1,j},\ \ sum{i,j}-f_{i,j-1})$ 然后呢，你会发现它MLE了，所以我们肯定要用一维搞定。 仔细想想，会发现j这维是冗余的。我们用$fi$表示i-i+j这段贝西先手可以拿到的最大价值，那么我们先枚举这个j即可。因为：$f_i=max(sum{i,j}-fi,\ \ sum{i,j}-f[i+1])$此时括号里面的f[i]和f[i+1]都是长度为j-1的，所以这样是可以的。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 5015;int c[MAXN], s[MAXN], f[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; int n = read(); for(int i = 1; i &lt;= n; i ++) c[i] = read(); for(int i = 1; i &lt;= n; i ++) f[i] = c[i]; for(int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + c[i]; /* for(int i = n; i &gt;= 1; i --) for(int j = i + 1; j &lt;= n; j ++) f[i][j] = max(c[i] - f[i + 1][j] + s[j] - s[i], c[j] - f[i][j - 1] + s[j - 1] - s[i - 1]); printf("%d\n", f[1][n]); */ for(int j = 1; j &lt;= n; j ++) for(int i = 1; i &lt;= n - j; i ++) f[i] = s[i + j] - s[i - 1] - min(f[i + 1], f[i]); printf("%d\n", f[1]);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1036 树的统计 题解]]></title>
    <url>%2F2018%2F02%2F07%2Fbzoj1036-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。 我们将以下面的形式来要求你对这棵树完成一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 III. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身 题解：树剖模板题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(LL i = a; i &lt;= b; i ++)#define REPG(i, x) for(LL i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1#define INF 0x7fffffffusing namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const LL MAXN = 1e6 + 15;struct Edge&#123;LL to, nxt;&#125;g[MAXN &lt;&lt; 1];LL head[MAXN], cnt = 0, tt = 0, top[MAXN], size[MAXN], w[MAXN], wt[MAXN], s[MAXN], sm[MAXN], fa[MAXN], son[MAXN], id[MAXN], dep[MAXN], n, m;inline void add(LL u, LL v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void add_edge(LL u, LL v)&#123;add(u, v); add(v, u);&#125;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void up(LL o)&#123; s[o] = s[lson] + s[rson]; sm[o] = max(sm[lson], sm[rson]);&#125;void build(LL o, LL l, LL r)&#123; if(l == r)&#123;s[o] = sm[o] = wt[l]; return ;&#125; LL mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); up(o);&#125;void modify(LL o, LL l, LL r, LL x, LL c)&#123; if(l == r)&#123;s[o] = sm[o] = c; return ;&#125; LL mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(lson, l, mid, x, c); if(x &gt; mid) modify(rson, mid + 1, r, x, c); up(o);&#125;LL querysum(LL o, LL l, LL r, LL x, LL y)&#123; if(x &lt;= l &amp;&amp; r &lt;= y) return s[o]; LL mid = l + r &gt;&gt; 1, ret = 0; if(x &lt;= mid) ret += querysum(lson, l, mid, x, y); if(y &gt; mid) ret += querysum(rson, mid + 1, r, x, y); return ret;&#125;LL querymax(LL o, LL l, LL r, LL x, LL y)&#123; if(x &lt;= l &amp;&amp; r &lt;= y) return sm[o]; LL mid = l + r &gt;&gt; 1, ret = -2e9; if(x &lt;= mid) ret = max(ret, querymax(lson, l, mid, x, y)); if(y &gt; mid) ret = max(ret, querymax(rson, mid + 1, r, x, y)); return ret;&#125;void dfs1(LL u, LL fafa, LL dd)&#123; size[u] = 1; dep[u] = dd; fa[u] = fafa; for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(v == fafa) continue; dfs1(v, u, dd + 1); size[u] += size[v]; if(size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;void dfs2(LL u, LL topf)&#123; id[u] = ++ tt; wt[tt] = w[u]; top[u] = topf; if(son[u]) dfs2(son[u], topf); for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;LL qmax(LL x, LL y)&#123; LL ret = -2e9; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); ret = max(ret, querymax(1, 1, tt, id[top[x]], id[x])); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) swap(x, y); ret = max(ret, querymax(1, 1, tt, id[x], id[y])); return ret;&#125;LL qsum(LL x, LL y)&#123; LL ret = 0; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); ret += querysum(1, 1, tt, id[top[x]], id[x]); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) swap(x, y); ret += querysum(1, 1, tt, id[x], id[y]); return ret;&#125;void work()&#123; n = read(); for(LL i = 1; i &lt; n; i ++)&#123; LL u = read(), v = read(); add_edge(u, v); &#125; for(LL i = 1; i &lt;= n; i ++) w[i] = read(); dfs1(1, 0, 1); dfs2(1, 1); build(1, 1, n); m = read(); while(m --)&#123; char ch[25]; scanf("%s", ch + 1); LL x = read(), y = read(); if(ch[1] == 'Q' &amp;&amp; ch[2] == 'M') printf("%d\n", qmax(x, y)); else if(ch[1] == 'Q' &amp;&amp; ch[2] == 'S') printf("%d\n", qsum(x, y)); else modify(1, 1, tt, id[x], y); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 772C Vulnerable Kerbals 题解]]></title>
    <url>%2F2017%2F12%2F28%2FCodeforces-772C%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题：You are given an integer m, and a list of n distinct integers between 0 and m - 1. You would like to construct a sequence satisfying the properties: Each element is an integer between 0 and m - 1, inclusive. All prefix products of the sequence modulo m are distinct. No prefix product modulo m appears as an element of the input list. The length of the sequence is maximized. Construct any sequence satisfying the properties above. Input The first line of input contains two integers n and m (0 ≤ n &lt; m ≤ 200 000) — the number of forbidden prefix products and the modulus. If n is non-zero, the next line of input contains n distinct integers between 0 and m - 1, the forbidden prefix products. If n is zero, this line doesn’t exist. Output On the first line, print the number k, denoting the length of your sequence. On the second line, print k space separated integers, denoting your sequence. 简要翻译：大概就是说，给你两个数n,m，然后再给你n个数，让你构造一个尽量长的序列，使得所有前缀积都不等于那n个数，并且输出这个序列。 题解：这道题是数论+DAG最长路 首先，我们设a为当前的序列的所有数的的乘积，这时加进来一个x，这样积就变为了b，那么我们可以用这样一个式子表示一下：ax%m=b，即$ax\equiv b (mod\ \ m)$。根据裴蜀定理，我们可以知道，当且仅当$gcd(a,m)|gcd(b,m)$时，这个同余方程有解，这时候我们就从a向b连一条边。由于有一些数与m的gcd相等，所以我们可以缩点。 缩点之后呢，显然就变成了一个DAG，这时候我们跑个最长路就可以了。 跑完最长路，我们记录下来了一条路径，但这不是最终的答案，因为我们记的是前缀积，通过前缀积之间的同余关系连的边，所以我们这时候要解这个同余方程，解完之后就是答案，那么怎么解呢？显然是用exgcd啊，这个要不会的话，还是回去看看NOIP2012 D2 T1同余方程吧。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex&lt;LF&gt; cd;typedef pair &lt;int, int&gt; abcd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 2e5 + 15;int f[MAXN], g[MAXN], pre[MAXN], a[MAXN], ans[MAXN], n, m, cnt = 0;vector &lt;int&gt; b[MAXN];bool vis[MAXN];abcd exgcd(int a, int b)&#123; if(!b) return abcd(1, 0); abcd t = exgcd(b, a % b); return abcd(t.second, t.first - a / b * t.second);&#125;inline int solve(LL a, LL b)&#123; abcd t = exgcd(a, m); int d = t.first * a + t.second * m; return ((b / d) * (t.first % m + m) % m) % m;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void work()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; i ++) a[i] = read(), vis[a[i]] = 1; for(int i = 0, d; i &lt; m; i ++)&#123; if(!vis[i])&#123; d = __gcd(i, m); int tmp = d % m; g[tmp] ++; f[tmp] ++; b[tmp].push_back(i); &#125; &#125; clr(pre, -1); for(int i = 1; i &lt; m; i ++) for(int j = i + i; j &lt;= m; j += i)&#123; int tmp = j % m; if(f[tmp] &lt; g[tmp] + f[i])&#123; f[tmp] = max(f[tmp], g[tmp] + f[i]), pre[tmp] = i; &#125; &#125; int k = 0; for(int j = 0; j &lt; m; j ++) if(!vis[j] &amp;&amp; f[j] &gt; f[k]) k = j; while(k != -1)&#123; for(int x:b[k]) ans[++ cnt] = x; k = pre[k]; &#125; reverse(ans + 1, ans + cnt + 1); for(int i = cnt; i &gt; 1; i --) ans[i] = solve(ans[i - 1], ans[i]); printf("%d\n", cnt); for(int i = 1; i &lt;= cnt; i ++) printf("%d ", ans[i]); printf("\n");&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>最长路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4455 小星星 题解]]></title>
    <url>%2F2017%2F12%2F28%2Fbzoj-4455%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：题目描述小Y是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有n颗小星星，用m条彩色的细线串了起来，每条细线连着两颗小星星。 有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了n?1条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小Y找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小Y想知道有多少种可能的对应方式。 只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。 输入输出格式输入格式：第一行包含个2正整数n,m，表示原来的饰品中小星星的个数和细线的条数。接下来m行，每行包含2个正整数u,v，表示原来的饰品中小星星u和v通过细线连了起来。这里的小星星从1开始标号。保证u&ne;v，且每对小星星之间最多只有一条细线相连。接下来n-1行，每行包含个2正整数u,v，表示现在的饰品中小星星u和v通过细线连了起来。保证这些小星星通过细线可以串在一起。n&lt;=17,m&lt;=n*(n-1)/2 输出格式：输出共1行，包含一个整数表示可能的对应方式的数量。如果不存在可行的对应方式则输出0。 题解：首先我们考虑最最暴力的做法：考虑每个点合不合法，dfs判断。时间复杂度$O(n^n)$ 我们再考虑一些优化，这是我们想到了dp。 $f[i][j]$表示以i为根的子树中，使用了原图中的哪些点的状态（j，装压，即用二进制表示）。初始值$f[i][j]=1$，然后dfs时枚举子集，暴力合并,转移方程式$f[u][i|j]+=f[v][j]$，其中v为u的儿子，i为初始状态的子集，j为当前枚举的子集。时间复杂度$O(3^nn^2)$ 不过显然这种dp不太行，那么我们在此基础上优化一下。 上面的dp合并时肯定保证了合法性（映射一一对应），如果我们不考虑合法性的话，最后容斥一下就可以了。 $f[i][j]$计算的是子树中，i点和原图中j点对应的方案数，合并的时候两个被看做是原图中的点有连边才能合并。 怎么算答案？我们可以发现$ans=\sum剩一个的-\sum剩两个的+\sum剩三个的…$ 举个栗子，3个数 我们首先+3个都用了的方案，但是有不合法的，这时我们-用了2个的，但是右减多了，这是我们再+用了1个的，这就是答案。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex&lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 115;struct Edge&#123;int to, nxt;&#125;g[MAXN * MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, a[MAXN], tot = 0, n, m;LL f[MAXN][MAXN], lim, ans = 0; bool mmap[MAXN][MAXN];inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v)&#123;add(u, v); add(v, u);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void dfs(int u, int fafa)&#123; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v == fafa) continue; dfs(v, u); &#125; for(int i = 1; i &lt;= tot; i ++)&#123; f[u][i] = 1; for(int j = head[u]; j; j = g[j].nxt)&#123; LL tmp = 0; int v = g[j].to; if(v == fafa) continue; for(int k = 1; k &lt;= tot; k ++) if(mmap[a[i]][a[k]]) tmp += f[v][k]; f[u][i] *= tmp; &#125; &#125;&#125;void work()&#123; scanf("%d %d", &amp;n, &amp;m); lim = (LL)(1 &lt;&lt; n); for(int i = 1; i &lt;= m; i ++)&#123; int u, v; scanf("%d %d", &amp;u, &amp;v); mmap[u][v] = mmap[v][u] = 1; &#125; for(int i = 1; i &lt; n; i ++)&#123; int u, v; scanf("%d %d", &amp;u, &amp;v); add_edge(u, v); &#125; for(LL i = 1; i &lt; lim; i ++)&#123; tot = 0; LL tmp = 0; for(int j = 0; j &lt; n; j ++) if((i &gt;&gt; j) &amp; 1) a[++ tot] = j + 1; dfs(1, 0); for(int j = 1; j &lt;= tot; j ++) tmp += f[1][j]; ans += (LL)(((n - tot) &amp; 1) ? -tmp : tmp); &#125; printf("%lld\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4196 软件包管理 题解]]></title>
    <url>%2F2017%2F12%2F27%2Fbzoj4196%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：题目描述Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。 你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包A依赖软件包B，那么安装软件包A以前，必须先安装软件包B。同时，如果想要卸载软件包B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2)个软件包A1,A2,A3,⋯,Am，其中A1依赖A2，A2依赖A3，A3依赖A4，……，A[m-1]依赖Am，而Am依赖A1，则称这m个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。 输入输出格式输入格式： 从文件manager.in中读入数据。 输入文件的第1行包含1个整数n，表示软件包的总数。软件包从0开始编号。 随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,⋯,n−2,n−1号软件包依赖的软件包的编号。 接下来一行包含1个整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种： install x：表示安装软件包x uninstall x：表示卸载软件包x 你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态。 对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。 输出格式： 输出到文件manager.out中。 输出文件包括q行。 输出文件的第i行输出1个整数，为第i步操作中改变安装状态的软件包数。 题解这道题就是裸的树链剖分。每个有依赖关系的都练一条边，0号为根。 install的时候，就相当于把这个点到根的这条路径上的所有点的点权赋成1, uninstall的时候，就相当于把这个点为根的子树中的点的点权全部赋成0。 这里我是在每次change前算了一个总数，change后再算一个两个sum的abs就是答案。 注意：lazy赋值要赋成不是1和0的数！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));#define lson o &lt;&lt; 1#define rson o &lt;&lt; 1 | 1using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 4e5 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, tt = 0, id[MAXN], dep[MAXN], size[MAXN], son[MAXN], fa[MAXN], top[MAXN], s[MAXN], lazy[MAXN];int n, m;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v)&#123;add(u, v); add(v, u);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void up(int o)&#123;s[o] = s[lson] + s[rson];&#125;inline void down(int o, int l, int r)&#123; if(lazy[o] &lt; 0) return ; lazy[lson] = lazy[o]; lazy[rson] = lazy[o]; int mid = l + r &gt;&gt; 1; s[lson] = lazy[o] * (mid - l + 1); s[rson] = lazy[o] * (r - mid); lazy[o] = -1;&#125;void modify(int o, int l, int r, int x, int y, int c)&#123; if(l &gt; r || x &gt; r || l &gt; y) return ; if(x &lt;= l &amp;&amp; r &lt;= y)&#123; lazy[o] = c; s[o] = (r - l + 1) * c; return ; &#125; down(o, l, r); int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(lson, l, mid, x, y, c); if(y &gt; mid) modify(rson, mid + 1, r, x, y, c); up(o);&#125;void build(int o, int l, int r)&#123; if(l == r)&#123;s[o] = 0; return ;&#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); up(o);&#125;int query(int o, int l, int r, int x, int y)&#123; int ret = 0; if(x &lt;= l &amp;&amp; r &lt;= y)&#123;return s[o];&#125; down(o, l, r); int mid = l + r &gt;&gt; 1; if(x &lt;= mid) ret += query(lson, l, mid, x, y); if(y &gt; mid) ret += query(rson, mid + 1, r, x, y); return ret;&#125;void updr(int x, int y)&#123; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); modify(1, 1, n, id[top[x]], id[x], 1); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) swap(x, y); modify(1, 1, n, id[x], id[y], 1);&#125;int qr(int x, int y)&#123; int ans = 0; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans += query(1, 1, n, id[top[x]], id[x]); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) swap(x, y); ans += query(1, 1, n, id[x], id[y]); return ans;&#125;void upds(int x)&#123; modify(1, 1, n, id[x], id[x] + size[x] - 1, 0);&#125;int qs(int x)&#123; return query(1, 1, n, id[x], id[x] + size[x] - 1);&#125;void dfs1(int u, int fafa, int dd)&#123; dep[u] = dd; fa[u] = fafa; size[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v == fafa) continue; dfs1(v, u, dd + 1); size[u] += size[v]; if(size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int fafa)&#123; id[u] = ++ tt; top[u] = fafa; if(!son[u]) return ; dfs2(son[u], fafa); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;void work()&#123; n = read(); clr(lazy, -1); for(int i = 2; i &lt;= n; i ++)&#123; int x = read() + 1; add_edge(x, i); &#125; dfs1(1, 0, 1); dfs2(1, 1); build(1, 1, n); m = read(); while(m --)&#123; char ch[10]; int x; scanf("%s", ch + 1); x = read() + 1; if(ch[1] == 'i')&#123; int tmp1 = qr(1, x); updr(1, x); int tmp2 = qr(1, x); printf("%d\n", abs(tmp2 - tmp1)); &#125; else &#123; int tmp1 = qs(x); upds(x); int tmp2 = qs(x); printf("%d\n", abs(tmp1 - tmp2)); &#125; &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流拓展]]></title>
    <url>%2F2017%2F12%2F27%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[无源汇有上下界可行流题意：题目描述：这是一道模板题。 n 个点，m 条边，每条边 e 有一个流量下界 lower(e) 和流量上界 upper(e) ，求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。 输入格式第一行两个正整数 n 、m。 之后的 m 行，每行四个整数 s 、t 、lower、upper。 输出格式：如果无解，输出一行 NO。 否则第一行输出 YES，之后 m mm 行每行一个整数，表示每条边的流量。 样例：样例输入 112345674 61 2 1 22 3 1 23 4 1 24 1 1 21 3 1 24 2 1 2 样例输出 11NO 样例输入 212345674 61 2 1 32 3 1 33 4 1 34 1 1 31 3 1 34 2 1 3 样例输出 21234567YES123211 题解：我们考虑把每条弧的下限都改为0，那么上限就是upper-lower。 这时候我们不一定能满足进出流量相等，怎么办呢？ 我们再设一个超级源和超级汇，先算出每个点的度数，然后$du[i]0$的连一条容量为du[i]的边。 然后跑最短路就可以了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 1e6 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, id;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], du[MAXN], dn[MAXN], anss[MAXM &lt;&lt; 1], n, m, s, t;queue &lt;int&gt; q; bool flag = 0;inline void add(int u, int v, int c, int id)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, id&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int id)&#123;add(u, v, c, id); add(v, u, 0, id);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &gt; 0 &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &gt; 0 &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; //freopen("2.in", "r", stdin); //freopen("2.my", "w", stdout); clr(head, -1); n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(), down = read(), up = read(); du[v] += down; du[u] -= down; dn[i] = down; add_edge(u, v, up - down, i); &#125; s = n + 1, t = n + 2; for(int i = 1; i &lt;= n; i ++)&#123; if(du[i] &gt; 0) add_edge(s, i, du[i], 0); else if(du[i] &lt; 0) add_edge(i, t, -du[i], 0); &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; flag = 1; for(int i = head[s]; ~i; i = g[i].nxt) if(g[i].c &gt; 0)&#123;flag = 0; break;&#125; if(!flag)&#123;printf("NO\n"); return ;&#125; printf("YES\n"); for(int i = 0; i &lt;= cnt; i ++)&#123; if(g[i].id &gt; 0 &amp;&amp; i % 2 == 1)&#123; anss[g[i].id] = dn[g[i].id] + g[i].c; &#125; &#125; for(int i = 1; i &lt;= m; i ++) printf("%d\n", anss[i]);&#125;int main()&#123; work(); return 0;&#125; 有源汇有上下界最大流题意：题目描述这是一道模板题。 n 个点，m 条边，每条边 e 有一个流量下界 lower(e) 和流量上界 upper(e) ，给定源点 s 与汇点 t ，求源点到汇点的最大流。 输入格式第一行两个正整数 n 、m 、s 、t。 之后的 m 行，每行四个整数 s 、t 、lower、upper。 输出格式如果无解，输出一行 please go home to sleep。 否则输出最大流。 样例样例输入1234567891011121314151610 15 9 109 1 17 189 2 12 139 3 11 121 5 3 41 6 6 71 7 7 82 5 9 102 6 2 32 7 0 13 5 3 43 6 1 23 7 6 75 10 16 176 10 10 117 10 14 15 样例输出143 题解：这个其实就是你先求一个可行流（从d向s连一条无下限容量为INF的弧，这就变成了无源汇有上下界可行流的问题），如果这个是满流的话（说明可以平衡），我们重新建一下图，泡个最大流就成了。 为什么重新跑一边就成呢？假设说我们继续在刚才的那个图上跑最大流，那么ans肯定等于之前算出来的可行流+残余网络中的最大流。既然我们已经填满了下限，何必再在原图上跑呢？新建一个图，它所跑出来的最大流肯定也是满足下限要求的（毕竟如果存在可行流，最大流的每条弧的流量肯定是往大里搞好啊）。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 1e6 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], du[MAXN], n, m, s, t, ss, tt, a[MAXN], b[MAXN], c[MAXN];queue &lt;int&gt; q;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &gt; 0 &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &gt; 0 &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); n = read(), m = read(); ss = read(), tt = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(), down = read(), up = read(); a[i] = u; b[i] = v; c[i] = up; du[v] += down; du[u] -= down; add_edge(u, v, up - down); &#125; s = n + 1, t = n + 2; add_edge(tt, ss, INF); int tot = 0; for(int i = 1; i &lt;= n; i ++)&#123; if(du[i] &gt; 0) add_edge(s, i, du[i]), tot += du[i]; else if(du[i] &lt; 0) add_edge(i, t, -du[i]); &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; if(ans != tot)&#123;printf("please go home to sleep\n"); return ;&#125; clr(head, -1); cnt = -1; for(int i = 1; i &lt;= m; i ++)&#123; add_edge(a[i], b[i], c[i]); &#125;s = ss, t = tt; int anss = 0; while(bfs())&#123; for(int i = 1; i &lt;= n; i ++) cur[i] = head[i]; anss += dfs(s, INF); &#125;printf("%d\n", anss);&#125;int main()&#123; work(); return 0;&#125; 有源汇有上下界最小流题意：题目描述n 个点，m 条边，每条边 e 有一个流量下界 lower(e) 和流量上界 upper(e) ，给定源点 s 与汇点 t，求源点到汇点的最小流。 输入格式第一行两个正整数 n 、m 、s 、t 。 之后的 m 行，每行四个整数 s 、t 、lower、upper。 输出格式如果无解，输出一行 please go home to sleep。 否则输出最小流。 样例样例输入123456789101112137 12 6 76 1 0 21474836471 7 0 21474836476 2 0 21474836472 7 0 21474836476 3 0 21474836473 7 0 21474836476 4 0 21474836474 7 0 21474836476 5 0 21474836475 7 0 21474836475 1 1 21474836473 4 1 2147483647 样例输出12 题解：我的第一反应就是：这东西的最小流不是他的最大流吗？ 后来看了题解·，并不是这样的。 因为循环流我们没有利用上。为了利用上循环流，我们再从t向s连一条无下限容量为INF的弧，向第一题一样跑个dinic，在满流的情况下，我们连的(t,s)的反向弧的已流容量就是答案。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], du[MAXN], cur[MAXN], n, m, ss, tt, S, T, ans = 0, s, t;queue &lt;int&gt; q;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &gt; 0 &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &gt; 0 &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void dinic()&#123; while(bfs())&#123; for(int i = 1; i &lt;= n + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125;&#125;void work()&#123; clr(head, -1); n = read(), m = read(), ss = read(), tt = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(), low = read(), up = read(); add_edge(u, v, up - low); du[u] -= low; du[v] += low; &#125; S = n + 1, T = n + 2; int tot = 0; for(int i = 1; i &lt;= n; i ++)&#123; if(du[i] &gt; 0) add_edge(S, i, du[i]), tot += du[i]; else if(du[i] &lt; 0) add_edge(i, T, -du[i]); &#125;s = S, t = T; add_edge(tt, ss, INF); dinic(); if(ans != tot)&#123;printf("please go home to sleep\n"); return ;&#125; printf("%d\n", g[cnt].c);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流24题总结]]></title>
    <url>%2F2017%2F12%2F27%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[网络流的建模确实不是很容易。但是通过这次刷题，我觉得网络流的建图都得基于以下两点： 1.我们想要（求）什么 2.我们需要保证什么条件 只要这个想清楚了，我觉得至少应付这24题应该是没什么问题（纯口hu）我当然不知道这24道题属于什么难度啦 题外话：貌似这里面掺杂了一些最短路、分层图之类的问题，然后我就没（不）有（会）做，所以这里面的总结当然不会是24道全的啦 loj有网络流24题系列，可以上loj做。 1.搭配飞行员题意：飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员，需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。 因为驾驶工作分工严格,两个正驾驶员或两个副驾驶员都不能同机飞行。 2≤n≤100 题解：二分图最大匹配瞎搞。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 115;const int MAXM = 1e4 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, n, m, cur[MAXN], s, t, d[MAXN];queue &lt;int&gt; q;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z; &#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c -= tmp; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void dinic()&#123; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; printf("%d\n", ans);&#125;void work()&#123; clr(head, -1); n = read(), m = read(); s = n + 1, t = n + 2; int x, y; while(~scanf("%d %d", &amp;x, &amp;y)) add_edge(x, y, 1); for(int i = 1; i &lt;= m; i ++) add_edge(s, i, 1); for(int i = m + 1; i &lt;= n; i ++) add_edge(i, t, 1); dinic();&#125;int main()&#123; work(); return 0;&#125; 2.太空飞行计划题意：W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合，和进行这些实验需要使用的全部仪器的集合。 W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 题解：显然的最大权闭合图，然后它要输出方案，我们dfs一下残量网络即可。 其实有更好的方法，就是直接判断最后一次bfs中，哪些点的d数组的值不为-1即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 115;const int MAXM = 1e4 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], m, n, s, t, dd[MAXN], len = 0;queue &lt;int&gt; q; bool vis[MAXN &lt;&lt; 1];inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); d[s] = 0; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].c)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void dfs1(int u)&#123; for(int i = head[u]; ~i; i = g[i].nxt)&#123; if(!(i % 2) &amp;&amp; g[i].c)&#123; int v = g[i].to; if(!vis[v])&#123;dd[++ len] = v; vis[v] = 1;&#125; dfs1(v); &#125; &#125;&#125;void work()&#123; clr(head, -1); m = read(), n = read(); s = n + m + 1, t = n + m + 2; int tot = 0; for(int i = 1; i &lt;= m; i ++)&#123; int w, x; char ch; scanf("%d", &amp;w); tot += w; add_edge(s, i, w); do &#123; ch = getchar(); if(ch == '\n' || ch == '\r' || ch == EOF) break; scanf("%d", &amp;x); add_edge(i, m + x, INF); &#125;while(ch != '\n' &amp;&amp; ch != '\r' &amp;&amp; ch != EOF); &#125; for(int i = m + 1; i &lt;= m + n; i ++)&#123; int w = read(); add_edge(i, t, w); &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n + m + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; dfs1(s); sort(dd + 1, dd + len + 1); for(int i = 1; i &lt;= m; i ++)&#123; if(~d[i]) printf("%d ", i); &#125;printf("\n"); for(int i = m + 1; i &lt;= m + n; i ++)&#123; if(~d[i]) printf("%d ", i - m); &#125;printf("\n"); printf("%d\n", tot - ans);&#125;int main()&#123; work(); return 0;&#125; 3.最小路径覆盖题意：点不能相交的有向图的最小路径覆盖。 题解：我们这样想： 如果每个点都单独成一条路径的话，我们需要n条路径覆盖。 如果有两个点连到了一起，我们就能减少一条路径。 如果再有两个点连到了一起，我们就又能减少一条路径。 所以，我们可以把这个有向图转化成一个二分图，具体转可以看代码。 然后跑一边最大匹配，n-最大匹配即为答案。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e4 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], n, m, s, t, cur[MAXN], dd[MAXN];queue &lt;int&gt; q; bool vis[MAXN];inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); d[s] = 0; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(tmp)&#123; dd[u] = v; if(v - n &gt; 0) vis[v - n] = 1; &#125; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); n = read(), m = read(); s = n * 2 + 1, t = n * 2 + 2; for(int i = 1; i &lt;= n; i ++) add_edge(s, i, 1); for(int i = n + 1; i &lt;= n * 2; i ++) add_edge(i, t, 1); for(int i = 1; i &lt;= m; i ++)&#123; int x = read(), y = read() + n; add_edge(x, y, 1); &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n * 2 + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; for(int i = 1; i &lt;= n; i ++)&#123; if(vis[i]) continue; printf("%d ", i); int k = i; while(dd[k])&#123; printf("%d ", dd[k] - n); k = dd[k] - n; &#125; printf("\n"); &#125; printf("%d\n", n - ans);&#125;int main()&#123; work(); return 0;&#125; 4.魔术球题意：假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1,2,3,4,⋯$ 的球。 每次只能在某根柱子的最上面放球。 在同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。 试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。 题解：这道题还是比较简单的。我们枚举答案，然后跑最大流看看可不可行，输出方案跟上一题差不多。 （我的方案输出写的好像有些问题呀。。。不过居然过了。。。） 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e5 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], dd[MAXN], cur[MAXN], n, s, t, tt[MAXN];queue &lt;int&gt; q; bool vis[MAXN], vis1[MAXN];inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); d[s] = 0; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(tmp)&#123; dd[u] = v; if(v - n &gt; 0) vis[v - 5015] = 1; &#125; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); n = read(); int ans = 0, need = 0; s = 8014, t = 8015; while(1)&#123; ans ++; need ++; for(int i = 1; i &lt; ans; i ++)&#123; if(sqrt(i + ans) == (int)sqrt(i + ans)) add_edge(i, ans + 5015, 1); &#125; add_edge(s, ans, 1); add_edge(ans + 5015, t, 1); int res = 0; while(bfs())&#123; for(int i = 0; i &lt;= 8015; i ++) cur[i] = head[i]; need -= dfs(s, INF); &#125; if(need == n) for(int i = 1; i &lt;= ans; i ++) tt[i] = dd[i], vis1[i] = vis[i]; if(need &gt; n) break; &#125; printf("%d\n", ans - 1); for(int i = 1; i &lt; ans; i ++)&#123; if(vis1[i]) continue; int k = i; printf("%d ", i); while(tt[k])&#123; printf("%d ", tt[k] - 5015); k = tt[k] - 5015; &#125; printf("\n"); &#125;&#125;int main()&#123; work(); return 0;&#125; 5. 圆桌聚餐题意：假设有来自 $n$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$ 。会议餐厅共有 $m$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。 试设计一个算法，给出满足要求的代表就餐方案。 题解：这道题我们的第一个任务就是判断是否存在可行解。 我们这样建图： s到每个公司连一条边，容量为$r_i$ 每个餐桌到t连一条边，容量为$c_i$ 每个公司向所有的餐桌各连一条边，容量为$1$ 跑最大流即可，判断一下最大流是否是总人数，是的话1，不是的话0 再考虑如何输出方案。 这个方案最好输出了！直接dfs每个公司到每个餐桌的连边，看看哪条边等于零了，就说明这个公司有代表坐在了这个餐桌上。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], r[MAXN], c[MAXN], m, n, s, t;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;queue &lt;int&gt; q;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].c)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); int tot = 0; m = read(), n = read(); s = m + n + 1, t = m + n + 2; for(int i = 1; i &lt;= m; i ++)&#123; r[i] = read(); tot += r[i]; add_edge(s, i, r[i]); for(int j = 1; j &lt;= n; j ++) add_edge(i, j + m, 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; c[i] = read(); add_edge(i + m, t, c[i]); &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= m + n + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; if(ans != tot)&#123;printf("0\n"); return ;&#125; printf("1\n"); for(int i = 1; i &lt;= m; i ++)&#123; for(int j = head[i]; ~j; j = g[j].nxt)&#123; int v = g[j].to; if(v != s &amp;&amp; !g[j].c) printf("%d ", v - m); &#125; printf("\n"); &#125;&#125;int main()&#123; work(); return 0;&#125; 6.最长递增子序列题意：给定正整数序列 $x_1∼x_n$，以下递增子序列均为非严格递增。 计算其最长递增子序列的长度 $s$ 。 计算从给定的序列中最多可取出多少个长度为 $s$ 的递增子序列。 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$，则从给定序列中最多可取出多少个长度为 $s$ 的递增子序列。 题解：我们一问一问考虑。 第一问：因为n小于等于500，$n^2$的dp即可。 第二问：这一问显然就要用到网络流了。我们要拆点（为什么？因为我们要控制一个点只选了1次），并在这两个拆出来的点连一条容量为1的边。然后呢？ 如果f[i]==ans1的话，那么从s到i的入点连一条容量为1的边。 如果f[i]==1的话，那么从i的出点到t连一条容量为1的边。 如果a[j]&gt;=a[i] &amp;&amp; j &gt; i &amp;&amp; f[j] == f[i] + 1（少一个条件都不可以！！！），那么从j的出点向i的入点连一条容量为1的边。 跑个最大流就成了。 第三问：把(s, 1), (1, 1), (s, n), (n, n), (1, t), (n, t)的容量改为INF（如果之前这两点有连边的话）。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], n, s, t, a[MAXN], f[MAXN];inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;queue &lt;int&gt; q;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].c)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); n = read(); s = n * 2 + 1, t = n * 2 + 2; for(int i = 1; i &lt;= n; i ++) a[i] = read(); for(int i = 1; i &lt;= n; i ++)&#123; f[i] = 1; for(int j = 1; j &lt; i; j ++) if(a[i] &gt;= a[j]) f[i] = max(f[i], f[j] + 1); &#125; int ans1 = 0; for(int i = 1; i &lt;= n; i ++) ans1 = max(ans1, f[i]); printf("%d\n", ans1); if(ans1 == 1)&#123;printf("%d\n%d\n", n, n); return ;&#125; for(int i = 1; i &lt;= n; i ++)&#123; if(f[i] == ans1) add_edge(s, i, 1); if(f[i] == 1) add_edge(i + n, t, 1); add_edge(i, i + n, 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = i + 1; j &lt;= n; j ++) if(f[j] == f[i] + 1) add_edge(j + n, i, 1); &#125; int ans2 = 0; while(bfs())&#123; for(int i = 1; i &lt;= n * 2 + 2; i ++) cur[i] = head[i]; ans2 += dfs(s, INF); &#125;printf("%d\n", ans2); cnt = -1; clr(head, -1); clr(cur, -1); for(int i = 1; i &lt;= n; i ++)&#123; if(f[i] == ans1) add_edge(s, i, (i == 1 || i == n) ? INF : 1); if(f[i] == 1) add_edge(i + n, t, (i == 1 || i == n) ? INF : 1); add_edge(i, i + n, (i == 1 || i == n) ? INF : 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = i + 1; j &lt;= n; j ++) if(a[j] &gt;= a[i] &amp;&amp; f[j] == f[i] + 1) add_edge(j + n, i, 1); &#125; int ans3 = 0; while(bfs())&#123; for(int i = 1; i &lt;= n * 2 + 2; i ++) cur[i] = head[i]; ans3 += dfs(s, INF); &#125;printf("%d\n", ans3);&#125;int main()&#123; work(); return 0;&#125; 7.试题库题意：假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 题解：这道题我感觉比前几道中的一些还要简单啊。 这个建图很好想：试卷需要的类型向t连一条容量为所需题目数的边；s向每道题连一条容量为1的边（保证每道题都只是用过1次）；每道题向自己所属的类型连一条容量为1的边。 跑最大流即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], k, n, s, t, r[MAXN], tt[MAXN];inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;queue &lt;int&gt; q;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].c)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); k = read(), n = read(); int m = 0; s = n + k + 1, t = n + k + 2; for(int i = 1; i &lt;= k; i ++)&#123; r[i] = read(); m += r[i]; if(r[i]) add_edge(i + n, t, r[i]); &#125; for(int i = 1; i &lt;= n; i ++)&#123; int p = read(); add_edge(s, i, 1); for(int j = 1; j &lt;= p; j ++)&#123; int x = read() + n; add_edge(i, x, 1); &#125; &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n + k + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; if(ans != m)&#123;printf("No Solution!\n"); return ;&#125; for(int i = 1; i &lt;= k; i ++)&#123; printf("%d:", i); for(int j = head[i + n]; ~j; j = g[j].nxt)&#123; if(j % 2 &amp;&amp; g[j].c) printf(" %d", g[j].to); &#125; printf("\n"); &#125;&#125;int main()&#123; work(); return 0;&#125; 8.方格取数题意：在一个有 $n\times m$ 个方格的棋盘中，每个方格中有一个正整数。 现要从方格中取数，使任意 2 个数所在方格没有公共边，且取出的数的总和最大。试设计一个满足要求的取数算法。 题解：这个是一个比较经典的方格类网络流的题。 我们首先要黑白染色，然后我们会发现一个很神奇的事情：相邻两个格子的颜色不一样！ 好，接下来s到每个染黑的点连一条容量为格子中的数的边，每个染白的点再向t连一条容量为格子中的数的边。然后相邻的格子（黑-&gt;白）连一条容量为INF的边。 我们把问题转化成了什么呢？最大点权独立集。 点权和-最大流（准确的说好像是点权和-最小割）即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define PI 3.14159265358979#define INF 0x7fffffffconst int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, d[MAXN], cur[MAXN], m, n, s, t, a[55][55], mark[55][55];int dx[5] = &#123;0, 1, -1, 0, 0&#125;;int dy[5] = &#123;0, 0, 0, 1, -1&#125;;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;queue &lt;int&gt; q;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].c)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); m = read(), n = read(); s = n * m + 1, t = n * m + 2; int tot = 0; for(int i = 1; i &lt;= m; i ++) for(int j = 1; j &lt;= n; j ++) mark[i][j] = (i - 1) * n + j; for(int i = 1; i &lt;= m; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; a[i][j] = read(); tot += a[i][j]; if((i + j) % 2 == 0) add_edge(s, mark[i][j], a[i][j]); else add_edge(mark[i][j], t, a[i][j]); &#125; &#125; for(int x1 = 1; x1 &lt;= m; x1 ++)&#123; for(int y1 = 1; y1 &lt;= n; y1 ++)&#123; if((x1 + y1) % 2 == 1) continue; for(int k = 1; k &lt;= 4; k ++)&#123; int x2 = x1 + dx[k], y2 = y1 + dy[k]; add_edge(mark[x1][y1], mark[x2][y2], INF); &#125; &#125; &#125; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n * m + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; printf("%d\n", tot - ans);&#125;int main()&#123; work(); return 0;&#125; 9.餐巾计划：题意：一个餐厅在相继的 $n$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 $P$ 分；或者把旧餐巾送到快洗部，洗一块需 $M$ 天，其费用为 $F$ 分；或者送到慢洗部，洗一块需 $N$ 天，其费用为 $S$ 分。 每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。 试设计一个算法为餐厅合理地安排好 $n$ 天中餐巾使用计划,使总的花费最小。 题解：终于到费用流了。。。 这个。。。我觉得这道题真的不错（虽说这个系列的题都不错），最好初学者自己想想。 如何建图： 1、从S向每个Xi连一条容量为ri，费用为0的有向边。 2、从每个Yi向T连一条容量为ri，费用为0的有向边。 3、从S向每个Yi连一条容量为无穷大，费用为p的有向边。 4、从每个Xi向Xi+1(i+1&lt;=N)连一条容量为无穷大，费用为0的有向边。 5、从每个Xi向Yi+m(i+m&lt;=N)连一条容量为无穷大，费用为f的有向边。 6、从每个Xi向Yi+n(i+n&lt;=N)连一条容量为无穷大，费用为s的有向边。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 2e4 + 15;const int MAXM = 2e6 + 15;const LL INF = 1e18;struct Edge&#123;LL to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];LL head[MAXN], cnt = -1, dist[MAXN], N, p, m, f, n, s, r[MAXN], S, T, pre[MAXN];queue &lt;LL&gt; q; bool inq[MAXN];inline void add(LL u, LL v, LL c, LL w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(LL u, LL v, LL c, LL w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r =r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa()&#123; clr(inq, 0); clr(pre, -1); for(LL i = 1; i &lt;= N * 2 + 2; i ++) dist[i] = INF; dist[S] = 0; q.push(S); inq[S] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(LL i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &lt;= 0 || dist[u] + g[i].w &gt;= dist[v]) continue; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;q.push(v); inq[v] = 1;&#125; &#125; &#125; return pre[T] != -1;&#125;void work()&#123; clr(head, -1); N = read(); S = N * 2 + 1, T = N * 2 + 2; p = read(); m = read(), f = read(); n = read(), s = read(); for(LL i = 1; i &lt;= N; i ++)&#123; r[i] = read(); add_edge(S, i, r[i], 0); add_edge(i + N, T, r[i], 0); &#125; for(LL i = 1; i &lt;= N; i ++) add_edge(S, i + N, INF, p); for(LL i = 1; i &lt; N; i ++) add_edge(i, i + 1, INF, 0); for(LL i = 1; i + m &lt;= N; i ++) add_edge(i, i + N + m, INF, f); for(LL i = 1; i + n &lt;= N; i ++) add_edge(i, i + N + n, INF, s); LL ans = 0; while(spfa())&#123; LL flow = INF; for(int i = T; i != S; i = g[pre[i] ^ 1].to)&#123; flow = Min(flow, g[pre[i]].c); &#125; for(int i = T; i != S; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; &#125; ans += dist[T] * flow; &#125; printf("%lld\n", ans);&#125;int main()&#123; work(); return 0;&#125; 10.数字梯形题意：给定一个由 $n$ 行数字组成的数字梯形如下图所示。梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。 分别遵守以下规则： 从梯形的顶至底的 $m$ 条路径互不相交； 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交； 从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。 题解：这道题有三问，确实都是不错的题。 对于第一问，m条路互不相交也就意味着每个点只经过一次，怎么维护？拆点！ 每个点的出点与他下一行的所能到达的两个点连一条容量为1，费用为自己的数值的边。 s与第一行的点的入点连一条容量为1，费用为0的边。 第n行的点的出点与t连一条容量为1，费用为0的边。 跑最大费用最大流。 第二问呢？ 第二问意味着不用拆点了。 并且把第n行的点与t的连边改成容量为INF，费用为自己的数值就完了。 第三问呢？ 所有的（除了s道第一行的各点的）弧全都改为容量为INF。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, dist[MAXN], pre[MAXN], m, n, a[MAXN][MAXN], mark[MAXN][MAXN], s, t;queue &lt;int&gt; q; bool inq[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa()&#123; clr(pre, -1); clr(dist, 0xc0); clr(inq, 0); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &gt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void work()&#123; clr(head, -1); m = read(), n = read(); int tmp = 0; for(int i = 1; i &lt;= n; i ++)&#123; int p = m + i - 1; for(int j = 1; j &lt;= p; j ++)&#123; a[i][j] = read(); tmp ++; mark[i][j] = tmp; &#125; &#125; s = tmp * 2 + 1; t = tmp * 2 + 2; for(int i = 1; i &lt;= n; i ++)&#123; int p = m + i - 1; for(int j = 1; j &lt;= p; j ++)&#123; if(mark[i + 1][j]) add_edge(mark[i][j] + tmp, mark[i + 1][j], 1, 0); if(mark[i + 1][j + 1]) add_edge(mark[i][j] + tmp, mark[i + 1][j + 1], 1, 0); add_edge(mark[i][j], mark[i][j] + tmp, 1, a[i][j]); if(i == 1) add_edge(s, mark[i][j], 1, 0); if(i == n) add_edge(mark[i][j] + tmp, t, 1, 0); &#125; &#125; int ans1 = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans1 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans1); clr(head, -1); cnt = -1; for(int i = 1; i &lt;= n; i ++)&#123; int p = m + i - 1; for(int j = 1; j &lt;= p; j ++)&#123; if(mark[i + 1][j]) add_edge(mark[i][j], mark[i + 1][j], 1, a[i][j]); if(mark[i + 1][j + 1]) add_edge(mark[i][j], mark[i + 1][j + 1], 1, a[i][j]); if(i == 1) add_edge(s, mark[i][j], 1, 0); if(i == n) add_edge(mark[i][j], t, INF, a[i][j]); &#125; &#125; int ans2 = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans2 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans2); clr(head, -1); cnt = -1; for(int i = 1; i &lt;= n; i ++)&#123; int p = m + i - 1; for(int j = 1; j &lt;= p; j ++)&#123; if(mark[i + 1][j]) add_edge(mark[i][j], mark[i + 1][j], INF, a[i][j]); if(mark[i + 1][j + 1]) add_edge(mark[i][j], mark[i + 1][j + 1], INF, a[i][j]); if(i == 1) add_edge(s, mark[i][j], 1, 0); if(i == n) add_edge(mark[i][j], t, INF, a[i][j]); &#125; &#125; int ans3 = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans3 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans3);&#125;int main()&#123; work(); return 0;&#125; 11.运输问题题意：W 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。货物供需平衡。从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_j$。试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。 题解：这个。。。太水了吧。。。好像都不用动脑子，瞎搞一搞就好了、 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, dist[MAXN], pre[MAXN], a[MAXN], b[MAXN], c[MAXN][MAXN], m, n, s, t;queue &lt;int&gt; q; bool inq[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa1()&#123; clr(dist, 0x3f); clr(inq, 0); clr(pre, -1); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &lt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;bool spfa2()&#123; clr(dist, 0xc0); clr(inq, 0); clr(pre, -1); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &gt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void work()&#123; clr(head, -1); m = read(), n = read(); s = (m + n) * 2 + 1, t = (m + n) * 2 + 2; for(int i = 1; i &lt;= m; i ++) a[i] = read(); for(int j = 1; j &lt;= n; j ++) b[j] = read(); for(int i = 1; i &lt;= m; i ++) for(int j = 1; j &lt;= n; j ++) c[i][j] = read(); for(int i = 1; i &lt;= m; i ++)&#123; add_edge(s, i, a[i], 0); for(int j = 1; j &lt;= n; j ++)&#123; add_edge(i, j + m, a[i], c[i][j]); if(i == 1) add_edge(j + m, t, b[j], 0); &#125; &#125; int ans1 = 0; while(spfa1())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123;flow = min(flow, g[pre[i]].c);&#125; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans1 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans1); clr(head, -1); cnt = -1; for(int i = 1; i &lt;= m; i ++)&#123; add_edge(s, i, a[i], 0); for(int j = 1; j &lt;= n; j ++)&#123; add_edge(i, j + m, a[i], c[i][j]); if(i == 1) add_edge(j + m, t, b[j], 0); &#125; &#125; int ans2 = 0; while(spfa2())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123;flow = min(flow, g[pre[i]].c);&#125; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans2 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans2); &#125;int main()&#123; work(); return 0;&#125; 12.分配问题题意：有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{i,j}$。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最大。 题解：太弱了。。。这尼玛哪用动脑子，简直就是裸的模板啊啊啊 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, dist[MAXN], pre[MAXN], c[MAXN][MAXN], n, s, t;queue &lt;int&gt; q; bool inq[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa1()&#123; clr(dist, 0x3f); clr(inq, 0); clr(pre, -1); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &lt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;bool spfa2()&#123; clr(dist, 0xc0); clr(inq, 0); clr(pre, -1); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &gt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void work()&#123; clr(head, -1); n = read(); s = n * 2 + 1, t = n * 2 + 2; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= n; j ++) c[i][j] = read(); for(int i = 1; i &lt;= n; i ++)&#123; add_edge(s, i, 1, 0); for(int j = 1; j &lt;= n; j ++)&#123; add_edge(i, j + n, 1, c[i][j]); if(i == 1) add_edge(j + n, t, 1, 0); &#125; &#125; int ans1 = 0; while(spfa1())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123;flow = min(flow, g[pre[i]].c);&#125; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans1 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans1); clr(head, -1); cnt = -1; for(int i = 1; i &lt;= n; i ++)&#123; add_edge(s, i, 1, 0); for(int j = 1; j &lt;= n; j ++)&#123; add_edge(i, j + n, 1, c[i][j]); if(i == 1) add_edge(j + n, t, 1, 0); &#125; &#125; int ans2 = 0; while(spfa2())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123;flow = min(flow, g[pre[i]].c);&#125; for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans2 += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans2); &#125;int main()&#123; work(); return 0;&#125; 13.负载平衡题意：G 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 题解：这个。。。自己看代码吧。以上三题都比较水。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, dist[MAXN], pre[MAXN], n, s, t, a[MAXN];queue &lt;int&gt; q; bool inq[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa()&#123; clr(pre, -1); clr(dist, 0x3f); clr(inq, 0); dist[s] = 0; q.push(s); inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &lt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;q.push(v); inq[v] = 1;&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void work()&#123; clr(head, -1); n = read(); s = n + 1, t = n + 2; int tot = 0; for(int i = 1; i &lt;= n; i ++)&#123; a[i] = read(); tot += a[i]; &#125; tot /= n; for(int i = 1; i &lt;= n; i ++)&#123; if(i != n) add_edge(i, i + 1, INF, 1); else add_edge(i, 1, INF, 1); if(i != 1) add_edge(i, i - 1, INF, 1); else add_edge(i, n, INF, 1); add_edge(i, t, tot, 0); add_edge(s, i, a[i], 0); &#125; int ans = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125; 14.最长 k 可重区间集题意：网址：传送门 题解：我们不知道这个开区间到底会有多长，所以我们首先肯定要离散化一下。 然后接下来就简单了。由于我们要限制每个点最多只能被覆盖k次，所以我们只给这个网络k的流量，没选一条，就将这段区间的剩余流量-1，具体实现就是i-&gt;i+1连一条容量为INF，费用为0的边；对于备选线段i-&gt;j，我们从i向j连一条容量为1，费用为其长度的边。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, dist[MAXN], pre[MAXN], n, k, s, t, l[MAXN], r[MAXN], dd[MAXN &lt;&lt; 1], len = 0, mark[MAXM];queue &lt;int&gt; q; bool inq[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa()&#123; clr(inq, 0); clr(dist, 0xc0); clr(pre, -1); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &gt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void work()&#123; clr(head, -1); n = read(); k = read(); for(int i = 1; i &lt;= n; i ++)&#123; l[i] = read(), r[i] = read(); if(l[i] &gt; r[i]) swap(l[i], r[i]); dd[++ len] = l[i], dd[++ len] = r[i]; &#125; sort(dd + 1, dd + len + 1); s = len + 1, t = len + 2; for(int i = 1; i &lt;= len; i ++) mark[dd[i]] = i; add_edge(s, 1, k, 0); add_edge(len, t, k, 0); for(int i = 1; i &lt; len; i ++) add_edge(i, i + 1, INF, 0); for(int i = 1; i &lt;= n; i ++)&#123; add_edge(mark[l[i]], mark[r[i]], 1, r[i] - l[i]); &#125; int ans = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125; 15.星际转移题意：网址：传送门 题解：这个属于枚举答案，构造网络流判定的问题，前面好像有一道什么柱子放球的问题，这两个应该是差不多的，只不过这个建图更难一些。 首先判断从地球到月球是否存在一条路线，如果不存在那么无解，否则把每个太空站按照每天拆分成d个点，表示第i个站第d天。建立附加源S汇T，顺序枚举答案Day。 1、对于第Day天，从S到连接一条容量为无穷大的有向边。2、从&lt;−1,Day&gt;到T连接一条容量为无穷大的有向边。3、对于第i个太空船，设第Day-1天在a处，第Day天在b处，从到连接一条容量为该太空船容量的有向边。4、对于第i个太空站，从到连接一条容量为无穷大的有向边。5、求当前网络最大流，如果最大流量大于等于地球上人数K，停止枚举，当前Day值就是答案。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define PI 3.14159265358979#define INF 0x7fffffff#define clr(x, y) memset(x, y, sizeof(x))const int MAXN = 1e4 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, fa[MAXN], cur[MAXN], d[MAXN], n, m, k, s, t, wgt[MAXN], tt[MAXN], stop[MAXN][MAXN], mark[MAXN][MAXN]; //mark[i][j]表示第j天太空站（地球：n+1 月球：n+2）i的编号 queue &lt;int&gt; q;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int getfa(int x)&#123;return x == fa[x] ? x : fa[x] = getfa(fa[x]);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(d, -1); q.push(s); d[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == -1)&#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; return d[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; d[v] == d[u] + 1)&#123; int tmp = dfs(v, min(g[i].c, flow)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) d[u] = -1; return ret;&#125;void work()&#123; clr(head, -1); n = read(), m = read(), k = read(); s = 0, t = 8015; for(int i = 1; i &lt;= n + 2; i ++) fa[i] = i; int earth = n + 1, moon = n + 2; for(int i = 1; i &lt;= m; i ++)&#123; wgt[i] = read(); tt[i] = read(); bool flag = 0; for(int j = 1; j &lt;= tt[i]; j ++)&#123; stop[i][j] = read(); if(stop[i][j] == 0) stop[i][j] = earth; if(stop[i][j] == -1) stop[i][j] = moon; int f1 = getfa(stop[i][1]), f2 = getfa(stop[i][j]); if(f1 != f2 &amp;&amp; j != 1) fa[f2] = f1; &#125; &#125; int tmp = 0; for(int i = 1; i &lt;= n + 2; i ++)&#123; for(int j = 0; j &lt;= 515; j ++)&#123; tmp ++; mark[i][j] = tmp; &#125; &#125; if(getfa(earth) != getfa(moon))&#123;printf("0\n"); return ;&#125; int Day = 0, ans = 0; add_edge(s, mark[earth][0], INF); add_edge(mark[moon][0], t, INF); while(ans &lt; k)&#123; Day ++; add_edge(s, mark[earth][Day], INF); add_edge(mark[moon][Day], t, INF); for(int i = 1; i &lt;= m; i ++)&#123; int a = stop[i][(Day - 1) % tt[i] + 1], b = stop[i][Day % tt[i] + 1]; add_edge(mark[a][Day - 1], mark[b][Day], wgt[i]); &#125; for(int i = 1; i &lt;= n; i ++) add_edge(mark[i][Day - 1], mark[i][Day], INF); while(bfs())&#123; for(int i = 0; i &lt;= 8015; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; &#125; printf("%d\n", Day);&#125;int main()&#123; work(); return 0;&#125; 16.航空路线问题题意：给定一张航空图，图中顶点代表城市，边代表两个城市间的直通航线。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。 除起点城市外，任何城市只能访问一次。 对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。 题解：这个。。。我们看到了任何城市只能访问一次，就知道了这道题肯定是要拆点的。 然后瞎搞不就完了吗。。。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));#define INF 0x7fffffffusing namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, dist[MAXN], pre[MAXN], n, m, s, t;queue &lt;int&gt; q; bool inq[MAXN]; map &lt;string, int&gt; a; map &lt;int, string&gt; b;string ss1[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa()&#123; clr(inq, 0); clr(pre, -1); clr(dist, 0xc0); q.push(s); dist[s] = 0; inq[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &gt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void print(int u)&#123; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(v == t) break; if(!g[i].c)&#123; if(u == 1 + n) g[i].c = 1; cout &lt;&lt; b[v] &lt;&lt;endl; print(v + n); break; &#125; &#125;&#125;void print2(int u)&#123; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(v == t) break; if(!g[i].c)&#123; print2(v + n); if(b[v] != ss1[n]) cout &lt;&lt; b[v] &lt;&lt;endl; break; &#125; &#125;&#125;void work()&#123; clr(head, -1); n = read(), m = read(); s = n * 2 + 1, t = n * 2 + 2; for(int i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; ss1[i]; a[ss1[i]] = i; b[i] = ss1[i]; if(i == 1 || i == n) add_edge(i, i + n, 2, 1); else add_edge(i, i + n, 1, 1); &#125; add_edge(s, 1, 2, 0); add_edge(n * 2, t, 2, 0); int flag = cnt - 1; for(int i = 1; i &lt;= m; i ++)&#123; string x, y; cin &gt;&gt; x &gt;&gt; y; int xx = a[x], yy = a[y]; if(xx &gt; yy) swap(xx, yy); if(xx == 1 &amp;&amp; yy == n) add_edge(xx + n, yy, 2, 0); else add_edge(a[x] + n, a[y], 1, 0); &#125; int ans = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans += flow * g[pre[i]].w; &#125; &#125; if(g[flag].c)&#123;printf("No Solution!\n"); return ;&#125; cout&lt;&lt;ans - 2&lt;&lt;endl; print(s); print2(s);&#125;int main()&#123; work(); return 0;&#125; 17.深海机器人问题题意：深海资源考察探险队的潜艇将到达深海的海底进行科学考察。 潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。 深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。 每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。 本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。 用一个 $P\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为$ (Q,P)$。 给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。 计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。 题解：这道题。。。我很草率的就A了，但是后面的一道题让我思考了良久，下一题再说这个问题是什么。 这道题我没拆点，因为不拆点看起来是对的（自己想想就知道了）。 建图就不说了，挺简单的。 当然，这道题拆点肯定是能做的，甚至这个方法比较好想。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 1e3 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int to, nxt, c, w;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = -1, pre[MAXN], dist[MAXN], mark[MAXN][MAXN], a, b, p, q, s, t, n, m;queue &lt;int&gt; q1; bool inq[MAXN];inline void add(int u, int v, int c, int w)&#123;g[++ cnt] = (Edge)&#123;v, head[u], c, w&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c, int w)&#123;add(u, v, c, w); add(v, u, 0, -w);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool spfa()&#123; clr(inq, 0); clr(pre, -1); clr(dist, 0xc0); q1.push(s); dist[s] = 0; inq[s] = 1; while(!q1.empty())&#123; int u = q1.front(); q1.pop(); inq[u] = 0; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dist[u] + g[i].w &gt; dist[v])&#123; dist[v] = dist[u] + g[i].w; pre[v] = i; if(!inq[v])&#123;inq[v] = 1; q1.push(v);&#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void work()&#123; clr(head, -1); a = read(), b = read(); p = read() + 1, q = read() + 1; int tmp = 0; s = p * q + 1, t = p * q + 2; for(int i = 1; i &lt;= p; i ++) for(int j = 1; j &lt;= q; j ++) mark[i][j] = ++ tmp; for(int i = 1; i &lt;= p; i ++)&#123; for(int j = 1; j &lt; q; j ++)&#123; int x = read(); add_edge(mark[i][j], mark[i][j + 1], 1, x); add_edge(mark[i][j], mark[i][j + 1], INF, 0); &#125; &#125; for(int i = 1; i &lt;= q; i ++)&#123; for(int j = 1; j &lt; p; j ++)&#123; int x = read(); add_edge(mark[j][i], mark[j + 1][i], 1, x); add_edge(mark[j][i], mark[j + 1][i], INF, 0); &#125; &#125; for(int i = 1; i &lt;= a; i ++)&#123; int k = read(), x = read() + 1, y = read() + 1; add_edge(s, mark[x][y], k, 0); &#125; for(int i = 1; i &lt;= b; i ++)&#123; int k = read(), x = read() + 1, y = read() + 1; add_edge(mark[x][y], t, k, 0); &#125; int ans = 0; while(spfa())&#123; int flow = INF; for(int i = t; i != s; i = g[pre[i] ^ 1].to) flow = min(flow, g[pre[i]].c); for(int i = t; i != s; i = g[pre[i] ^ 1].to)&#123; g[pre[i]].c -= flow; g[pre[i] ^ 1].c += flow; ans += flow * g[pre[i]].w; &#125; &#125; printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125; 18.火星探险问题题意：火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。 登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。 探测车在移动中还必须采集岩石标本。 每一块岩石标本由最先遇到它的探测车完成采集。 每块岩石标本只能被采集一次。 岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。 探测车不能通过有障碍的地面。 本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。 如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。 用一个 $P\times Q$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 $(X_1,Y_1)$ 处，传送器 的位置在 $(X_P,Y_Q)$处。 给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多， 而且探测车采集到的岩石标本的数量最多。 题解：这道题我最开始也想用和上一题差不多的方法，然而，发现是错的，就是为什么是错的呢？ 这种的走格子的如果转化成上一题走边的话，你会发现有一些边加了很多次，所以这显然是错的。拆点做的话，便能很好的限制一条边被算了两次。 如果我们把这道题改改，我们依然走格子，但是权值在边上呢？这时候，我能可以发现，我们把这个图转化成跟上一问差不多的图，是没有问题的，是不会有边算了2次的。 如果没有懂得话，可以结合下面的图看一看。 19.骑士共存问题题意：在一个 $n\times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。 对于给定的 n×n\text{n} \times \text{n}n×n 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。 题解：这道题又是一个方格问题。首先我们要做的还是染色。染完色后我们发现两个能互相攻击的骑士颜色互不相同，然后有冲突的连边，算最大点独立集即可。 心得：这次收获还是蛮大的，20道题刷了2.5天，速度还是有些慢了，一天才8道，不过这才刚开始，倒是还能接受。估计这20题也让我把网络流的大部分常见的建模套路全都熟悉了一边，所以说收获真的始挺大的。]]></content>
      <categories>
        <category>总结</category>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合图求欧拉回路]]></title>
    <url>%2F2017%2F12%2F27%2F%E6%B7%B7%E5%90%88%E5%9B%BE%E6%B1%82%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[刚学完网络流，正好看到了这个混合图求欧拉回路也是用网络流做，就学了学。 先推荐一篇blog，写的是真好：混合图求欧拉回路 我这篇也是从他那里转的。 算法目的：求混合图(有的边是单向，有的边是双向)的欧拉回路 预备知识： 1.无向图欧拉回路求法（其实就是dfs） 2.有向图欧拉回路球阀（其实就是无向图的dfs倒着输出） 3.网络流算法 大概思路： 1.先对所有无向边进行任意定向，即随机为他们确定一个方向2.此时这张图变成了一个有向图，我们计算出所有点的入度和出度，如果有点的入度与出度的奇偶性不同，那么无解 3.将所有入度&gt;出度的点向超级汇点连一条容量为$\frac{入度−出度}{2}$的边，超级源点向所有出度&gt;入度的点连一条容量为$\frac{出度−入度}{2}$的边，然后对于原图中所有的定向为(a,b)无向边连一条从a到b容量为1的边4.跑网络流，如果正好能使所有从超级源点出来的边满流，则有解5.把在网络流中那些因为原图无向边而建的流量为1的边中经过流量的边反向，就形成了一个能跑出欧拉回路的有向图，如果要求方案，用有向图求欧拉回路的方法求解即可 算法解析： 第一步先定向没什么好说的。根据预备知识我们可以得到，只有当所有点的“入度=出度”时，这张图才能有欧拉回路。所以我们的目标是调整“无向边”的方向使得每个点的入度等于出度。而考虑我们刚才所进行的网络流建图，从源到汇的一条增广路中经过的那些“原来是无向边而产生的边”，相当于把它们全部进行反向。这样造成的后果就是中间经过的那些点出度入度不变，只有一开始的点入度+1，出度-1、最后的点入度-1，出度+1.所以当源点到一个点的那条边满流时，就意味着这个点的出度已经等于入度了，自调整的过程已经完成。而当全部的点全部完成这一事件时，就说明已经能找到一条欧拉回路了。]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>欧拉回路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vijos 1880 ファーラの力 题解]]></title>
    <url>%2F2017%2F12%2F27%2Fvijos-1880%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：背景窗外斜阳 日暮西山 倚栏眺想着当年气盛青涩的年少时光湍急 岁月汹涌 物是人已非年年我挥汗洒泪赴沙场 描述Ninian 的魔力可以在结界间传递。结界中有 N 个光柱，第 i 个光柱的光压范围为 0~Ei 。魔力可以有 M 种传递，从光柱 Ai 传递到光柱 Bi ，花费时间 Ti 。当魔力从光压为 S 传递并花费了 T 的时间后，就会衰减到光柱上光压为 S-T 处，S-T 不能为负。Ninian 可以将魔力的光压花费 1 时间增加 1 或减少 1 ，当然魔力的光压不能超过光柱的光压范围，也不能小于 0 。Ninian 的魔力初始在 1 号光柱，光压为 X 。问 Ninian 的魔力到达第 N 个光柱且光压最大所需要的最少时间。 格式输入格式第一行三个整数 N, M, X 。接下来的 N 行每行一个整数表示 Ei 。接下来的 M 行每行三个整数表示 Ai, Bi, Ti 。 输出格式输出一个整数表示所需的最少时间，如果 Ninian 的魔力无法到达，输出 -1 。 题解：这道题我倒是想了一个下午。。。估（肯）计（定）是我太蠢了。。。 我们先考虑x=0的情况，x=0的话，我们何时往上加都是一样的，所以说，我们直接跑个最短路dist，ans就是dist*2+h[n]就完了（为什么乘2呢？一个是时间上的，一个是光压上的补满（这样我就不难发现1单位的时间换1单位的光压，这个在接下来的分析中很有用）） 好了，接下来我们该考虑一下x!=0的情况了（其实x=0就是一种特殊情况）。 首先我们要知道，往上加光压何时做都是等效的，这样的话我们最后再加光压，然后我们每到一个光柱的时候，所在的光压一定是递减的。 我们先算出（先不用管怎么算）f[n]（表示不加光压，到n的最大光压）。 这时候我们统计答案的时候分类讨论： 1.当f[n]&gt;0时，这说明我们所走过的所有的光压值都没有&lt;0（因为是递减的）。那么这时候我们要做的就是算上走过的时间以及补满的时间。走过的时间就是x-f[n]，补满的时间就是h[n]-f[n]，所以说ans就是x+h[n]-f[n]*2。 2.当f[n]&lt;0时，我们还是要算走过的时间和补满的时间，走过的时间就是x-f[n]，补满的时间就是h[n]-f[n]（可以理解成先用-f[n]的时间补到0，然后+h[n]补满），所以说ans就是x+h[n]-f[n]*2。 呵呵，貌似不用分类讨论（我大概是个zz）。 怎么算f[n]呢？即我们怎样才能得到最大光压。显然，最短路所得到的一定是最大的，所以跑最短路就完了。 注意：这道题要开LL，同时，INF要开的大点，要不然就会跟我一样gg了半天。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex&lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))const LL MAXN = 1e6 + 15;const LL INF = 1e16;struct Edge&#123;LL to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];LL head[MAXN], cnt = 0, h[MAXN], dist[MAXN], n, m, x, f;queue &lt;LL&gt; q; bool vis[MAXN];inline void add(LL u, LL v, LL dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(LL u, LL v, LL dis)&#123;if(h[u] &gt;= -dis) add(u, v, dis); if(h[v] &gt;= -dis) add(v, u, dis);&#125;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void spfa()&#123; for(LL i = 1; i &lt;= n; i ++) dist[i] = -INF; q.push(1); dist[1] = x; vis[1] = 1; while(!q.empty())&#123; LL u = q.front(); q.pop(); vis[u] = 0; for(LL i = head[u]; i; i = g[i].nxt)&#123; LL v = g[i].to; if(dist[v] &lt; dist[u] + g[i].dis)&#123; dist[v] = min(dist[u] + g[i].dis, h[v]); if(!vis[v])&#123;vis[v] = 1; q.push(v);&#125; &#125; &#125; &#125; f = dist[n];&#125;void work()&#123; n = read(), m = read(), x = read(); for(LL i = 1; i &lt;= n; i ++) h[i] = read(); for(LL i = 1; i &lt;= m; i ++)&#123; LL u = read(), v = read(), t = read(); add_edge(u, v, -t); &#125; spfa(); if(f == -INF) printf("-1\n"); else printf("%lld\n", x + h[n] - f * 2);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI 2010 Bridges 题解]]></title>
    <url>%2F2017%2F12%2F27%2FPOI-2010-Bridges-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：题目描述San Bytecisco is a beautifully situated coastal town. It consists of small, yet densely populated islands, numbered from to . Certain islands are connected with bridges, used for (bidirectional) road traffic. Each pair of islands can be connected with at most one bridge. The islands are connected in such a way that every island can be reached from every other by using the bridges only. Byteasar and Bytie are going for a bike trip in San Bytecisco. The will start their ride at the island no. 1. They intend to visit every island, while passing along every bridge once and ending the trip where it began, i.e., the island no. 1. Being quite seasoned riders, they expect some serious trouble from… the wind! After all, it is very windy along the coast, and especially so on the bridges between the islands. Obviously, depending on its speed and direction, the wind makes it hard to cross the bridge in different extent for either direction. For simplicity we will assume for every bridge and direction of crossing, the opposing wind speed is constant. Help Byteasar and Bytie to find a route as they desire that will in addition be the least tiresome. Byteasar and Bytie agreed on the maximum opposing wind speed as a measure of a route’s tiresomeness. InputIn the first line of the standard input there are two integers separated by a single space: and (, ), denoting the number of islands and the number of bridges in San Bytecisco respectively. The islands are numbered from 1 to , while the bridges from 1 to . The following lines specify the bridges. The line no. contains four integers , , , (, , ), separated by single spaces. These denote that the bridge no. connects the islands no. and . The opposing wind speeds are when one goes moves from to , and if one goes from to . OutputIf there is no route satisfying the requirements of the daring two riders, the first and only line of the standard output should hold the word NIE (no in Polish). Otherwise, the output should have two lines, specifying the least tiresome route over San Bytecisco. The first line should hold the maximum opposing wind speed for that route, i.e., the number we wish to minimize. The second line should hold integers, separated by single spaces, giving the numbers of successive bridges one crosses on the least tiresome route. Should there be more than one least tiresome route, your program can pick one arbitrarily. 题解：这道题裸的混合图求欧拉回路，直接搞就完了，输出方案的时候倒着输出即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex &lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 707185547const int MAXN = 1e4 + 15;const int MAXM = 1e6 + 15;struct Edge&#123;int from, to, nxt, c;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt, du[MAXN], dd[MAXN], cur[MAXN], n, m, a[MAXN], b[MAXN], c[MAXN], d[MAXN], s, t, tot = 0, e[1005][1005], ans[MAXN], len = 0;queue &lt;int&gt; q;inline void add(int u, int v, int c)&#123;g[++ cnt] = (Edge)&#123;u, v, head[u], c&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int c)&#123;add(u, v, c); add(v, u, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool bfs()&#123; clr(dd, -1); q.push(s); dd[s] = 0; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dd[v] == -1)&#123; dd[v] = dd[u] + 1; q.push(v); &#125; &#125; &#125; return dd[t] != -1;&#125;int dfs(int u, int flow)&#123; if(u == t) return flow; int ret = 0; for(int&amp; i = cur[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(g[i].c &amp;&amp; dd[v] == dd[u] + 1)&#123; int tmp = dfs(v, min(flow, g[i].c)); flow -= tmp; g[i].c -= tmp; ret += tmp; g[i ^ 1].c += tmp; if(!flow) break; &#125; &#125; if(!ret) dd[u] = -1; return ret;&#125;int dinic()&#123; int ans = 0; while(bfs())&#123; for(int i = 1; i &lt;= n + 2; i ++) cur[i] = head[i]; ans += dfs(s, INF); &#125; return ans;&#125;bool pd(int mid)&#123; clr(head, -1); cnt = -1; s = n + 1, t = n + 2; for(int i = 1; i &lt;= m; i ++)&#123; if(c[i] &gt; mid) return 0; if(d[i] &lt;= mid) add_edge(a[i], b[i], 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; if(du[i] &gt; 0) add_edge(s, i, du[i] / 2); else if(du[i] &lt; 0) add_edge(i, t, -du[i] / 2); &#125; if(dinic() == tot / 2) return 1; return 0;&#125;void dfs(int x)&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(e[x][i])&#123; e[x][i] = 0; dfs(i); &#125; &#125; ans[++ len] = x;&#125;void print(int mid)&#123; for(int i = 0; i &lt;= cnt; i += 2)&#123; if(g[i].from == s || g[i].to == t) continue; if(g[i].c == 0) e[g[i].to][g[i].from] = 1; else e[g[i].from][g[i].to] = 1; &#125; for(int i = 1; i &lt;= m; i ++)&#123; if(c[i] &lt;= mid &amp;&amp; d[i] &gt; mid) e[a[i]][b[i]] = 1; &#125; /* for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; if(e[i][j]) printf("%d --&gt; %d\n", i, j); &#125; &#125; */ dfs(1);//printf("\n");&#125;void work()&#123; clr(head, -1); n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; a[i] = read(), b[i] = read(), c[i] = read(), d[i] = read(); if(d[i] &lt; c[i])&#123;swap(a[i], b[i]); swap(c[i], d[i]);&#125; du[a[i]] ++; du[b[i]] --; &#125; for(int i = 1; i &lt;= n; i ++)&#123; if(du[i] % 2 != 0)&#123;printf("NIE\n"); return ;&#125; tot += abs(du[i]) / 2; &#125; int l = 1, r = 1000; while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(pd(mid)) r = mid; else l = mid + 1; &#125; printf("%d\n", l); int nonsense = pd(l); print(l); clr(e, 0); for(int i = 1; i &lt;= m; i ++)&#123; e[a[i]][b[i]] = e[b[i]][a[i]] = i; &#125; for(int i = len; i &gt; 1; i --)&#123; printf("%d ", e[ans[i]][ans[i - 1]]); &#125; printf("\n");&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>欧拉回路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loj2323 [清华集训]小Y和地铁 题解]]></title>
    <url>%2F2017%2F12%2F27%2Floj2323%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：小Y是一个爱好旅行的OIer。一天，她来到了一个新的城市。由于不熟悉那里的交通系统，她选择了坐地铁。 她发现每条地铁线路可以看成平面上的一条曲线，不同线路的交点处一定会设有换乘站。通过调查得知，没有线路是环线，也没有线路与自身相交。任意两条不同的线路只会在若干个点上相交，没有重合的部分，且没有三线共点的情况。即，如图所示的情况都是不存在的： 小Y坐着地铁 0 号线，路上依次经过了 n 个换乘站。她记下了每个换乘站可以换乘的线路编号，发现每条线路与她所乘坐的线路最多只有 2 个换乘站。现在小Y想知道，除掉她经过的换乘站以外，这个城市里最少有几个换乘站。只有你告诉她正确的答案，她才会答应下次带你去玩呢。 题解：这道题呀，反正我这种蒟蒻不会想到这题竟然是个爆搜。。。 首先，得说明一条性质： 这两种是等价的（旋转一下就可以得到另外一个）。 好，接下来我来讲讲怎么爆搜。 我们可以不用考虑与0号线只交了1个点的线路（一个点就能自成线路），只记录交了2次的。然后我们维护右端点是从上面过来的，还是从下面过来的。维护信息的时候用个树状数组就可以了，代码里有更详细的解释，在这就不赘述了。 注意：枚举右端点的时候为什么左端点取个min就成了？即证明这个贪心为什么是对的。 我们判断一下连通性就好了。 如图，最左边这一列显然不用考虑，我们看右半部分。 对于上边的图，2和3不连通，5和6连通。 对于下边的图，2‘和3’不连通，5‘和6’连通。 连通性是一样的，所以说这个贪心是没问题的。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex&lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 115;int a[MAXN], l[MAXN], r[MAXN], T, n, cnt = 0, ans;struct szsz&#123; int s[MAXN]; void init()&#123;clr(s, 0);&#125;; void add(int x, int v)&#123;for(; x &lt;= MAXN; x += x &amp; -x) s[x] += v;&#125; int getsum(int x)&#123;int ret = 0; for(; x; x -= x &amp; -x) ret += s[x]; return ret;&#125; int query(int l, int r)&#123;return getsum(r) - getsum(l - 1);&#125;&#125;up, down;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void dfs(int j, int now)&#123; if(now &gt; ans) return ; if(j &gt; cnt)&#123;if(now &lt; ans) ans = now; return ;&#125; up.add(r[j], 1); dfs(j + 1, now + min(up.query(l[j], r[j] - 1), up.query(r[j] + 1, n) + down.query(l[j], n)));//右端点从上面过去的。左端点从上过：up.query(l[j], r[j] - 1) 左端点从下过：up.query(r[j] + 1, n) + down.query(l[j], n)-&gt;这个需要用到上面提的性质转化一下，把图变成右边有个大圈圈的样子。 up.add(r[j], -1);down.add(r[j], 1); dfs(j + 1, now + min(down.query(l[j], r[j] - 1), down.query(r[j] + 1, n) + up.query(l[j], n)));//右端点从下面过去，同上。 down.add(r[j], -1); return ;&#125;void work()&#123; T = read(); while(T --)&#123; n = read(); up.init(), down.init(); for(int i = 1; i &lt;= n; i ++) a[i] = read(); cnt = 0; ans = INF; for(int i = 1; i &lt; n; i ++) for(int j = i + 1; j &lt;= n; j ++)&#123; if(a[i] == a[j]) l[++ cnt] = i, r[cnt] = j; &#125; dfs(1, 0); printf("%d\n", ans); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arc077F题解]]></title>
    <url>%2F2017%2F12%2F27%2Farc077F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题：We will call a string that can be obtained by concatenating two equal strings an even string. For example, xyzxyz and aaaaaa are even, while ababab` and xyzxy are not. For a non-empty string S, we will define f(S) as the shortest even string that can be obtained by appending one or more characters to the end of S. For example, f(abaaba)=abaababaab. It can be shown that f(S) is uniquely determined for a non-empty string S. You are given an even string S consisting of lowercase English letters. For each letter in the lowercase English alphabet, find the number of its occurrences from the l-th character through the r-th character of f^10^100(S). Here,f^10^100(S) is the string f(f(f(…f(S)…))) obtained by applying f to S 10^100​ times. 译题：定义AA表示两个一样的字符串A接在一起。定义F(SS)=TT，TT是长度最小的满足条件的字符串且SS是TT的前缀。给你小写字母串SS，求F10100(SS)的区间[l,r]每个字母出现次数。 题解：对于f(SS)，我们找到其最长公共后缀T，那么f(SS)=STST。 因为是对称的，而且我们要找接近无限次，所以我们可以只考虑变换g(S)=ST。 设T的长度为d，S的长度为n。 可以证明，如果d|n，那么g(ST)=STT，否则g(ST)=STS。（意（我）会（也）即（不）可（会）） 对于g(ST)=STS，我们可以发现S-&gt;ST-&gt;STS-&gt;STSST…… 这显然是满足斐波那契的这种特性。 我们分类讨论一下就可以了。 具体写代码的时候，我们求一个next数组，T就是n-next[n]。我们再记一个每个字母出现的前缀和。 输出的时候，我们判断一下，如果这个长度小于我们输入的串，直接输出即可；如果大于，就记录一下我们最开始的两个字符串的长度和每个字母出现的次数，通过递归求出这个“类斐波那契”的式子。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex&lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 2e5 + 15;char ch[MAXN];int n, nxt[MAXN], T;LL l, r, f[MAXN][35];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;LL ff(LL len, int c)&#123; if(len &lt;= n) return f[len][c]; if(len &lt;= n * 2) return f[n][c] + f[len - n][c]; LL f1 = f[n][c], f2 = f[n][c] + f[T][c], l1 = n, l2 = n + T; while(len &gt; l1 + l2)&#123; LL t = f2; f2 += f1; f1 = t; t = l2; l2 += l1; l1 = t; &#125; return f2 + ff(len - l2, c);&#125;LL calc(LL len, int c)&#123; if(len &lt;= n) return f[len][c]; if(len &lt;= n * 2) return f[n][c] + f[len - n][c]; if(n % T == 0)&#123; LL tmp = (len - 1ll * n) / T * f[T][c] + f[n][c]; len -= n; len %= T; return tmp + f[len][c]; &#125; return ff(len, c);&#125;void work()&#123; scanf("%s %lld %lld", ch + 1, &amp;l, &amp;r); n = strlen(ch + 1) / 2; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 0; j &lt; 26; j ++) f[i][j] = f[i - 1][j]; f[i][ch[i] - 'a'] ++; &#125; nxt[1] = 0; for(int i = 2, j = 0; i &lt;= n; i ++)&#123; for(; j &amp;&amp; ch[j + 1] != ch[i];) j = nxt[j]; if(ch[j + 1] == ch[i]) j ++; nxt[i] = j; &#125; T = n - nxt[n]; for(int i = 0; i &lt; 26; i ++) printf("%lld ", calc(r, i) - calc(l - 1, i));&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[agc006D题解]]></title>
    <url>%2F2017%2F12%2F27%2Fagc006D%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题We have a pyramid with N steps, built with blocks. The steps are numbered 1 through N from top to bottom. For each 1≤i≤N, step i consists of 2i−1 blocks aligned horizontally. The pyramid is built so that the blocks at the centers of the steps are aligned vertically. Snuke wrote a permutation of (1, 2, …, 2N−1) into the blocks of step N. Then, he wrote integers into all remaining blocks, under the following rule: The integer written into a block b must be equal to the median of the three integers written into the three blocks directly under b, or to the lower left or lower right of b. Writing integers into the blocks Afterwards, he erased all integers written into the blocks. Now, he only remembers that the permutation written into the blocks of step N was (a1, a2, …, a2N−1). Find the integer written into the block of step 1. 译题：给你一个数n，我们要往一个n阶的“金字塔里”填数，输入给出了最底下一排的2n-1个数（一个1~2n-1的排列），每个格子里所填的数满足这样一个条件：这个数是它斜左下方、斜右下方、正下方三个数中第二大的（也就是既不是最大、又不是最小的那个），问最上面的那个数字是多少。 题解：这道题我感觉比较巧妙。 首先，我们肯定知道，朴素算法是$O(n^2)$的，肯定过不了。 既然数据范围是$10^5$，我们很容易想到这题应该是$O(nlogn)$的，所以我们二分答案。 关键就是怎么check，我们设k为当前二分的值，那么我们把大于等于k的记为1，小于k的记为0，如下图： 这时候我们发现如果有一段（大于1）0或者1，它会一直留到最后，就像上图中的”0 0”和”1 1 1”。 如果1和0交替出现，我们会发现它的规模会越来越小，直到没有，就像上图中的”1 0 1 0 1 0”。 如果交替出现的没有了，我们还剩什么呢？肯定只剩一段0，一段1拼成的了。然而在两侧的由于越到金字塔规模越小，最后也会没有。 那么这时候还剩什么呢？只剩最中间的了。所以我们可以从刚才的”一段0，一段1拼成的序列”中找到第n个是几（即金字塔的最中央）。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;typedef complex&lt;LF&gt; cd;#define clr(x, y) memset(x, y, sizeof(x))#define INF 0x7fffffffconst int MAXN = 2e5 + 15;int a[MAXN], b[MAXN], n, m, ans, cnt = 0;struct Node&#123;int l, r, c;&#125;f[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool check(int k)&#123; cnt = 0; for(int i = 1; i &lt;= n; i ++) b[i] = (a[i] &gt;= k ? 1 : 0); int i = 1; while(i &lt; n)&#123; if(b[i] != b[i + 1])&#123;i ++; continue;&#125; f[++ cnt].l = i, f[cnt].c = b[i]; while(i &lt; n &amp;&amp; b[i] == b[i + 1]) i ++; f[cnt].r = i; i ++; &#125; if(!cnt) return b[1]; f[0].r = 0; for(int i = 1; i &lt;= cnt; i ++)&#123; int l = f[i - 1].r + 1, r = f[i].l - 1; if(l &gt; r) continue; int mid = l + r &gt;&gt; 1; f[i - 1].r = mid, f[i].l = mid + 1; &#125; int l = f[cnt].r + 1, r = n; int mid = l + r &gt;&gt; 1; if(l &lt;= r) f[cnt].r = mid; for(int i = 1; i &lt;= n; i ++) if(f[i].l &lt;= m &amp;&amp; f[i].r &gt;= m) return f[i].c;&#125;void tp()&#123; int l = 1, r = n; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid, l = mid + 1; else r = mid - 1; &#125;&#125;void work()&#123; n = read(); m = n; n = n * 2 - 1; for(int i = 1; i &lt;= n; i ++) a[i] = read(); tp(); printf("%d\n", ans);&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3207 Ikki's Story IV - Panda's Trick 题解]]></title>
    <url>%2F2017%2F12%2F10%2FPOJ3207-Ikki-s-Story-IV-Panda-s-Trick-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题：liympanda, one of Ikki’s friend, likes playing games with Ikki. Today after minesweeping with Ikki and winning so many times, he is tired of such easy games and wants to play another game with Ikki.liympanda has a magic circle and he puts it on a plane, there are n points on its boundary in circular border: 0, 1, 2, …, n − 1. Evil panda claims that he is connecting m pairs of points. To connect two points, liympanda either places the link entirely inside the circle or entirely outside the circle. Now liympanda tells Ikki no two links touch inside/outside the circle, except on the boundary. He wants Ikki to figure out whether this is possible…Despaired at the minesweeping game just played, Ikki is totally at a loss, so he decides to write a program to help him. 译题：平面上，一个圆，圆的边上按顺时针放着n个点。现在要连m条边，比如a，b，那么a到b可以从圆的内部连接，也可以从圆的外部连接。给你的信息中，每个点最多只会连接的一条边。问能不能连接这m条边，使这些边都不相交。 题解：这道题可以归类为2-sat判断合法解，这种题应该算是比较基本、简单且常见的。 具体怎么做呢？ 我们把每条边看成两个点，i表示画在内部，i’表示画在外部。 然后我们可以知道，在内部相交的边，在外部也一定相交。 然后根据逻辑关系搞一搞就完了： 如果两边相交，那么连边：i-&gt;j’, i’-&gt;j, j-&gt;i’, j’-&gt;i 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;using namespace std;typedef long long LL;typedef double LF;const int MAXN = 2e5 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN];int head[MAXN], cnt, px[MAXN], py[MAXN], n, m, belong[MAXN], dfn[MAXN], low[MAXN], tim, tot;bool instack[MAXN];stack &lt;int&gt; sta;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void init()&#123; memset(head, 0, sizeof(head)); cnt = 0; memset(px, 0, sizeof(px)); memset(py, 0, sizeof(py)); tim = 0, tot = 0; memset(instack, 0, sizeof(instack)); memset(belong, 0, sizeof(belong)); memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low));&#125;void getmap()&#123; for(int i = 1; i &lt;= m; i ++)&#123; px[i] = read(), py[i] = read(); if(px[i] &gt; py[i]) swap(px[i], py[i]); &#125; for(int i = 1; i &lt;= m; i ++) for(int j = i + 1; j &lt;= m; j ++) if(px[j] &gt;= px[i] &amp;&amp; px[j] &lt;= py[i] &amp;&amp; py[j] &gt;= py[i] || py[j] &gt;= px[i] &amp;&amp; py[j] &lt;= py[i] &amp;&amp; px[j] &lt;= px[i])&#123; add(2 * i - 1, 2 * j); add(2 * j - 1, 2 * i); add(2 * j, 2 * i - 1); add(2 * i, 2 * j - 1); &#125;&#125;void tarjan(int u, int fafa)&#123; dfn[u] = low[u] = ++ tim; instack[u] = 1; sta.push(u); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(u == fafa) continue; if(!dfn[v])&#123; tarjan(v, u); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; tot ++; int i; do&#123; i = sta.top(); sta.pop(); instack[i] = 0; belong[i] = tot; &#125;while(i != u); &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= m * 2; i ++) if(!dfn[i]) tarjan(i, 0); bool flag = 1; for(int i = 1; i &lt; m * 2; i += 2)&#123; if(belong[i] == belong[i + 1])&#123;flag = 0; break;&#125; &#125; if(flag) printf("panda is telling the truth...\n"); else printf("the evil panda is lying again\n");&#125;void work()&#123; while(~scanf("%d %d", &amp;n, &amp;m))&#123; init(); getmap(); solve(); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3683 Priest John's Busiest Day 题解]]></title>
    <url>%2F2017%2F12%2F10%2FPOJ3683-Priest-John-s-Busiest-Day-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题： 译题：一个小镇里面只有一个牧师，现在有些新人要结婚，需要牧师分别去主持一个仪式，给出每对新人婚礼的开始时间 s 和结束时间 t ，还有他们俩的这个仪式需要的时间（每对新人需要的时间长短可能不同） d ，牧师可以在婚礼开始的时间 d 内（s 到 s+d）或者是结束前的时间 d 内（t - d 到 t）完成这个仪式。现在问能否给出一种安排，让牧师能完成所有夫妇婚礼的仪式，如果可以，输出一种安排。 题解：又是一道2-sat输出解的题。 好做。 怎么做？ 我们把题目可以稍微转化一下，把一场婚礼可以举行仪式的两个时间段单拿出来，然后选其中之一，看看能不能找到一种方案，使得每一对中的两个时间段选其一，且线段之间没有相互覆盖。这很符合2-sat的模型啊！如果没有理解可以看下图。 然后问题就简单了，问题就转化成了怎么建边。 找出相互覆盖的两条线段a和b，那么可以建边：a-&gt;b’ b-&gt;a’ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;typedef double LF;const int MAXN = 1e4 + 15;const int MAXX = 1e6 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXX &lt;&lt; 1], e[MAXX &lt;&lt; 1];struct Wed&#123;int s, t;&#125;a[MAXN];int head[MAXN], head1[MAXN], cnt = 0, cnt1 = 0, dfn[MAXN], low[MAXN], belong[MAXN], tim = 0, n, dt[MAXN], tot = 0, d[MAXN], opp[MAXN], col[MAXN];bool instack[MAXN];stack &lt;int&gt; sta; queue &lt;int&gt; q;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void readd(int u, int v)&#123;e[++ cnt1] = (Edge)&#123;v, head1[u]&#125;; head1[u] = cnt1;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;bool pd(int i, int j)&#123; if(a[i].s &gt;= a[j].t || a[i].t &lt;= a[j].s) return 0; return 1;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ tim; sta.push(u); instack[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; tot ++; int i; do&#123; i = sta.top(); sta.pop(); belong[i] = tot; instack[i] = 0; &#125;while(i != u &amp;&amp; !sta.empty()); &#125;&#125;bool solve()&#123; for(int i = 1; i &lt;= n * 2; i ++)&#123; if(!dfn[i]) tarjan(i); &#125; bool flag = 1; for(int i = 1; i &lt;= n * 2; i += 2)&#123; if(belong[i] == belong[i + 1])&#123;flag = 0; break;&#125; opp[belong[i]] = belong[i + 1]; opp[belong[i + 1]] = belong[i]; &#125; if(!flag)&#123;printf("NO\n"); return 0;&#125; printf("YES\n"); return 1;&#125;void setmdl()&#123; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= n; j ++)&#123; if(i == j) continue; if(pd(i * 2 - 1, j * 2 - 1)) add(i * 2 - 1, j * 2); if(pd(i * 2 - 1, j * 2)) add(i * 2 - 1, j * 2 - 1); if(pd(i * 2, j * 2 - 1)) add(i * 2, j * 2); if(pd(i * 2, j * 2)) add(i * 2, j * 2 - 1); &#125;&#125;void rebuild()&#123; for(int i = 1; i &lt;= n * 2; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1)&#123;readd(v1, u1); d[u1] ++;&#125; &#125; &#125;&#125;void topo_sort()&#123; memset(col, -1, sizeof(col)); int tmp = 0; for(int i = 1; i &lt;= tot; i ++) if(!d[i]) q.push(i); while(!q.empty())&#123; int u = q.front(); q.pop(); if(col[u] == -1)&#123;col[u] == 1; col[opp[u]] = 0;&#125; for(int i = head1[u]; i; i = e[i].nxt)&#123; int v = e[i].to; d[v] --; if(!d[v]) q.push(v); &#125; &#125;&#125;void print()&#123; //for(int i = 1; i &lt;= n * 2; i ++)cout&lt;&lt;col[i]&lt;&lt;endl; for(int i = 1; i &lt;= n; i ++)&#123; if(col[belong[i * 2 - 1]]) printf("%.2d:%.2d %.2d:%.2d\n", a[i * 2 - 1].s / 60, a[i * 2 - 1].s % 60, a[i * 2 - 1].t / 60, a[i * 2 - 1].t % 60); else printf("%.2d:%.2d %.2d:%.2d\n", a[i * 2].s / 60, a[i * 2].s % 60, a[i * 2].t / 60, a[i * 2].t % 60); &#125;&#125;void work()&#123; n = read(); for(int i = 1; i &lt;= n; i ++)&#123; int x, y, z, r; scanf("%d:%d %d:%d", &amp;x, &amp;y, &amp;z, &amp;r); dt[i] = read(); a[i * 2 - 1].s = x * 60 + y; a[i * 2 - 1].t = x * 60 + y + dt[i]; a[i * 2].s = z * 60 + r - dt[i]; a[i * 2].t = z * 60 + r; &#125; setmdl(); if(!solve()) return ; rebuild(); topo_sort(); print();&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3678 Katu Puzzle 题解]]></title>
    <url>%2F2017%2F12%2F10%2FPOJ3678-Katu-Puzzle-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题： 译题：一些点，点的取值可以是0或者1，没有告诉你具体取值。 一些边，有权值，有运算方式（并，或，异或），要求和这条边相连的两个点经过边上的运算后的结果是边的权值。 问你有没有可能把每个点赋值满足所有边的要求。 题解：又一道2-sat判断合法性题目。 代码量稍微的就小了一些，相比于要输出方案的。 关键还是建边，这个建边就更直白了，毕竟给你的就是逻辑运算符，只不过要建的边多一点。 A 0A’ 1c op 值 op 边 边 边 边 0 and i’-&gt;j j’-&gt;i N/A N/A 0 or i’-&gt;i j’-&gt;j i-&gt;j j-&gt;i 0 xor i-&gt;j i’-&gt;j’ j-&gt;i j’-&gt;i’ 1 and i’-&gt;i j’-&gt;j i’-&gt;j’ j’-&gt;i’ 1 or i-&gt;j’ j-&gt;i’ N/A N/A 1 xor i-&gt;j’ i’-&gt;j j-&gt;i’ j’-&gt;i 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 2e4 + 15;const int MAXM = 2e6 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, tim = 0, tot = 0, dfn[MAXN], low[MAXN], belong[MAXN];int n, m;bool instack[MAXN];stack &lt;int&gt; sta;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ tim; sta.push(u); instack[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; tot ++; int i; do&#123; i = sta.top(); sta.pop(); instack[i] = 0; belong[i] = tot; &#125;while(i != u); &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= n * 2; i ++) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= n; i ++)&#123; if(belong[i * 2 - 1] == belong[i * 2])&#123;printf("NO\n"); return ;&#125; &#125; printf("YES\n");&#125;void init()&#123; n = read(), m = read(); char ch[10]; for(int i = 1; i &lt;= m; i ++)&#123; int u = read() + 1, v = read() + 1, c = read(); scanf("%s", ch + 1); if(!c)&#123; if(ch[1] == 'A') add(2 * u, 2 * v - 1), add(2 * v, 2 * u - 1); else if(ch[1] == 'O') add(2 * u, 2 * u - 1), add(2 * v, 2 * v - 1), add(2 * u - 1, 2 * v - 1), add(2 * v - 1, 2 * u - 1); else add(2 * u - 1, 2 * v - 1), add(2 * u, 2 * v), add(2 * v - 1, 2 * u - 1), add(2 * v, 2 * u); &#125; else &#123; if(ch[1] == 'A') add(2 * u - 1, 2 * u), add(2 * v - 1, 2 * v), add(2 * u, 2 * v), add(2 * v, 2 * u); else if(ch[1] == 'O') add(2 * u - 1, 2 * v), add(2 * v - 1, 2 * u); else add(2 * u - 1, 2 * v), add(2 * u, 2 * v - 1), add(2 * v - 1, 2 * u), add(2 * v, 2 * u - 1); &#125; &#125; solve();&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3648 Wedding 题解]]></title>
    <url>%2F2017%2F12%2F10%2FPOJ3648-Wedding-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题： 译题：一对新婚的夫妇邀请(n-1)对夫妇来参加自己的宴会,这对新人以及这些受邀请的夫妇都坐在长桌子的两边,新娘和新郎分别坐在桌子的两侧,新娘不希望看到她邀请来的那些夫妇之中有妻子和丈夫坐在同一边的情况(即妻子和丈夫要分作桌子的两边),在这n对夫妇中有一些男女存在着暧昧的关系,所以新娘也不希望看到有暧昧关系的人坐在她对面的那一侧.求解是否存在一种满足新娘要求的座位分配方案,如果存在的话,那么就输出这方案,否则输出”bad luck”. 题解：这道题属于2-sat输出解类型，比较麻烦，不过这也是有套路的，就是tarjan缩点建反图，然后拓扑排序，染色，输出答案即可。 我们设新娘编号为0，新郎为1，被邀请到的couples中，wife的编号为$2\times i$husband的编号为$2\times i + 1$。 我们以新娘对面的状态建图。 我们首先要建边0-&gt;1，表示对面一定坐着新郎。 然后我们根据输入中的“特殊关系”来建边。 对于A和B不能坐在同一边， A-&gt;B’ B’-&gt;A 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 5e4 + 15;const int MAXM = 3e6 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN &lt;&lt; 1], e[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, head1[MAXN], cnt1 = 0, tim = 0, tot = 0, belong[MAXN], col[MAXN], dfn[MAXN], low[MAXN], opp[MAXN];int n, m, d[MAXN];bool instack[MAXN];stack &lt;int&gt; sta;queue &lt;int&gt; q;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline void add1(int u, int v)&#123;e[++ cnt1] = (Edge)&#123;v, head1[u]&#125;; head1[u] = cnt1;&#125;inline void init()&#123; cnt = cnt1 = tim = tot = 0; clr(head, -1); clr(head1, -1); clr(belong, 0); clr(col, -1); clr(instack, 0); clr(dfn, 0); clr(low, 0); clr(opp, 0); clr(d, 0);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ tim; sta.push(u); instack[u] = 1; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; tot ++; int i; do&#123; i = sta.top(); sta.pop(); instack[i] = 0; belong[i] = tot; &#125;while(i != u); &#125;&#125;void rebuild()&#123; for(int i = 0; i &lt; n * 2; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; ~j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1) add1(v1, u1), d[u1] ++; &#125; &#125;&#125;void topo()&#123; for(int i = 1; i &lt;= tot; i ++) if(!d[i]) q.push(i); while(!q.empty())&#123; int u = q.front(); q.pop(); if(col[u] == -1) col[u] = 1, col[opp[u]] = 0; for(int i = head1[u]; ~i; i = e[i].nxt)&#123; int v = e[i].to; d[v] --; if(!d[v]) q.push(v); &#125; &#125;&#125;void print()&#123; for(int i = 2; i &lt; 2 * n; i += 2)&#123; if(col[belong[i]] == col[belong[0]]) printf("%dw ", i / 2); else printf("%dh ", i / 2); &#125; printf("\n");&#125;void solve()&#123; for(int i = 0; i &lt; 2 * n; i ++) if(!dfn[i]) tarjan(i); for(int i = 0; i &lt; n; i ++)&#123; if(belong[i * 2] == belong[i * 2 + 1])&#123;printf("bad luck\n"); return ;&#125; opp[belong[i * 2]] = belong[i * 2 + 1]; opp[belong[i * 2 + 1]] = belong[i * 2]; &#125; rebuild(); topo(); print();&#125;void work()&#123; n = read(), m = read(); while(n &amp;&amp; m)&#123; init(); for(int i = 1; i &lt;= m; i ++)&#123; int u, v; char s, t; int a0, a1, b0, b1; scanf("%d %c %d %c", &amp;u, &amp;s, &amp;v, &amp;t); if(s == 'h') a0 = 2 * u, a1 = 2 * u + 1; else a0 = 2 * u + 1, a1 = 2 * u; if(t == 'h') b0 = 2 * v, b1 = 2 * v + 1; else b0 = 2 * v + 1, b1 = 2 * v; add(a1, b0); add(b1, a0); &#125; add(0, 1); solve(); n = read(), m = read(); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2749 Building roads 题解]]></title>
    <url>%2F2017%2F12%2F10%2FPOJ2749-Building-roads-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题： 译题：有n个农场，每个农场有坐标x，y。 有两个集合点s1和s2（也有坐标），每个农场必须连接其中的一个（有且仅有一个）。 然后有A个条件，每个条件a，b表示a农场不能和b农场连接在一个集合点。 然后再有B个条件，每个条件a，b表示a农场必须和b农场连接在一个集合点。 问你，在各种合法的连接情况中，任何两个农场间的距离的最大值的最小值是多少。 题解：一看到最大值的最小值，我们要干什么呢？ 二分答案！ 没错，这道题和POJ2723很像，都是二分一下然后用2sat判定，这就做完了，怎样建图我想我不用多说了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 2e4 + 15;const int MAXM = 2e6 + 15;const int INF = 1e8;struct Edge&#123;int to, nxt;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], cnt = 0, dfn[MAXN], low[MAXN], tim = 0, tot = 0, belong[MAXN], opp[MAXN];int n, A, B, dis = 0, sx1, sy1, sx2, sy2, x[MAXN], y[MAXN], a[MAXN], b[MAXN], c[MAXN], d[MAXN];bool instack[MAXN];stack &lt;int&gt; sta;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void init()&#123; cnt = tim = tot = 0; clr(head, 0); clr(dfn, 0); clr(belong, 0); clr(low, 0);&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ tim; sta.push(u); instack[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; tot ++; int i; do&#123; i = sta.top(); sta.pop(); belong[i] = tot; instack[i] = 0; &#125;while(i != u); &#125;&#125;bool check(int k)&#123; init(); for(int i = 1; i &lt;= A; i ++)&#123; add(a[i] * 2, b[i] * 2 - 1); add(a[i] * 2 - 1, b[i] * 2); add(b[i] * 2, a[i] * 2 - 1); add(b[i] * 2 - 1, a[i] * 2); &#125; for(int i = 1; i &lt;= B; i ++)&#123; add(c[i] * 2, d[i] * 2); add(c[i] * 2 - 1, d[i] * 2 - 1); add(d[i] * 2, c[i] * 2); add(d[i] * 2 - 1, c[i] * 2 - 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = i + 1; j &lt;= n; j ++)&#123; if(abs(x[i] - sx1) + abs(x[j] - sx1) + abs(y[i] - sy1) + abs(y[j] - sy1) &gt; k) add(2 * i - 1, 2 * j), add(2 * j - 1, 2 * i); if(abs(x[i] - sx1) + abs(x[j] - sx2) + abs(y[i] - sy1) + abs(y[j] - sy2) + dis &gt; k) add(2 * i - 1, 2 * j - 1), add(2 * j, 2 * i); if(abs(x[i] - sx2) + abs(x[j] - sx1) + abs(y[i] - sy2) + abs(y[j] - sy1) + dis &gt; k) add(2 * i, 2 * j), add(2 * j - 1, 2 * i - 1); if(abs(x[i] - sx2) + abs(x[j] - sx2) + abs(y[i] - sy2) + abs(y[j] - sy2) &gt; k) add(2 * i, 2 * j - 1), add(2 * j, 2 * i - 1); &#125; &#125; for(int i = 1; i &lt;= n * 2; i ++) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= n * 2; i += 2) if(belong[i] == belong[i + 1]) return 0; return 1;&#125;void work()&#123; n = read(), A = read(), B = read(); sx1 = read(), sy1 = read(), sx2 = read(), sy2 = read(); dis = abs(sx1 - sx2) + abs(sy1 - sy2); for(int i = 1; i &lt;= n; i ++) x[i] = read(), y[i] = read(); for(int i = 1; i &lt;= A; i ++) a[i] = read(), b[i] = read(); for(int i = 1; i &lt;= B; i ++) c[i] = read(), d[i] = read(); int l = 0, r = INF, ans = -1; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(check(mid)) r = mid - 1, ans = mid; else l = mid + 1; &#125; if(~ans) printf("%d\n", ans); else printf("-1\n");&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2723 Get Luffy Out 题解]]></title>
    <url>%2F2017%2F12%2F10%2FPOJ2723-Get-Luffy-Out-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意：原题： 译题：鸳鸯锁：你的基友路飞被关进了一座M层的监狱，每层的门上由两把锁锁住，打开任意一把即可入内。这些锁的钥匙一共有2N种，两两互斥，当使用了一把钥匙后，另一把与其互斥的钥匙就会消失，造成鸳鸯锁永远只能解开一把。给定锁的配对关系和门上锁的编号，请计算最高能到达的层数。 题解：又是一道弱智题啊。。。还不用输出解，这岂不是很简单，套路套路，直接过。 哦，这道题多了一个二分答案，然后用2sat判定一下是否可行即可，具体可以看代码。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 2e4 + 15;const int MAXM = 2e6 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXM &lt;&lt; 1];int head[MAXN], a[MAXN], b[MAXN], cnt = 0, dfn[MAXN], low[MAXN], tim = 0, tot = 0, belong[MAXN], opp[MAXN];int n, m;bool instack[MAXN];stack &lt;int&gt; sta;inline void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void init()&#123; cnt = tim = tot = 0; clr(head, -1); clr(dfn, 0); clr(belong, 0); clr(low, 0);&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ tim; sta.push(u); instack[u] = 1; for(int i = head[u]; ~i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; tot ++; int i; do&#123; i = sta.top(); sta.pop(); belong[i] = tot; instack[i] = 0; &#125;while(i != u); &#125;&#125;bool check(int k)&#123; init(); for(int i = 1; i &lt;= k; i ++)&#123; add(opp[a[i]], b[i]); add(opp[b[i]], a[i]); &#125; for(int i = 0; i &lt; n * 2; i ++) if(!dfn[i]) tarjan(i); for(int i = 0; i &lt; n * 2; i += 2)&#123; if(belong[i] == belong[opp[i]]) return 0; &#125; return 1;&#125;void work()&#123; n = read(), m = read(); while(n &amp;&amp; m)&#123; memset(opp, 0, sizeof(opp)); for(int i = 1; i &lt;= n; i ++)&#123; int u = read(), v = read(); opp[u] = v; opp[v] = u; &#125; for(int i = 1; i &lt;= m; i ++) a[i] = read(), b[i] = read(); int l = 0, r = m, ans; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid, l = mid + 1; else r = mid - 1; &#125; printf("%d\n", ans); n = read(), m = read(); &#125;&#125;int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习]]></title>
    <url>%2F2017%2F12%2F09%2F%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近学的东西比较多，感觉学了学点分治就已经彻底忘记平衡树了。。。。（日常瞎扯.jpg） 好，进入正题。 讲解与模板：先推荐几个讲解点分治的博客： 传送门1 传送门2 传送门3 第3个讲得比较清楚，不过它的求重心好像有一些偏差。 Q ：点分治是什么？ A ：首先，它是一个算法，在竞赛中比较常用（废话）。 Q ：点分治能干什么？ A ：竞赛中，有一类题，就是求树上满足某特殊条件的路径的条数，一般见到这个，大概就可以套点分治了。它究竟还能干什么，好吧，必须承认我对其他的一无所知。。。 注意： 很多题解里面给出的getrt函数（即求重心函数）写的是有问题的，因为我们相当于是把重心当做新的根，但是此时的$size$（子树大小）没更新，导致下一次求重心的时候求错，所以我们每次要在递归每个子树的函数中，重新算一遍$size$。 模板：这个是POJ1741，题意就是说求树上距离$\leq k$的点对数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;const int MAXN = 2e4 + 15;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;struct Edge&#123;int to, nxt, dis;&#125;g[MAXN];int head[MAXN], cnt, f[MAXN], dd[MAXN], size[MAXN], d[MAXN];int n, k, rt, ans, con, len;bool vis[MAXN];void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125;void clr()&#123; for(int i = 1; i &lt;= n; i ++) vis[i] = f[i] = size[i] = head[i] = dd[i] = 0; cnt = rt = 0, f[0] = 1e9, con = n, len = ans = 0;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void getrt(int u, int fafa)&#123; size[u] = 1; f[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v == fafa || vis[v]) continue; getrt(v, u); size[u] += size[v]; f[u] = max(f[u], size[v]); &#125; f[u] = max(f[u], con - size[u]); if(f[u] &lt; f[rt]) rt = u;&#125;void getdis(int u, int fafa)&#123; size[u] = 1; dd[++ len] = d[u]; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v == fafa || vis[v]) continue; d[v] = d[u] + g[i].dis; getdis(v, u); size[u] += size[v]; &#125;&#125;int cal(int u, int w)&#123; len = 0; d[u] = w; getdis(u, 0); sort(dd + 1, dd + len + 1); int l = 1, r = len, sum = 0; while(l &lt; r)&#123; if(dd[l] + dd[r] &lt;= k) sum += r - l, l ++; else r --; &#125; return sum;&#125;void solve(int u)&#123; vis[u] = 1; ans += cal(u, 0); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; ans -= cal(v, g[i].dis); rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125;void init()&#123; while((n = read()) &amp;&amp; (k = read()))&#123; clr(); for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); add_edge(u, v, dis); &#125; getrt(1, 0); solve(rt); printf("%d\n", ans); &#125;&#125;int main()&#123; init(); return 0;&#125; 稍微讲一下这个程序： 我们把树上的路径分为两种：经过根的路径，不经过根的路径。 对于每个根，我们计算了每棵子树上的所有点到当前根的$dist$，然后排序，用two-pointer计数，其中有一些非法的路径，就是两条到根的路径出自同一棵子树，如下图，我们需要把它减掉。然后就做完了啊。 题目与练习：BZOJ1468题意：与POJ1741相同 题解：模板题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double LF; const int MAXN = 4e4 + 15; struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int size[MAXN], f[MAXN], dd[MAXN], d[MAXN], head[MAXN];int rt = 0, n, k, cnt = 0, con, ans = 0, len = 0;bool vis[MAXN]; inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void getrt(int u, int fafa)&#123; size[u] = 1; f[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; getrt(v, u); size[u] += size[v]; f[u] = max(f[u], size[v]); &#125; f[u] = max(f[u], con - size[u]); if(f[u] &lt; f[rt]) rt = u;&#125; void getdis(int u, int fafa)&#123; size[u] = 1; dd[++ len] = d[u]; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; d[v] = d[u] + g[i].dis; getdis(v, u); size[u] += size[v]; &#125;&#125; int cal(int u, int w)&#123; int ret = 0; len = 0; d[u] = w; getdis(u, 0); sort(dd + 1, dd + len + 1); int l = 1, r = len; while(l &lt; r)&#123; if(dd[l] + dd[r] &lt;= k) ret += r - l, l ++; else r --; &#125; return ret;&#125; void solve(int u)&#123; vis[u] = 1; ans += cal(u, 0); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; ans -= cal(v, g[i].dis); rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125; void work()&#123; n = read(); for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); add_edge(u, v, dis); &#125; k = read(); f[0] = con = n; getrt(1, 0); solve(rt); printf("%d\n", ans);&#125; int main()&#123; work(); return 0;&#125; BZOJ3365题意：与之前两题相同。 题解：略。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double LF; const int MAXN = 4e4 + 15; struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int size[MAXN], f[MAXN], dd[MAXN], d[MAXN], head[MAXN];int rt = 0, n, k, cnt = 0, con, ans = 0, len = 0;bool vis[MAXN]; inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void getrt(int u, int fafa)&#123; size[u] = 1; f[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; getrt(v, u); size[u] += size[v]; f[u] = max(f[u], size[v]); &#125; f[u] = max(f[u], con - size[u]); if(f[u] &lt; f[rt]) rt = u;&#125; void getdis(int u, int fafa)&#123; dd[++ len] = d[u]; size[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; d[v] = d[u] + g[i].dis; getdis(v, u); size[u] += size[v]; &#125;&#125; int cal(int u, int w)&#123; int ret = 0; len = 0; d[u] = w; getdis(u, 0); sort(dd + 1, dd + len + 1); int l = 1, r = len; while(l &lt; r)&#123; if(dd[l] + dd[r] &lt;= k) ret += r - l, l ++; else r --; &#125; return ret;&#125; void solve(int u)&#123; vis[u] = 1; ans += cal(u, 0); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; ans -= cal(v, g[i].dis); rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125; void work()&#123; n = read(); int m = read(); for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); char ch[5]; scanf("%s", ch); add_edge(u, v, dis); &#125; k = read(); f[0] = con = n; getrt(1, 0); solve(rt); printf("%d\n", ans);&#125; int main()&#123; work(); return 0;&#125; BZOJ2152：题意：一棵树，路径距离是3的倍数的点对数占总点对数的百分之多少，求出这个分数（最简形式）。 题解：首先，我们可以知道，总点对数的数量是$n\times n$个，最简形式也好搞，分子分母求个gcd就完了。 所以说，我们成功的把这个问题转化成了求满足树上路径距离是3的倍数的路径条数，很好，这显然就变成了点分治的”套路题“。 那么接下连我们怎么套路一番呢？很简单，我们递归每一棵子树时，g[0]表示路径距离$mod\ \ 3\equiv 0$的条数，g[1]和g[2]道理同前。 那么显然，每一棵子树的贡献就是$2\times g[1]\times g[2]+g[0]\times g[0]$ 什么？不明白？ 那再看一遍题吧，(3,4)和(4,3)算两种。。。 好吧，怪我没说清楚。 那么，又做完了一道题！ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double LF; const int MAXN = 4e4 + 15; struct Edge&#123;int to, nxt, dis;&#125;g[MAXN];int size[MAXN], f[MAXN], d[5], head[MAXN];int cnt = 0, con, rt, n, ans = 0;bool vis[MAXN]; inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; int gcd(int a, int b)&#123;return (!b) ? a : gcd(b, a % b);&#125; void getrt(int u, int fafa)&#123; size[u] = 1; f[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; getrt(v, u); size[u] += size[v]; f[u] = max(f[u], size[v]); &#125; f[u] = max(f[u], con - size[u]); if(f[u] &lt; f[rt]) rt = u;&#125; void getdis(int u, int w, int fafa)&#123; d[w] ++; size[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; getdis(v, (w + g[i].dis) % 3, u); size[u] += size[v]; &#125;&#125; void solve(int u)&#123; vis[u] = 1; d[0] = d[1] = d[2] = 0; getdis(u, 0, 0); ans += d[0] * d[0] + 2 * d[1] * d[2]; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; d[0] = d[1] = d[2] = 0; getdis(v, g[i].dis, u); ans -= d[0] * d[0] + 2 * d[1] * d[2]; rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125; void work()&#123; n = read(); for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); add_edge(u, v, dis % 3); &#125; f[0] = con = n; getrt(1, 0); solve(rt); n *= n; int tmp = gcd(n, ans); printf("%d/%d\n", ans / tmp, n / tmp);&#125; int main()&#123; work(); return 0;&#125; BZOJ2599题意：给一棵树,每条边有权.求一条简单路径,权值和等于K,且边的数量最小.N &lt;= 200000, K &lt;= 1000000 题解：看着是IOI的题，但是你看完题解以后，会发现这题并没有那么难。 这个乍一看跟点分治好像扯不上边啊。。。 不用点分治你用什么？？？ 好吧，还是强行扯回点分治。 实际上这道题跟点分治并不是没关系，一看路径距离和，我像是个OIer都应该知道可以用点分治做吧。。。 我们用$d$数组表示该点深度，$dis$数组表示当前根到当前递归到的点的距离，同时我们再开一个$t$数组，$t[dist]$表示距离为$dist$经过的最少的边。然后对于当前的根，我们每递归完它的一个子树，就update一些$t$数组的值，同时，每次递归的时候，也更新一下$ans$的值。 大家不要被update(v, 0, 0)吓到，它只是为了清空$t$而生的，我（更准确的说是黄学长）觉得memset太慢。 这个做法事黄学长提供的，如果看不懂我的题解，可以看黄学长的。 hzwer的题解 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt; #define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt) #define mem(x, y) memset(x, y, sizeof(x)); using namespace std; typedef long long LL;typedef double LF; LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125; const int MAXN = 2e5 + 15; struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], size[MAXN], t[MAXN * 10], f[MAXN], d[MAXN], dis[MAXN];int cnt = 0, rt, n, k, ans, con;bool vis[MAXN]; inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void getrt(int u, int fafa)&#123; size[u] = 1; f[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; getrt(v, u); size[u] += size[v]; f[u] = max(f[u], size[v]); &#125; f[u] = max(f[u], con - size[u]); if(f[u] &lt; f[rt]) rt = u;&#125; void update(int u, int fafa, bool opt)&#123; if(dis[u] &lt;= k)&#123; if(opt) t[dis[u]] = min(t[dis[u]], d[u]); else t[dis[u]] = 1e9; &#125; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; update(v, u, opt); &#125;&#125; void cal(int u, int fafa)&#123; size[u] = 1; if(dis[u] &lt;= k) ans = min(ans, t[k - dis[u]] + d[u]); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; d[v] = d[u] + 1; dis[v] = dis[u] + g[i].dis; cal(v, u); size[u] += size[v]; &#125;&#125; void solve(int u)&#123; vis[u] = 1; t[0] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; d[v] = 1; dis[v] = g[i].dis; cal(v, 0); update(v, 0, 1); &#125; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; update(v, 0, 0); &#125; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125; void init()&#123; n = read(), k = read(); for(int i = 1; i &lt;= k; i ++) t[i] = n; for(int i = 1; i &lt; n; i ++)&#123; int u = read() + 1, v = read() + 1, dis = read(); add_edge(u, v, dis); &#125; f[0] = con = ans = n; getrt(1, 0); solve(rt); if(ans != n) printf("%d\n", ans); else printf("-1\n");&#125; int main()&#123; init(); return 0;&#125; BZOJ1316题意：一棵n个点的带权有根树，有p个询问，每次询问树中是否存在一条长度为Len的路径，如果是，输出Yes否输出No. 题解：这道题就有点像最开始讲的那道模板题，只不过换成了=。那我们应该怎么做呢？同样的方法做，只不过，我们不能用双指针了吧？！是啊！那怎么办呢？两次二分呗！两次二分分别二分我们要找的值的最左边出现的位置和最右边出现的位置。 这不就做完了吗？？？快去刷吧，这题太水了，洛谷都把它归为“模板题”啦！ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double LF; const int MAXN = 1e4 + 15; struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int n, m, rt, cnt = 0, len = 0, con;int head[MAXN], size[MAXN], f[MAXN], d[MAXN], dd[MAXN], q[MAXN], ans[MAXN];bool vis[MAXN]; inline void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; void getrt(int u, int fafa)&#123; size[u] = 1; f[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; getrt(v, u); size[u] += size[v]; f[u] = max(f[u], size[v]); &#125; f[u] = max(f[u], con - size[u]); if(f[u] &lt; f[rt]) rt = u;&#125; int find_l(int l, int r, int k)&#123; int ans = 0; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(dd[mid] == k) ans = mid, r = mid - 1; else if(dd[mid] &lt; k) l = mid + 1; else r = mid - 1; &#125; return ans;&#125; int find_r(int l, int r, int k)&#123; int ans = -1; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(dd[mid] == k) ans = mid, l = mid + 1; else if(dd[mid] &lt; k) l = mid + 1; else r = mid - 1; &#125; return ans;&#125; void getdis(int u, int fafa)&#123; dd[++ len] = d[u]; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v] || v == fafa) continue; d[v] = d[u] + g[i].dis; getdis(v, u); &#125;&#125; int cal(int u, int w, int k)&#123; int ret = 0; len = 0; d[u] = w; getdis(u, 0); sort(dd + 1, dd + len + 1); for(int i = 1; i &lt;= len; i ++)&#123; if(2 * dd[i] &gt; k) break; int l = find_l(i, len, k - dd[i]); int r = find_r(i, len, k - dd[i]); ret += r - l + 1; &#125; return ret;&#125; void solve(int u)&#123; vis[u] = 1; for(int i = 1; i &lt;= m; i ++) ans[i] += cal(u, 0, q[i]); for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(vis[v]) continue; for(int j = 1; j &lt;= m; j ++) ans[j] -= cal(v, g[i].dis, q[j]); rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void work()&#123; n = read(), m = read(); for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); add_edge(u, v, dis); &#125; for(int i = 1; i &lt;= m; i ++) q[i] = read(); f[0] = con = n; rt = 0; getrt(1, 0); solve(rt); for(int i = 1; i &lt;= m; i ++)&#123; if(ans[i]) printf("Yes\n"); else printf("No\n"); &#125;&#125; int main()&#123; work(); return 0;&#125; BZOJ3697：题意：采药人的药田是一个树状结构，每条路径上都种植着同种药材。采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。 题解：如果觉得我讲的不够清楚，可以参照黄学长的blog：传送门 我们先把边权为0的边改成-1。 想一想，我们是不是把这个问题转化成了：存在多少条路径，满足到中间的某点前缀和为0，并且到终点的总和也为0（和的概念是“边权和”）？ 如果想通了，那么这个问题就很好解决了啊，是不是？ 对于当前的根，我们把路径分为两种，一种是过此根的路径，另外一种是不经过根的路径。对于第一种情况，我们先dfs预处理出来到根的距离为$dis$的路径数量。$g[dis][0/1]$表示之前dfs过的子树中，到根的距离为$dis$的路径数目，其中是否出现过前缀和为0的点，$f$数组同理，表示当前正在dfs的子树。 然后统计一下就好了（具体可以看代码）。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double LF; const int MAXN = 1e5 + 15; struct Edge&#123;int to, nxt, dis;&#125;gg[MAXN &lt;&lt; 1];int size[MAXN], head[MAXN], ff[MAXN], t[MAXN &lt;&lt; 1], d[MAXN], dis[MAXN];int n, con, cnt = 0, mxdep, rt;LL ans, f[MAXN &lt;&lt; 1][2], g[MAXN &lt;&lt; 1][2];bool vis[MAXN]; inline void add(int u, int v, int dis)&#123;gg[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;inline void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void getrt(int u, int fafa)&#123; size[u] = 1; ff[u] = 0; for(int i = head[u]; i; i = gg[i].nxt)&#123; int v = gg[i].to; if(vis[v] || v == fafa) continue; getrt(v, u); size[u] += size[v]; ff[u] = max(ff[u], size[v]); &#125; ff[u] = max(ff[u], con - size[u]); if(ff[u] &lt; ff[rt]) rt = u;&#125; void dfs(int u, int fafa)&#123; size[u] = 1; mxdep = max(mxdep, d[u]); if(t[dis[u]]) f[dis[u]][1] ++; else f[dis[u]][0] ++; t[dis[u]] ++; for(int i = head[u]; i; i = gg[i].nxt)&#123; int v = gg[i].to; if(vis[v] || v == fafa) continue; d[v] = d[u] + 1; dis[v] = dis[u] + gg[i].dis; dfs(v, u); size[u] += size[v]; &#125; t[dis[u]] --;&#125; void cal(int u)&#123; int mx = 0; g[0 + n][0] = 1; for(int i = head[u]; i; i = gg[i].nxt)&#123; int v = gg[i].to; if(vis[v]) continue; d[v] = 1; dis[v] = gg[i].dis + n; mxdep = 1; dfs(v, 0); mx = max(mx, mxdep); ans += (g[0 + n][0] - 1) * f[0 + n][0]; for(int j = -mxdep; j &lt;= mxdep; j ++) ans += g[-j + n][1] * f[j + n][1] + g[-j + n][0] * f[j + n][1] + g[-j + n][1] * f[j + n][0]; for(int j = -mxdep + n; j &lt;= mxdep + n; j ++)&#123; g[j][0] += f[j][0]; g[j][1] += f[j][1]; f[j][0] = f[j][1] = 0; &#125; &#125; for(int i = -mx + n; i &lt;= mx + n; i ++) g[i][0] = g[i][1] = 0;&#125; void solve(int u)&#123; vis[u] = 1; cal(u); for(int i = head[u]; i; i = gg[i].nxt)&#123; int v = gg[i].to; if(vis[v]) continue; rt = 0; con = size[v]; getrt(v, 0); solve(rt); &#125;&#125; void work()&#123; n = read(); ans = 0; rt = 0; for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); if(!dis) dis = -1; add_edge(u, v, dis); &#125; ff[0] = con = n; getrt(1, 0); solve(rt); printf("%lld\n", ans);&#125; int main()&#123; work(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡树学习]]></title>
    <url>%2F2017%2F12%2F02%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今天学了一下splay，发现splay还是很强大的。 先安利几篇本蒟蒻认为好的讲解：讲解1 讲解2 讲解3 个人比较推荐好好看第三篇博客，主要我不用指针，所以这篇博客特别适合我，而且讲的也很细。 据一些dalao说，treap和SBT的功能都没有splay强，于是本蒟蒻就先学习了splay splay其实很好学，主要你要研究透它其中的原理，如果只被代码的话，我想意义不大，毕竟做题你还不会。 我学习splay的时候也发现了一些问题，不够这些问题很多都早就有人提出来了，我也说一说比较主要的问题。例如：每次插入（或查询）完为什么要把当前节点旋转到最上面？ 呵呵，毕竟不要太较真，网上有一些dalao给出的答案是期望时间短，确实挺有道理。 然后我们就来具体的看一下splay吧。 讲解与模板1早上先是看了看这篇博客（讲的真的是太好了！）传送门 模板：同时我也给一个我的模板（原题洛谷3369，打的十分丑陋）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 2e5 + 15;int sz = 0, rt;int key[MAXN], size[MAXN], son[MAXN][2], fa[MAXN], cnt[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void up(int p)&#123;size[p] = cnt[p] + size[son[p][0]] + size[son[p][1]];&#125;inline int get(int x)&#123;return son[fa[x]][1] == x;&#125;inline void rotate(int x)&#123; int p = fa[x], g = fa[p], opt = get(x); son[p][opt] = son[x][opt ^ 1]; fa[son[x][opt ^ 1]] = p; son[x][opt ^ 1] = p; fa[p] = x; fa[x] = g; if(g) son[g][son[g][1] == p] = x; up(p); up(x);&#125;inline int splay(int x)&#123; for(int p = fa[x]; p; rotate(x), p = fa[x]) if(fa[p]) rotate((get(p) == get(x)) ? p : x); rt = x;&#125;inline void ins(int x)&#123; if(!rt)&#123; ++ sz; rt = sz; key[sz] = x; size[sz] = cnt[sz] = 1; son[sz][0] = son[sz][1] = fa[sz] = 0; return ; &#125; int now = rt, p = 0; while(1)&#123; if(key[now] == x)&#123; cnt[now] ++; up(now); up(p); splay(now); return ; &#125; p = now; now = son[now][x &gt; key[now]]; if(!now)&#123; sz ++; key[sz] = x; size[sz] = cnt[sz] = 1; son[sz][0] = son[sz][1] = 0; son[p][x &gt; key[p]] = sz; fa[sz] = p; up(p); splay(sz); return ; &#125; &#125;&#125;inline int find(int x)&#123; int now = rt, ans = 0; while(1)&#123; if(x == key[now])&#123;ans += size[son[now][0]]; splay(now); return ans + 1;&#125; if(x &lt; key[now]) now = son[now][0]; else &#123; ans += size[son[now][0]] + cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline int find_rnk(int x)&#123; int now = rt; while(1)&#123; if(x == -1) return -1; if(x &gt;= size[son[now][0]] + 1 &amp;&amp; x &lt;= size[son[now][0]] + cnt[now]) return key[now]; if(x &lt;= size[son[now][0]]) now = son[now][0]; else &#123; x = x - size[son[now][0]] - cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline int pre()&#123; int x = son[rt][0]; while(son[x][1]) x = son[x][1]; return x;&#125;inline int sub()&#123; int x = son[rt][1]; while(son[x][0]) x = son[x][0]; return x;&#125;inline void del(int x)&#123; int cfzsb = find(x); if(cnt[rt] &gt; 1)&#123;cnt[rt] --; up(rt); return ;&#125; if(!son[rt][0] &amp;&amp; !son[rt][1]) return ; if(!son[rt][0] || !son[rt][1])&#123; rt = son[rt][0] + son[rt][1]; fa[rt] = 0; return ; &#125; int oldrt = rt, leftbig = pre(); splay(leftbig); fa[son[oldrt][1]] = rt; son[rt][1] = son[oldrt][1]; up(rt);&#125;void init()&#123; int n = read(); for(int i = 1; i &lt;= n; i ++)&#123; int opt = read(), x = read(); if(opt == 1) ins(x); else if(opt == 2) del(x); else if(opt == 3) printf("%d\n", find(x)); else if(opt == 4) printf("%d\n", find_rnk(x)); else if(opt == 5)&#123; ins(x); printf("%d\n", key[pre()]); del(x); &#125; else if(opt == 6)&#123; ins(x); printf("%d\n", key[sub()]); del(x); &#125; &#125;&#125;int main()&#123; init(); return 0;&#125; 题目与练习然后接下来我们可以看一些题： BZOJ1588（洛谷2234）题意：一共n个数，对于当前输入的数x，我们找到之前已经输入进来的b个数中的一个数，使得其与x的差的绝对值最小，将这个最小的绝对值加进答案中。特殊的，第一个输入的数的数值直接加入答案中。 题解这道题十分的模板，对于当前输入的点x，把它insert进去后，找到其前驱与后继，然后在insert的时候判断一下是否已经出现过此数，用几个bool变量就能解决。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 2e5 + 15;int sz = 0, rt;int key[MAXN], size[MAXN], son[MAXN][2], fa[MAXN], cnt[MAXN];bool fl, fr, ff, hh;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void up(int p)&#123;size[p] = cnt[p] + size[son[p][0]] + size[son[p][1]];&#125;inline int get(int x)&#123;return son[fa[x]][1] == x;&#125;inline void rotate(int x)&#123; int p = fa[x], g = fa[p], opt = get(x); son[p][opt] = son[x][opt ^ 1]; fa[son[x][opt ^ 1]] = p; son[x][opt ^ 1] = p; fa[p] = x; fa[x] = g; if(g) son[g][son[g][1] == p] = x; up(p); up(x);&#125;inline int splay(int x)&#123; for(int p = fa[x]; p; rotate(x), p = fa[x]) if(fa[p]) rotate((get(p) == get(x)) ? p : x); rt = x;&#125;inline void ins(int x)&#123; if(!rt)&#123; ++ sz; rt = sz; key[sz] = x; size[sz] = cnt[sz] = 1; son[sz][0] = son[sz][1] = fa[sz] = 0; return ; &#125; int now = rt, p = 0; while(1)&#123; if(key[now] == x)&#123; cnt[now] ++; hh = 1; up(now); up(p); splay(now); return ; &#125; p = now; now = son[now][x &gt; key[now]]; if(!now)&#123; sz ++; key[sz] = x; size[sz] = cnt[sz] = 1; son[sz][0] = son[sz][1] = 0; son[p][x &gt; key[p]] = sz; fa[sz] = p; up(p); splay(sz); return ; &#125; &#125;&#125;inline int find(int x)&#123; int now = rt, ans = 0; while(1)&#123; if(x == key[now])&#123;ans += size[son[now][0]]; splay(now); return ans + 1;&#125; if(x &lt; key[now]) now = son[now][0]; else &#123; ans += size[son[now][0]] + cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline int find_rnk(int x)&#123; int now = rt; while(1)&#123; if(x == -1) return -1; if(x &gt;= size[son[now][0]] + 1 &amp;&amp; x &lt;= size[son[now][0]] + cnt[now]) return key[now]; if(x &lt;= size[son[now][0]]) now = son[now][0]; else &#123; x = x - size[son[now][0]] - cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline int pre()&#123; int x = son[rt][0]; if(!x) fl = 0; while(son[x][1]) x = son[x][1]; return x;&#125;inline int sub()&#123; int x = son[rt][1]; if(!x) fr = 0; while(son[x][0]) x = son[x][0]; return x;&#125;inline void del(int x)&#123; int cfzsb = find(x); if(cnt[rt] &gt; 1)&#123;cnt[rt] --; up(rt); return ;&#125; if(!son[rt][0] &amp;&amp; !son[rt][1]) return ; if(!son[rt][0] || !son[rt][1])&#123; rt = son[rt][0] + son[rt][1]; fa[rt] = 0; return ; &#125; int oldrt = rt, leftbig = pre(); splay(leftbig); fa[son[oldrt][1]] = rt; son[rt][1] = son[oldrt][1]; up(rt);&#125;void init()&#123; int n = read(), ans; int x = read(); ins(x); ans += x; for(int i = 2; i &lt;= n; i ++)&#123; fl = 1, fr = 1, hh = 0; x = read(); ins(x); int a = key[pre()], b = key[sub()]; //printf("%d %d\n", a, b); //printf("%d %d\n", fl, fr); if(hh) continue; int tot = (1 &lt;&lt; 31) - 1; if(fl) tot = min(tot, abs(x - a)); if(fr) tot = min(tot, abs(x - b)); //printf("%d\n", tot); ans += tot; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); return 0;&#125; 洛谷2286题意：给出宠物和人出现的序列，宠物和人都会选择①现在存在的②和自己特征值之差的绝对值最小的③特征值最小的非同类【即宠物选择人，人选择宠物】，选择成功时将会累计一个特征值差的绝对值作为不满意度，当序列结束时输出不满意度的和对1000000取模的值显而易见选择的方案是唯一的。 题解：这道题跟上一道差不多啊，只不过特判的东西不太一样，然后可能需要一个Delete操作，然后也就没什么了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const LL MAXN = 2e5 + 15;const LL MOD = 1e6;LL key[MAXN], son[MAXN][2], fa[MAXN], size[MAXN], cnt[MAXN];LL sz = 0, rt;bool fl, fr, ff;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void up(LL p)&#123;size[p] = cnt[p] + size[son[p][0]] + size[son[p][1]];&#125;inline LL get(LL x)&#123;return son[fa[x]][1] == x;&#125;inline void rotate(LL x)&#123; LL p = fa[x], g = fa[p], opt = get(x); son[p][opt] = son[x][opt ^ 1]; fa[son[x][opt ^ 1]] = p; son[x][opt ^ 1] = p; fa[p] = x; fa[x] = g; if(g) son[g][son[g][1] == p] = x; up(p); up(x);&#125;inline LL splay(LL x)&#123; for(LL p = fa[x]; p; rotate(x), p = fa[x]) if(fa[p]) rotate((get(p) == get(x)) ? p : x); rt = x;&#125;inline void ins(LL x)&#123; if(!rt)&#123; ++ sz; rt = sz; key[sz] = x; size[sz] = cnt[sz] = 1; son[sz][0] = son[sz][1] = fa[sz] = 0; return ; &#125; LL now = rt, p = 0; while(1)&#123; if(key[now] == x)&#123; cnt[now] ++; ff = 1; up(now); up(p); splay(now); return ; &#125; p = now; now = son[now][x &gt; key[now]]; if(!now)&#123; sz ++; key[sz] = x; size[sz] = cnt[sz] = 1; son[sz][0] = son[sz][1] = 0; son[p][x &gt; key[p]] = sz; fa[sz] = p; up(p); splay(sz); return ; &#125; &#125;&#125;inline LL find(LL x)&#123; LL now = rt, ans = 0; while(1)&#123; if(x == key[now])&#123;ans += size[son[now][0]]; splay(now); return ans + 1;&#125; if(x &lt; key[now]) now = son[now][0]; else &#123; ans += size[son[now][0]] + cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline LL find_rnk(LL x)&#123; LL now = rt; while(1)&#123; if(x == -1) return -1; if(x &gt;= size[son[now][0]] + 1 &amp;&amp; x &lt;= size[son[now][0]] + cnt[now]) return key[now]; if(x &lt;= size[son[now][0]]) now = son[now][0]; else &#123; x = x - size[son[now][0]] - cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline LL pre()&#123; LL x = son[rt][0]; if(!x) fl = 0; while(son[x][1]) x = son[x][1]; return x;&#125;inline LL sub()&#123; LL x = son[rt][1]; if(!x) fr = 0; while(son[x][0]) x = son[x][0]; return x;&#125;inline void del(LL x)&#123; LL cfzsb = find(x); if(cnt[rt] &gt; 1)&#123;cnt[rt] --; up(rt); return ;&#125; if(!son[rt][0] &amp;&amp; !son[rt][1])&#123;key[rt] = fa[rt] = cnt[rt] = size[rt] = 0; rt = 0;&#125; if(!son[rt][0] || !son[rt][1])&#123; rt = son[rt][0] + son[rt][1]; fa[rt] = 0; return ; &#125; LL oldrt = rt, leftbig = pre(); splay(leftbig); fa[son[oldrt][1]] = rt; son[rt][1] = son[oldrt][1]; up(rt);&#125;void init()&#123; LL n = read(), tot = 0; LL ans = 0; LL flag; for(LL i = 1; i &lt;= n; i ++)&#123; LL opt = read(), x = read(); if(i == 1)&#123;flag = opt; ins(x); tot ++;&#125; else if(flag == opt || !tot)&#123;ins(x); tot ++; flag = opt;&#125; else &#123; tot --; fl = 1, fr = 1, ff = 0; LL mark, tot = 21474836478; ins(x); if(ff)&#123;del(x); del(x); continue;&#125; LL a = key[pre()], b = key[sub()]; if(fl &amp;&amp; tot &gt; abs(x - a))&#123;tot = abs(x - a); mark = a;&#125; if(fr &amp;&amp; tot &gt; abs(x - b))&#123;tot = abs(x - b); mark = b;&#125; del(x); del(mark); ans = (ans + 1ll * tot) % MOD; &#125; &#125; printf("%lld\n", ans);&#125;int main()&#123; init(); return 0;&#125; BZOJ1503题意：OIER公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把他们的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第k多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？ I命令 I_k 新建一个工资档案，初始工资为k。如果某员工的初始工资低于工资下界，他将立刻离开公司。 A命令 A_k 把每位员工的工资加上k S命令 S_k 把每位员工的工资扣除k F命令 F_k 查询第k多的工资 题解：我们可以单独开一个tot记扣的钱（或涨的钱）的总数。对于新建档案，我们就用一般的ins就可以了。 难点就在于踢掉&lt;min的人。那么我们找到最小的要被踢掉的人，给他旋转至根，然后删掉其左子树即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;#define clr(x, y) memset(x, y, sizeof(x));LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 2e5 + 15;int key[MAXN], size[MAXN], cnt[MAXN], fa[MAXN], son[MAXN][2]; int sz, rt, pos = 0;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline int get(int x)&#123;return son[fa[x]][1] == x;&#125;inline void up(int x)&#123;size[x] = size[son[x][0]] + size[son[x][1]] + cnt[x];&#125;inline void clear()&#123; rt = sz = 0; clr(key, 0); clr(size, 0); clr(son, 0); clr(fa, 0); clr(cnt, 0);&#125;inline void rotate(int x)&#123; int p = fa[x], g = fa[p], opt = get(x); son[p][opt] = son[x][opt ^ 1]; fa[son[x][opt ^ 1]] = p; son[x][opt ^ 1] = p; fa[p] = x; fa[x] = g; if(g) son[g][son[g][1] == p] = x; up(p); up(x);&#125;inline void splay(int x)&#123; for(int p = fa[x]; p; rotate(x), p = fa[x]) if(fa[p]) rotate((get(x) == get(p)) ? p : x); rt = x;&#125;inline void ins(int x)&#123; if(!rt)&#123; ++ sz; rt = sz; key[sz] = x; son[sz][0] = son[sz][1] = fa[sz] = 0; cnt[sz] = size[sz] = 1; return ; &#125; int now = rt, p = 0; while(1)&#123; if(key[now] == x)&#123; cnt[now] ++; up(now); up(p); splay(now); return ; &#125; p = now; now = son[now][x &gt; key[now]]; if(!now)&#123; ++ sz; key[sz] = x; son[sz][0] = son[sz][1] = 0; fa[sz] = p; son[p][x &gt; key[p]] = sz; size[sz] = cnt[sz] = 1; up(sz); up(p); splay(sz); return ; &#125; &#125;&#125;inline int find(int x)&#123; int now = rt, ans = 0; while(1)&#123; if(key[now] == x)&#123;ans += size[son[now][0]]; splay(now); return ans + 1;&#125; if(key[now] &gt; x) now = son[now][0]; else &#123; ans += size[son[now][0]] + cnt[now]; now = son[now][1]; &#125; &#125;&#125;inline int find_rnk(int x)&#123; int now = rt; while(1)&#123; if(!now) return -1; if(x &gt;= size[son[now][1]] + 1 &amp;&amp; x &lt;= size[son[now][1]] + cnt[now])&#123;splay(now); return key[now] + pos;&#125; if(x &lt;= size[son[now][1]]) now = son[now][1]; else &#123; x = x - size[son[now][1]] - cnt[now]; now = son[now][0]; &#125; &#125;&#125;inline int pre()&#123; int now = son[rt][0]; while(son[rt][1]) now = son[rt][1]; return now;&#125;inline int sub()&#123; int now = son[rt][1]; while(son[rt][0]) now = son[rt][0]; return now;&#125;inline void del(int x)&#123; int whatever = find(x); if(cnt[rt] &gt; 1)&#123;cnt[rt] --; up(rt); return ;&#125; if(!son[rt][0] &amp;&amp; !son[rt][1])&#123;clear(); return ;&#125; if(!son[rt][0] || !son[rt][1])&#123; rt = son[rt][0] + son[rt][1]; fa[rt] = 0; return ; &#125; int leftbig = pre(), ort = rt; splay(leftbig); son[rt][1] = son[ort][1]; fa[son[ort][1]] = rt; up(rt);&#125;void init()&#123; int n = read(), minn = read(), ans = 0; clear(); while(n --)&#123; char ch[5]; scanf("%s", ch); int x = read(); if(ch[0] == 'I' &amp;&amp; x &gt;= minn) ins(x - pos); else if(ch[0] == 'A')&#123;pos += x;&#125; else if(ch[0] == 'S')&#123; pos -= x; ins(minn - pos); ans += size[son[rt][0]]; son[rt][0] = 0; up(rt); del(minn - pos); &#125; else if(ch[0] == 'F') printf("%d\n", find_rnk(x)); &#125; printf("%d\n", ans);&#125;int main()&#123; init(); return 0;&#125; 讲解与模板2splay有很多应用。 接下来我们就先来谈谈splay的区间应用。 好，我们以洛谷的3391【模板】文艺平衡树举例 传送门 这道题就是反转一个子序列，好，那么我们该怎么办呢？ 首先，我们建一个a数组，a[i] = i（最开始序列的状态）。 然后我们根据a数组建树（满足左儿子小于父亲，右儿子大于父亲）。 我们很容易发现，这棵树的中序遍历便是原序列，并且我们在splay旋转的过程中，这一性质不变。相信很多人看过关于这方面的blog，说是这次操作只需将l-1移到根，r+1移到根的右儿子，那么l~r就在root的rson的lson里，画个图大家就知道了。 既然都在一棵子树中了，我们就交换左右儿子即可。 模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define clr(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAXN = 2e5 + 15;int a[MAXN], rt, sz, head, tail, n, m;int fa[MAXN], key[MAXN], son[MAXN][2], size[MAXN], opt[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;inline void clear()&#123; rt = 0, sz = 0; head = n + 1; tail = n + 2; clr(fa, 0); clr(son, 0); clr(key, 0); clr(size, 0); clr(opt, 0);&#125;inline int get(int x)&#123;return son[fa[x]][1] == x;&#125;inline void up(int o)&#123;size[o] = size[son[o][0]] + size[son[o][1]] + 1;&#125;inline void down(int o)&#123; if(!opt[o]) return ; swap(son[o][0], son[o][1]); if(son[o][0]) opt[son[o][0]] ^= 1; if(son[o][1]) opt[son[o][1]] ^= 1; opt[o] = 0;&#125;inline void build(int &amp;o, int p, int l, int r)&#123; if(l == r)&#123;o = ++ sz; key[o] = a[l]; size[o] = 1; fa[o] = p; return ;&#125; if(l + 1 == r)&#123; o = ++ sz; int rson = ++ sz; key[o] = a[l]; key[rson] = a[r]; fa[o] = p; fa[rson] = o; son[o][1] = rson; size[o] = 2; size[rson] = 1; return ; &#125; int mid = (l + r) &gt;&gt; 1; o = ++ sz; key[o] = a[mid]; size[o] = 1; fa[o] = p; build(son[o][0], o, l, mid - 1); build(son[o][1], o, mid + 1, r); up(o);&#125;inline int find(int x)&#123; int now = rt; x ++; while(1)&#123; down(now); if(size[son[now][0]] + 1 == x) return now; if(size[son[now][0]] + 1 &gt; x) now = son[now][0]; else &#123; x = x - size[son[now][0]] - 1; now = son[now][1]; &#125; &#125;&#125;inline int rotate(int x)&#123; int p = fa[x], g = fa[p], typ = get(x); son[p][typ] = son[x][typ ^ 1]; fa[son[x][typ ^ 1]] = p; son[x][typ ^ 1] = p; fa[p] = x; fa[x] = g; if(g) son[g][son[g][1] == p] = x; up(p); up(x);&#125;inline void splay(int x, int dtn)&#123; for(int p = fa[x]; p != dtn &amp;&amp; p; rotate(x), p = fa[x]) if(fa[p] != dtn &amp;&amp; fa[p]) rotate((get(x) == get(p)) ? p : x);&#125;inline void rever(int l, int r)&#123; l = find(l - 1), r = find(r + 1); splay(l, 0); rt = l; splay(r, rt); opt[son[son[rt][1]][0]] ^= 1;&#125;inline void output(int o)&#123; down(o); if(son[o][0]) output(son[o][0]); if(key[o] != head &amp;&amp; key[o] != tail) printf("%d ", key[o]); if(son[o][1]) output(son[o][1]);&#125;void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; i ++) a[i] = i; a[0] = n + 1, a[n + 1] = n + 2; clear(); build(rt, 0, 0, n + 1); for(int i = 1; i &lt;= m; i ++)&#123; int l = read(), r = read(); rever(l, r); &#125; output(rt); printf("\n");&#125;int main()&#123; init(); return 0;&#125; 题目与练习BZOJ1861题意：小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用1到n的正整数给每本书都编了号。 小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有X-1、X或X+1本书。 当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。 久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为X的书在书柜的什么位置；(2)从上到下第i本书的编号是多少。 第一行有两个数n，m，分别表示书的个数以及命令的条数；第二行为n个正整数：第i个数表示初始时从上至下第i个位置放置的书的编号；第三行到m+2行，每行一条命令。命令有5种形式： 1． Top S——表示把编号为S的书房在最上面。 2． Bottom S——表示把编号为S的书房在最下面。 3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书； 4． Ask S——询问编号为S的书的上面目前有多少本书。 5． Query S——询问从上面数起的第S本书的编号。 题解：对于本题有5个操作，我将一一说明对于每种操作的具体做法。 1.Top 将元素旋到根，然后将左子树合并到该元素的后继 2.Bottom 将元素旋到根，然后将右子树合并到该元素的前驱 3.Insert 直接与该元素的前驱/后继交换位置及信息 4.Ask 将元素旋到根，输出size-1 5.Query 在树上find_rnk即可 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 2e5 + 15;int key[MAXN], son[MAXN][2], fa[MAXN], opt[MAXN], size[MAXN], loc[MAXN];int n, m, a[MAXN], sz, rt;inline void up(int x)&#123;size[x] = size[son[x][0]] + size[son[x][1]] + 1;&#125;inline int get(int x)&#123;return son[fa[x]][1] == x;&#125;inline void clear()&#123; rt = sz = 0; memset(fa, 0, sizeof(fa)); memset(son, 0, sizeof(son)); memset(key, 0, sizeof(key)); memset(size, 0, sizeof(size));&#125;inline void rotate(int x)&#123; int p = fa[x], g = fa[p], opt = get(x); son[p][opt] = son[x][opt ^ 1]; fa[son[x][opt ^ 1]] = p; son[x][opt ^ 1] = p; fa[p] = x; fa[x] = g; if(g) son[g][son[g][1] == p] = x; up(p); up(x);&#125;inline void splay(int x, int dtn)&#123; for(int p = fa[x]; p != dtn &amp;&amp; p; rotate(x), p = fa[x]) if(fa[p] != dtn &amp;&amp; fa[p]) rotate((get(x) == get(p)) ? p : x); if(!dtn) rt = x;&#125;inline void build(int &amp;o, int p, int l, int r)&#123; if(l == r)&#123; o = ++ sz; key[o] = a[l]; size[o] = 1; loc[a[l]] = o; son[o][0] = son[o][1] = 0; fa[o] = p; return ; &#125; if(l + 1 == r)&#123; o = ++ sz; int rson = ++ sz; son[o][1] = rson; size[o] = 2; size[son[o][1]] = 1; fa[o] = p; fa[son[o][1]] = o; key[o] = a[l]; key[son[o][1]] = a[l + 1]; loc[a[l]] = o; loc[a[l + 1]] = son[o][1]; return ; &#125; int mid = l + r &gt;&gt; 1; o = ++ sz; size[o] = 1; fa[o] = p; key[o] = a[mid]; loc[a[mid]] = o; build(son[o][0], o, l, mid - 1); build(son[o][1], o, mid + 1, r); up(o);&#125;inline int pre()&#123; int now = son[rt][0]; if(!now) return -1; while(son[now][1]) now = son[now][1]; return now;&#125;inline int sub()&#123; int now = son[rt][1]; if(!now) return -1; while(son[now][0]) now = son[now][0]; return now;&#125;inline void top(int x)&#123; splay(loc[x], 0); int rightmin = sub(); if(!son[rt][0]) return ; if(rightmin == -1)&#123;swap(son[rt][0], son[rt][1]); return ;&#125; splay(rightmin, rt); son[son[rt][1]][0] = son[rt][0]; fa[son[son[rt][1]][0]] = son[rt][1]; son[rt][0] = 0; up(son[rt][1]);&#125;inline void bottom(int x)&#123; splay(loc[x], 0); int leftmax = pre(); if(!son[rt][1]) return ; if(leftmax == -1)&#123;swap(son[rt][0], son[rt][1]); return ;&#125; splay(leftmax, rt); son[son[rt][0]][1] = son[rt][1]; fa[son[son[rt][0]][1]] = son[rt][0]; son[rt][1] = 0; up(son[rt][0]);&#125;inline void rever_front(int x)&#123; splay(loc[x], 0); int leftmax = pre(); if(leftmax == -1) return ; splay(leftmax, rt); swap(key[son[rt][0]], key[rt]); swap(loc[key[son[rt][0]]], loc[key[rt]]);&#125;inline void rever_back(int x)&#123; splay(loc[x], 0); int rightmin = sub(); if(rightmin == -1) return ; splay(rightmin, rt); swap(key[son[rt][1]], key[rt]); swap(loc[key[son[rt][1]]], loc[key[rt]]);&#125;inline int find(int x)&#123;splay(loc[x], 0); return size[son[rt][0]];&#125;inline int find_rnk(int x)&#123; int now = rt; while(1)&#123; if(size[son[now][0]] + 1 == x) return key[now]; if(size[son[now][0]] + 1 &gt; x) now = son[now][0]; else &#123; x = x - size[son[now][0]] - 1; now = son[now][1]; &#125; &#125;&#125;inline void output(int o)&#123; if(son[o][0]) output(son[o][0]); printf("%d ", key[o]); if(son[o][1]) output(son[o][1]);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;int main()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; i ++) a[i] = read(); clear(); build(rt, 0, 1, n); while(m --)&#123; char ch[11]; scanf("%s", ch + 1); int x = read(); if(ch[1] == 'T') top(x); else if(ch[1] == 'B') bottom(x); else if(ch[1] == 'I')&#123;int y = read(); if(y == 1) rever_back(x); else if(y == -1) rever_front(x);&#125; else if(ch[1] == 'A') printf("%d\n", find(x)); else if(ch[1] == 'Q')&#123;printf("%d\n", find_rnk(x));&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基题目练习]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[原来没听说过什么是线性基（估计是本juruo太菜了），但是学懂以后感觉用处真的挺多的，这段时间里做题都想着用线性基。。。估计是黔驴技穷了吧，我还是刷题太少了，这次刷题我感觉线性基的一些基本用法、套路我都过了一遍，还是很开心很激动的，不过当时何神讲的题还是有好多都没有做，接下来还是抓紧时间多做一些线性基的难题吧！ 知道线性基是什么之后，本蒟蒻就刷了刷题。 洛谷3812模板的不能再模板 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 65;LL b[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void init()&#123; int n = read(); for(int i = 1; i &lt;= n; i ++)&#123; LL x; scanf("%lld", &amp;x); for(int j = 55; j &gt;= 0; j --) if((1LL &lt;&lt; j) &amp; x)&#123; if(!b[j])&#123;b[j] = x; break;&#125; else x ^= b[j]; &#125; &#125; LL ans = 0; for(int i = 55; i &gt;= 0; i --) if((ans ^ b[i]) &gt; ans) ans ^= b[i]; printf("%lld\n", ans);&#125;int main()&#123; init(); return 0;&#125; BZOJ 2460题意： $n$个数，每个数有两个属性：a和b，从中选出一些数，使得在这些数的a异或起来不为0的情况下，b之和最大。 题解： 这题十分的水嘛。 贪心+线性基 我们每加入一个数时，ans再加上其法力值就完了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e3 + 15;const int MAXM = 65;LL ans = 0, a[MAXM];struct Node&#123;LL b, w;&#125;t[MAXM];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void doit(int n)&#123; for(int i = 1; i &lt;= n; i ++)&#123; LL x = t[i].b; for(int j = 65; ~j; j --) if((1LL &lt;&lt; j) &amp; x)&#123; if(!a[j])&#123;a[j] = x; break;&#125; else x ^= a[j]; &#125; if(x) ans += t[i].w; &#125;&#125;bool cmp(Node x, Node y)&#123; if(x.w != y.w) return x.w &gt; y.w; return x.b &lt; y.b;&#125;void init()&#123; int n = read(); for(int i = 1; i &lt;= n; i ++) scanf("%lld %lld", &amp;t[i].b, &amp;t[i].w); sort(t + 1, t + n + 1, cmp); doit(n); printf("%lld\n", ans);&#125;int main()&#123; init(); return 0;&#125; BZOJ2115题意： 给你一张无相连通图，带边权，然后让你求从点1到点n所经过的边的边权异或和最大是多少。 （注意：一条边可以重复走多次） 题解： 显然，我们考虑这样一件事，对于我们当前所在的点u，准备到v，如果我们在u到v的这条路上走多次，最终到达v，那么异或出来的结果和u直接走到v的值一样（a^b^b=a），所以说，我们直接考虑从1到n不走重复路线的情况下的异或和。 既然是一个无相连通图，它就有可能有很多简单环，对于能够使ans变大的环的异或和，我们显然是要把它加进1到n的这条路径中去。 所以说，做法已经明了了。1.dfs预处理出图上所有简单环，并且处理出每个环的异或和，还要找到一条1到n的路径，算出其异或和now。2.我们把这些简单环的异或和放在一个数组中，问题就转换成了模板题“异或和最大”的问题，然后再^now，这显然就是答案了。 那么，我们可能会想，为什么刚开始我们随机找一条1到n的不走重复边的路径一定就能保证最优性的？很显然，我们通过dfs寻找简单环的时候一定有（我们刚开始随机找到的1到n的路径pass1+另外一条与其不相交的1到n的路径pass2）这种环如果我们把now^这个环的异或和，那么就相当于我们最开始找的就是pass2。 还有一个疑问，肯定就是如果某一个被我们异或进答案的环的异或和，这个环上面的点与我们找到的1到n的路径没有共同点怎么办？其实不用担心那么多，我们从最开始找的这条路走，走到某一个点后开始像那个环前进，绕了一圈后，我们再原路返回，这样“多出来的”这段路就抵消了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 5e4 + 15;const int MAXM = 1e5 + 15;struct Edge&#123;int to, nxt; LL dis;&#125;g[MAXM &lt;&lt; 2];int head[MAXN], cnt = 0, tot = 0;LL crcl[MAXM &lt;&lt; 2], dist[MAXN], b[70];bool vis[MAXN];void add(int u, int v, LL dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;void add_edge(int u, int v, LL dis)&#123;add(u, v, dis); add(v, u, dis);&#125;void dfs(int u)&#123; vis[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!vis[v])&#123;dist[v] = dist[u] ^ g[i].dis; dfs(v);&#125; else crcl[++ tot] = dist[u] ^ dist[v] ^ g[i].dis; &#125;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void L_basis()&#123; for(int i = 1; i &lt;= tot; i ++)&#123; LL x = crcl[i]; for(int j = 62; ~j; j --) if((1LL &lt;&lt; j) &amp; x)&#123; if(!b[j])&#123;b[j] = x; break;&#125; x ^= b[j]; &#125; &#125;&#125;void init()&#123; int n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(); LL dis; scanf("%lld", &amp;dis); add_edge(u, v, dis); &#125; dfs(1); LL ans = dist[n]; L_basis(); for(int i = 62; ~i; i --) ans = Max(ans, ans ^ b[i]); printf("%lld\n", ans);&#125;int main()&#123; init(); return 0;&#125; HDOJ3949题意： 给定 $n(n≤10000)$ 个数 $a_1, a_2, …,a_n$，以及 $Q(Q≤10000)$ 个询问，每次询问这些数（至少一个，不能不选）能够组成的异或和中第 $k$ 小的数是什么（去掉重复的异或和）。 题解： 这道题我们分两种考虑：1.线性基中的基向量的数量cnt=n的时候，异或值不可能出0（因为B是V的线性无关的极大集合，所以说V此时也是线性无关的），我们求出线性基后，把k在二进制下进行拆分，对于第0位至第max_base位，如果k的这位为1，那么我们就异或上对应的基向量值。2.线性基中的基向量的数量cnt&lt;n的时候，异或值可能出现0（B为线性无关，|B|&lt;n，所以V为线性相关），所以我们先把k-1然后再按照上述做法解决问题。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define REP(i, a, b) for(int i = a; i &lt;= b; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;LL abs(LL x)&#123;return x &gt; 0 ? x : -x;&#125;const int MAX_BASE = 63;const int MAXN = 1e5 + 15;LL a[MAXN], b[MAX_BASE];int cnt = 0; bool flag = 0;vector&lt;LL&gt; v;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void L_Basis(int n)&#123; for(int i = 1; i &lt;= n; i ++)&#123; LL x = a[i]; for(int j = 60; ~j; j --) if((1LL &lt;&lt; j) &amp; x)&#123; if(!b[j])&#123; b[j] = x; cnt ++; for(int k = j - 1; k &gt;= 0; k --) if(b[k] &amp;&amp; ((b[j] &gt;&gt; k) &amp; 1)) b[j] ^= b[k]; for(int k = j + 1; k &lt;= 60; k ++) if((b[k] &gt;&gt; j) &amp; 1) b[k] ^= b[j]; break; &#125; else x ^= b[j]; &#125; &#125; if(cnt != n) flag = 1; v.clear(); for(int i = 0; i &lt;= 60; i ++) if(b[i]) v.push_back(b[i]);&#125;inline LL query(LL k)&#123; LL num = (1LL &lt;&lt; cnt) - 1, ans = 0; if(flag) k --; if(k &gt; num) return -1; for(int i = 0; i &lt; cnt; i ++) if((k &gt;&gt; i) &amp; 1) ans ^= v[i]; return ans;&#125;void init()&#123; int T = read(); for(int ca = 1; ca &lt;= T; ca ++)&#123; memset(b, 0, sizeof(b)); cnt = 0; flag = 0; int n = read(); for(int i = 1; i &lt;= n; i ++) scanf("%lld", &amp;a[i]); L_Basis(n); printf("Case #%d:\n", ca); int m = read(); while(m --)&#123; LL k; scanf("%lld", &amp;k); printf("%lld\n", query(k)); &#125; &#125;&#125;int main()&#123; init(); return 0;&#125; 总结:线性基的套路题： 1.第k个异或和 2.求所有异或值的和 同时，我们还可发现 任意一条 $1$ 到 $n$ 的路径的异或和，都可以由任意一条 $1$ 到 $n$ 路径的异或和与图中的一些环的异或和来组合得到。]]></content>
      <categories>
        <category>总结</category>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基学习]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本篇文章很多内容选自 线性基1 线性基2 先说明一点，$a_i$表示一个标量，而加粗的$a_i$表示一个向量，以便于区分。 概述基（basis）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的OI题目中，通常利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作$ \lceil$线性基$\rfloor$。 预备知识向量空间（vector space）定义$(F,V,+,•)$为向量空间（vector space），其中$F$为域，$V$为集合，$V$中元素称为向量，$+$为向量加法，$•$为标量乘法，且运算满足8条公理。 线性无关（linearly independent）对于向量空间中 $V$ 上 $n$ 个元素的向量组 $(v_1, v_2,…,v_n)$，若存在不全为 $0$ 的数 $a_i\in F$，满足 $a_1 v_1+a_2 v_2 + … + a_n v_n = 0$ 则称这 $n$ 个向量线性相关（linearly dependent），否则称为线性无关（linearly independent）。 线性组合（linear combination）对于向量空间中 $V$ 上 $n$ 个元素的向量组$(v_1, v_2,..,v_n)$，其线性组合（linear combination）是如下形式的向量 $a_1 v_1+a_2 v_2 + … + a_n v_n$ 其中 $a_1, …,a_n∈F$。 一组向量线性无关⇔ 没有向量可用有限个其他向量的线性组合所表示 张成（span）对于向量空间中 $V$ 上 $n$ 个元素的向量组$(v_1, v_2,..,v_n)$ ，其所有线性组合所构成的集合称为 $(v_1, v_2,..,v_n)$的张成（span），记为$span(v_1, v_2,..,v_n)$。 基（basis）若向量空间 $V$ 中向量组$B$既是线性无关的又可以张成 $V$，则称其为 $V$ 的基（basis）。 $B$中的元素称为基向量。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。 性质设 $B$ 是向量空间 $V$ 的基。则 $B$ 具有以下性质： $V$ 是 $B$ 的极小生成集，就是说只有 $B$ 能张成 $V$，而它的任何真子集都不张成全部的向量空间。 $B$ 是 $V$ 中线性无关向量的极大集合，就是说 $B$ 在 $V$ 中是线性无关集合，而且 $V$ 中没有其他线性无关集合包含它作为真子集。 $V$ 中所有的向量都可以按唯一的方式表达为 $B$ 中向量的线性组合。 第三点尤其重要，感性的理解，基就是向量空间中的一个子集，它可以通过唯一的线性组合，来张成向量空间中所有的向量，这样就可以大大的缩小我们向量空间的大小。 线性相关性引理（Linear Dependent Lemma）如果 $(v_1, v_2,..,v_n)$ 在 $V$ 中是线性相关的，并且 $v_1\not= 0$，则有至少一个 $j\in {2,…,m} $ 使得下列成立： $vj\in span(v_1, v_2,..,v{j-1})$ 如果从 $(v_1, v_2,..,v_n)$ 去掉第 $j$ 项，则剩余向量组的张成仍然等于 $span(v_1, v_2,..,v_n)$ 。 证明：设 $(v_1, v_2,..,v_n)$ 在 $V$ 中是线性相关的，并且 $v_1\not=0$，则有不全为 $0$ 的 $a_1,a_2,…,a_n\in F$，使得$a_1 v_1+…+a_m v_m=0$ $a_2,a_3,…,a_n​$ 不会全为 $0​$（因为 $v_1\not=0​$）。设 $j​$ 是 $2,…,m​$ 中使得 $a_j\not=0​$ 的最大者，那么 v_j=-\frac{a_1}{a_j}v_1-...-\frac{a_{j-1}}{a_j}v_{j-1}这就有 $(1)$ 成立。 为了证明 $(2)$，设 $u\in span(v_1,…,v_n)$则存在 $c_1,…,c_n\in F$，使得 $u=c_1 v_1+…+c_n v_n$ 在上面的等式中，可以用之前的等式右边来代替$v_j$。这样 $u$ 包含于从$(v_1, v_2,..,v_n)$ 去掉第 $j$ 项的张成，因而 $(2)$ 成立。]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.10.27刷题总结]]></title>
    <url>%2F2017%2F10%2F27%2F2017-10-27%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[好像已经一周没有写刷题总结了，那么今天就稍微总结一下这段时间刷的一些题。 最近主要是在洛谷刷题，刷一些提高-省选难度的题。 洛谷3388： 【模板】割点（割顶） 分析： 这道题就是一个模板，所以我就大概说一下tarjan怎么求个点吧。 当一个点是割点时，我们考虑这样两种情况： 这个点没有father（即为根节点），且它的son的数量&gt;1，那么显然删掉这个点后这个图就不连通了。 对于一个比u后tarjan到的点v，且u有father，保证low[v] &gt;= dfn[u]，那么u点就是割点（因为如果low[v]&lt;dfn[u]，那么说明v能翻到u的上面，那么这样就会形成一个环，所以此时删不删u到无法影响这个图的连通性） 注意：向上翻的时候不能把dfn[v]写成low[v]，这样容易翻过，那么肯定就WA了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e5 + 15;int n, m;int head[MAXN], cnt = 0, fa[MAXN];int dfn[MAXN], low[MAXN], tot = 0;struct Edge&#123;int to, nxt;&#125;g[MAXN &lt;&lt; 1];int ans[MAXN], tmp = 0;bool isg[MAXN], vis[MAXN];void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_edge(int u, int v)&#123;add(u, v); add(v, u);&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; int rootson = 0; dfn[u] = low[u] = ++ tot; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; fa[v] = u; rootson ++; tarjan(v); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u] &amp;&amp; fa[u]) vis[u] = 1; &#125; else if(v != fa[u]) low[u] = min(low[u], dfn[v]); &#125; if(rootson &gt; 1 &amp;&amp; !fa[u]) vis[u] = 1;&#125;void solve()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!dfn[i]) tarjan(i); &#125; int ans = 0; for(int i = 1; i &lt;= n; i ++) if(vis[i]) ans ++; printf("%d\n", ans); for(int i = 1; i &lt;= n; i ++) if(vis[i]) printf("%d ", i); printf("\n");&#125;void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(); add_edge(u, v); &#125; solve();&#125;int main()&#123; init(); return 0;&#125; ​ ​ 洛谷3807: 【模板】卢卡斯定理 分析： 又是一道模板题，此处证明略，若想看证明，可以到我的csdn blog去看。 这道题就是用lucas定理：$Lucas^mn\ \ mod\ \ p = C^{m\ \ mod\ \ p}{n\ \ mod\ \ p} \times Lucas^{m/p}_{n/p}$ 所以这题也没什么可说的了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 2e5 + 15;LL frac[MAXN];inline int read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;LL qpow(LL a, LL b, LL p)&#123; LL base = a, ret = 1; while(b)&#123; if(b &amp; 1) ret = ret * base % p; base = base * base % p; b &gt;&gt;= 1; &#125; return ret;&#125;LL C(LL n, LL m, LL p)&#123; if(m &gt; n) return 0; return ((frac[n] * (qpow(frac[n - m], p - 2, p)) % p) % p * (qpow(frac[m], p - 2, p)) % p) % p;&#125;LL Lucas(LL n, LL m, LL p)&#123; if(m == 0) return 1; return ((C(n % p, m % p, p) % p) * (Lucas(n / p, m / p, p)) % p) % p;&#125;void init()&#123; int T = read(); while(T --)&#123; LL n = read(), m = read(), p = read(); frac[0] = 1; for(LL i = 1; i &lt;= p; i ++)&#123;frac[i] = (frac[i - 1] * i) % p;&#125; //for(LL i = 2; i &lt;= n + m; i ++) printf("%lld ", frac[i]); //printf("\n"); printf("%lld\n", Lucas(n + m, m, p)); &#125;&#125;int main()&#123; //fre(); init(); return 0;&#125; 洛谷3811： 【模板】乘法逆元 分析： 公式，不解释。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 3e6;int inv[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;//83分做法：费马小定理 LL qpow(LL a, LL b, LL p)&#123; LL base = a, ret = 1; while(b)&#123; if(b &amp; 1) ret = ret * base % p; base = base * base % p; b &gt;&gt;= 1; &#125; return ret % p;&#125;//100分做法：线性求逆元 void solve(int n, int p)&#123; inv[1] = 1; for(int i = 2; i &lt;= n; i ++) inv[i] = (1ll * (p - p / i) * inv[p % i]) % (1ll * p);&#125;void init()&#123; int n = read(), p = read(); solve(n, p); for(int i = 1; i &lt;= n; i ++) printf("%d\n", inv[i] % p);&#125;int main()&#123; //fre(); init(); return 0;&#125; 洛谷2002： 消息扩散 分析： tarjan缩点，然后找缩点后的入度为零的点的个数即为答案。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e6 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN], e[MAXN];int head[MAXN], cnt = 0, tot = 0, ans = 0, n, m;int head_sd[MAXN], cnt_sd = 0, in_sd[MAXN], belong[MAXN];int sta[MAXN], dfn[MAXN], low[MAXN], tmp = 0;bool instack[MAXN];void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_sd(int u, int v)&#123;e[++ cnt_sd] = (Edge)&#123;v, head_sd[u]&#125;; head_sd[u] = cnt_sd;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; sta[++ tmp] = u, instack[u] = 1, dfn[u] = low[u] = ++ tot; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; ans ++; while(sta[tmp] != u)&#123; int gg = sta[tmp]; belong[gg] = ans; instack[gg] = 0; tmp --; &#125; instack[u] = 0; tmp --; belong[u] = ans; &#125;&#125;void query()&#123; int anss = 0; for(int i = 1; i &lt;= ans; i ++) if(!in_sd[i]) anss ++; printf("%d\n", anss);&#125;void suodian()&#123; for(int i = 1; i &lt;= n; i ++) if(!belong[i]) belong[i] = ++ ans; for(int i = 1; i &lt;= n; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1)&#123;add_sd(u1, v1); in_sd[v1] ++;&#125; &#125; &#125; query();&#125;void solve()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!dfn[i]) tarjan(i); &#125; suodian(); &#125;void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(); add(u, v); &#125; solve();&#125;int main()&#123; init(); return 0;&#125; 洛谷3373： 【模板】线段树 2 分析： 这道线段树其实也就是个模板，但是个人感觉比较容易错，尤其是什么先乘后加，加的懒标记也要乘之类的，这个自己画画图都能明白。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(LL i = 1; i &lt;= n; i ++)#define REPG(i, x) for(LL i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const LL MAXN = 1e5 + 15;LL a[MAXN], s[MAXN &lt;&lt; 2], col[MAXN &lt;&lt; 2], mul[MAXN &lt;&lt; 2], MOD;void up(LL p)&#123;s[p] = (s[p &lt;&lt; 1] + s[p &lt;&lt; 1 | 1]) % MOD;&#125;void build(LL p, LL l, LL r)&#123; mul[p] = 1; if(l == r)&#123;s[p] = a[l]; return ;&#125; LL mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); up(p);&#125;void down(LL p, LL l, LL r)&#123; if(mul[p] != 1)&#123; (col[p &lt;&lt; 1] *= mul[p]) %= MOD; (s[p &lt;&lt; 1] *= mul[p]) %= MOD; (mul[p &lt;&lt; 1] *= mul[p]) %= MOD; (col[p &lt;&lt; 1 | 1] *= mul[p]) %= MOD; (s[p &lt;&lt; 1 | 1] *= mul[p]) %= MOD; (mul[p &lt;&lt; 1 | 1] *= mul[p]) %= MOD; mul[p] = 1; &#125; if(col[p])&#123; int mid = (l + r) &gt;&gt; 1; (col[p &lt;&lt; 1] += col[p]) %= MOD; (s[p &lt;&lt; 1] += (mid - l + 1) * col[p]) %= MOD; (col[p &lt;&lt; 1 | 1] += col[p]) %= MOD; (s[p &lt;&lt; 1 | 1] += (r - mid) * col[p]) %= MOD; col[p] = 0; &#125;&#125;void modify(LL p, LL l, LL r, LL x, LL y, LL c, int gg)&#123; if(x &lt;= l &amp;&amp; r &lt;= y)&#123; if(gg == 2)&#123;(s[p] += (r - l + 1) * c) %= MOD; (col[p] += c) %= MOD;&#125; else if(gg == 1)&#123;(col[p] *= c) %= MOD; (mul[p] *= c) %= MOD; (s[p] *= c) %= MOD;&#125; return ; &#125; down(p, l, r); LL mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) modify(p &lt;&lt; 1, l, mid, x, y, c, gg); if(y &gt; mid) modify(p &lt;&lt; 1 | 1, mid + 1, r, x, y, c, gg); up(p);&#125;LL query(LL p, LL l, LL r, LL x, LL y)&#123; LL ret = 0; if(x &lt;= l &amp;&amp; r &lt;= y) return s[p]; down(p, l, r); LL mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) (ret += query(p &lt;&lt; 1, l, mid, x, y)) %= MOD; if(y &gt; mid) (ret += query(p &lt;&lt; 1 | 1, mid + 1, r, x, y)) %= MOD; up(p); return ret;&#125;inline LL read()&#123; LL r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void init()&#123; LL n = read(), q = read(); MOD = read(); for(LL i = 1; i &lt;= n; i ++) a[i] = read(); //for(LL i = 1; i &lt;= MAXN; i ++) mul[i] = 1; build(1, 1, n); while(q --)&#123; LL gg = read(); if(gg == 2)&#123; LL x = read(), y = read(), k = read(); modify(1, 1, n, x, y, k, 2); &#125; else if(gg == 3)&#123; LL x = read(), y = read(); printf("%lld\n", query(1, 1, n, x, y) % MOD); &#125; else if(gg == 1)&#123; LL x = read(), y = read(), k = read(); modify(1, 1, n, x, y, k, 1); &#125; &#125;&#125;int main()&#123; //fre(); init(); return 0;&#125; 洛谷2574： XOR的艺术 分析： 这道题由于它xor的是1，那么也就意味着0变1，1变0.所以说我们记录区间内1的个数就可以了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define lson (o &lt;&lt; 1)#define rson (o &lt;&lt; 1 | 1)using namespace std;const int MAXN = 2e5 + 15;char str[MAXN];int n, m, a[MAXN &lt;&lt; 2];struct Segment_Tree&#123; int sumv[MAXN &lt;&lt; 2], optv[MAXN &lt;&lt; 2]; inline void pushup(int o) &#123; sumv[o]=sumv[lson]+sumv[rson]; return; &#125; inline void pushdown(int o, int l, int r) &#123; if(optv[o])&#123; int mid = (l + r) &gt;&gt; 1; optv[lson]^= 1; optv[rson] ^= 1; sumv[lson]=(mid - l + 1)-sumv[lson]; sumv[rson]=(r - mid)-sumv[rson]; optv[o]=0; &#125; &#125; inline void build(int o, int l, int r) &#123; optv[o]=0; if(l==r) &#123; sumv[o]= a[l]; return; &#125; int mid = (l+r)&gt;&gt;1; if(l &lt;= mid) build(lson, l, mid); if(r &gt; mid) build(rson, mid+1, r); pushup(o); &#125; inline int querysum(int o, int l, int r, int ql, int qr) &#123; if(ql&lt;=l &amp;&amp; qr&gt;=r) return sumv[o]; pushdown(o, l, r); int mid = (l+r)&gt;&gt;1, ans=0; if(ql &lt;= mid) ans+= querysum(lson, l, mid, ql, qr); if(qr &gt; mid) ans+= querysum(rson, mid+1, r, ql, qr); return ans; &#125; inline void optadd(int o, int l, int r, int ql, int qr) &#123; if(ql&lt;=l &amp;&amp; qr&gt;=r) &#123; optv[o] ^= 1; sumv[o]=(r - l + 1) - sumv[o]; return;&#125; pushdown(o, l, r); int mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid) optadd(lson, l, mid, ql, qr); if(qr &gt; mid) optadd(rson, mid+1, r, ql, qr); pushup(o); &#125;&#125; st;int main()&#123; scanf("%d%d", &amp;n, &amp;m); cin&gt;&gt; str; for(int i=1; i&lt;=n; i++) a[i]=str[i-1]-'0'; st.build(1, 1, n); for(int i=1; i&lt;=m; i++) &#123; int tmp1, l, r; scanf("%d%d%d", &amp;tmp1, &amp;l, &amp;r); if(tmp1==1) printf("%d\n", st.querysum(1, 1, n, l, r)); if(tmp1==0) st.optadd(1, 1, n, l, r); &#125; return 0;&#125; 洛谷1099： 树网的核 分析： 首先我们得明确一件事：对于多条树的直径，不管最后的路径F在那一条上，都有偏心距最优解，因为它们的直径中心是确定的 这样就简单了，我先dfs一遍，找到其中一条树的直径，然后在这条直径上枚举小于等于s的路径，然后跑SPFA，最后取个点的dist最大的值再和ans取一个min即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e3 + 15;struct Edge&#123;int to, nxt, dis;&#125;g[MAXN];int e[MAXN][MAXN];int head[MAXN], cnt = 0, dist[MAXN], tmp = -1, tot, pat[MAXN];int pre[MAXN], cost[MAXN], ss[MAXN], dd[MAXN];void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125;queue &lt;int&gt; q;bool vis[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void dfs(int u, int fafa)&#123; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v != fafa)&#123; if(dist[v] &lt; dist[u] + g[i].dis)&#123; dist[v] = dist[u] + g[i].dis; pre[v] = u; &#125; if(dist[v] &gt; tmp)&#123;tmp = dist[v]; tot = v;&#125; dfs(v, u); &#125; &#125;&#125;void SPFA()&#123; while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = 0; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(dd[v] &gt; dd[u] + g[i].dis)&#123; dd[v] = dd[u] + g[i].dis; if(!vis[v])&#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;void init()&#123; int n = read(), s = read(), cnt_ld = 0, ans = 2e9; int gg = -1, st, en; for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(), dis = read(); add_edge(u, v, dis); e[u][v] = e[v][u] = dis; &#125; for(int i = 1; i &lt;= n; i ++)&#123; dfs(i, 0); if(dist[tot] &gt; gg)&#123; cnt_ld = 0; gg = dist[tot]; st = i; en = tot; for(int j = en; ; j = pre[j])&#123; pat[++ cnt_ld] = j; if(j == st) break; &#125; &#125; tot = -1; memset(dist, 0, sizeof(dist)); memset(pre, 0, sizeof(pre)); &#125; for(int i = 1; i &lt;= (cnt_ld &gt;&gt; 1); i ++) swap(pat[cnt_ld - i + 1], pat[i]); for(int i = 1; i &lt;= cnt_ld; i ++)&#123;vis[pat[i]] = 1; if(i != 1) ss[i] = ss[i - 1] + e[pat[i - 1]][pat[i]];&#125; for(int i = 1; i &lt;= cnt_ld; i ++)&#123; memset(dd, 0x3f, sizeof(dd)); memset(vis, 0, sizeof(vis)); while(!q.empty()) q.pop(); int j; for(j = i; j &lt;= cnt_ld; j ++)&#123; if(ss[j] - ss[i] &gt; s)&#123;j --; break;&#125; &#125; for(int k = i; k &lt;= j; k ++)&#123;dd[pat[k]] = 0; q.push(pat[k]); vis[pat[k]] = 1;&#125; SPFA(); int orzcfz = 0; for(int k = 1; k &lt;= n; k ++) orzcfz = max(orzcfz, dd[k]); ans = min(ans, orzcfz); &#125; printf("%d\n", ans);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.10.21刷题总结]]></title>
    <url>%2F2017%2F10%2F22%2F2017-10-21%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近一直都在刷一些有关tarjan（缩点）的题。 洛谷1262： 由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果A间谍手中掌握着关于B间谍的犯罪证据，则称A可以揭发B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。 我们的反间谍机关提供了一份资料，色括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有n个间谍(n不超过3000)，每个间谍分别用1到3000的整数来标识。 请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。 分析：显然，我们判断no的条件是最开始通过没一个想被收买的人出发dfs，如果有的点没有被dfs到，那么就输出No。编号随着dfs的时候记录一下即可。 接下来我们再考虑最小费用。 显然，只要一个强连通分量中只要有一个人愿意被收买，我们就能知道这个强连通分量中所有点的信息。所以说我们先用tarjan缩点，然后记录一下每个强连通分量中想被收买的间谍的最下费用，对于一个缩完的点，如果它的入读为0的话，ans加上它的w_min。ans即为答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 2e5 + 15;const int INF = 2e9;struct Edge&#123;int to, nxt;&#125;g[MAXN], e[MAXN];int ans1 = 0, ans2 = 0;int head[MAXN], head_sd[MAXN], cnt = 0, cnt_sd = 0;int in[MAXN], out[MAXN], ans = 0, dfns = 0, n, tot = 0;int dfn[MAXN], low[MAXN], sta[MAXN], in_sd[MAXN], out_sd[MAXN], belong[MAXN];int w[MAXN], w_sd[MAXN], num_sd[MAXN], min_num = INF;bool instack[MAXN], vis[MAXN];void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_sd(int u, int v)&#123;e[++ cnt_sd] = (Edge)&#123;v, head_sd[u]&#125;; head_sd[u] = cnt_sd;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ dfns; instack[u] = 1; sta[++ tot] = u; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123;tarjan(v); low[u] = min(low[u], low[v]);&#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; ans ++; while(sta[tot] != u)&#123; int gg = sta[tot]; instack[gg] = 0; belong[gg] = ans; tot --; &#125; instack[u] = 0; tot --; belong[u] = ans; &#125;&#125;void suodian()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!belong[i]) belong[i] = ++ ans; w_sd[belong[i]] = min(w_sd[belong[i]], w[i]); &#125; for(int i = 1; i &lt;= n; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1)&#123;add_sd(u1, v1); in_sd[v1] ++; out_sd[u1] ++;&#125; &#125; &#125;&#125;void dfs(int u)&#123; //cout&lt;&lt;u&lt;&lt;endl; vis[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!vis[v]) dfs(v); &#125;&#125;void doit()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!dfn[i]) tarjan(i); &#125; suodian();&#125;bool check()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(w[i] != INF &amp;&amp; !vis[i]) dfs(i); &#125; for(int i = 1; i &lt;= n; i ++) if(!vis[i]) min_num = min(min_num, i); if(min_num != INF) return 1; return 0;&#125;void query()&#123; int anss = 0; for(int i = 1; i &lt;= ans; i ++) if(!in_sd[i]) anss += w_sd[i]; printf("YES\n%d\n", anss);&#125;void init()&#123; n = read(); int p = read(); for(int i = 1; i &lt;= (n &lt;&lt; 1); i ++) w[i] = w_sd[i] = INF; for(int i = 1; i &lt;= p; i ++)&#123; int x = read(), dis = read(); w[x] = dis; &#125; int r = read(); for(int i = 1; i &lt;= r; i ++)&#123; int from = read(), to = read(); add(from, to); &#125; min_num = INF; if(check())&#123;printf("NO\n%d\n", min_num); return ;&#125; doit(); query(); &#125;int main()&#123; //freopen("testdata (1).in", "r", stdin); //freopen("my.out", "w", stdout); init(); return 0;&#125; 洛谷2341： 每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶 牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜 欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你 算出有多少头奶牛可以当明星。 分析： 题目的要求是求受欢迎的牛的数量，其实就是将题目给出的图经过缩点后求出度为0的强连通分量编号里面点的个数，在这有一些需要特判的情况，即当经缩点后出度为0的点的个数大于1时是不符合条件的（因为如果这样就不是大家都喜欢的牛了），所以这种情况应该输出0。其他地方就没有什么该注意的地方了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e5 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN], e[MAXN];int ans1 = 0, ans2 = 0;int head[MAXN], head_sd[MAXN], cnt = 0, cnt_sd = 0;int in[MAXN], out[MAXN], ans = 0, dfns = 0, n, m, tot = 0;int dfn[MAXN], low[MAXN], sta[MAXN], in_sd[MAXN], out_sd[MAXN], belong[MAXN];int orzqyf[MAXN];bool instack[MAXN];void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_sd(int u, int v)&#123;e[++ cnt_sd] = (Edge)&#123;v, head_sd[u]&#125;; head_sd[u] = cnt_sd;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ dfns; instack[u] = 1; sta[++ tot] = u; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123;tarjan(v); low[u] = min(low[u], low[v]);&#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; ans ++; while(sta[tot] != u)&#123; int gg = sta[tot]; instack[gg] = 0; belong[gg] = ans; tot --; &#125; instack[u] = 0; tot --; belong[u] = ans; &#125;&#125;void suodian()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!belong[i]) belong[i] = ++ ans; orzqyf[belong[i]] ++; &#125; for(int i = 1; i &lt;= n; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1)&#123;add_sd(u1, v1); in_sd[v1] ++; out_sd[u1] ++;&#125; &#125; &#125;&#125;void doit()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!dfn[i]) tarjan(i); &#125; suodian();&#125;void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(); add(u, v); &#125; doit(); int orzcjr = 0, orzpkl; for(int i = 1; i &lt;= ans; i ++)&#123; if(!out_sd[i])&#123;orzcjr ++; orzpkl = i;&#125; &#125; if(orzcjr &gt; 1) printf("0\n"); else printf("%d\n", orzqyf[orzpkl]);&#125;int main()&#123; init(); return 0;&#125; 洛谷2746&amp;2812： 一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。 你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。 分析： 因为这两道题是一样的，所以我放在一起来说。 很显然，子任务A就是求缩完点之后，入度为0的点的个数；子任务B就是求缩完点后，入读为0的点的个数和出度为0的点的个数的较大值（因为我们要使它形成一个大环，出入度都必须大于0）。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e5 + 15;struct Edge&#123;int to, nxt;&#125;g[MAXN], e[MAXN];int ans1 = 0, ans2 = 0;int head[MAXN], head_sd[MAXN], cnt = 0, cnt_sd = 0;int in[MAXN], out[MAXN], ans = 0, dfns = 0, n, tot = 0;int dfn[MAXN], low[MAXN], sta[MAXN], in_sd[MAXN], out_sd[MAXN], belong[MAXN];bool instack[MAXN];void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_sd(int u, int v)&#123;e[++ cnt_sd] = (Edge)&#123;v, head_sd[u]&#125;; head_sd[u] = cnt_sd;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ dfns; instack[u] = 1; sta[++ tot] = u; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123;tarjan(v); low[u] = min(low[u], low[v]);&#125; else if(instack[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u])&#123; ans ++; while(sta[tot] != u)&#123; int gg = sta[tot]; instack[gg] = 0; belong[gg] = ans; tot --; &#125; instack[u] = 0; tot --; belong[u] = ans; &#125;&#125;void suodian()&#123; for(int i = 1; i &lt;= n; i ++) if(!belong[i]) belong[i] = ++ ans; for(int i = 1; i &lt;= n; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1)&#123;add_sd(u1, v1); in_sd[v1] ++; out_sd[u1] ++;&#125; &#125; &#125;&#125;void doit()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!dfn[i]) tarjan(i); &#125; suodian();&#125;void query2()&#123; int tmp1 = 0, tmp2 = 0; for(int i = 1; i &lt;= ans; i ++)&#123; if(!in_sd[i]) tmp1 ++; if(!out_sd[i]) tmp2 ++; &#125; if(ans == 1) printf("0\n"); else printf("%d\n", max(tmp1, tmp2));&#125;void query1()&#123; for(int i = 1; i &lt;= ans; i ++) if(!in_sd[i]) ans1 ++; printf("%d\n", ans1);&#125;void init()&#123; n = read(); for(int i = 1; i &lt;= n; i ++)&#123; int v = read(); while(v)&#123;add(i, v); in[v] ++, out[i] ++; v = read();&#125; &#125; doit(); query1(); query2();&#125;int main()&#123; init(); return 0;&#125; 洛谷3387： 给定一个n个点m条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。 允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。 分析： 洛谷给的是tarjan+dp，然而我不太懂怎么dp，所以我就用了SPFA。 缩完点后对于入度为0的点跑一遍SPFA，最后取最大值即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e5 + 15; struct Edge&#123;int to, nxt;&#125;g[MAXN];struct Edge_sd&#123;int to, nxt;&#125;e[MAXN];int head[MAXN], cnt = 0, sta[MAXN], belong[MAXN], w[MAXN], in[MAXN];int dist[MAXN], dw[MAXN], dfn[MAXN], low[MAXN];int head_sd[MAXN], cnt_sd = 0;int dfsn = 0, tot = 0, ans = 0;int n, m;bool instack[MAXN], vis[MAXN];queue &lt;int&gt; q;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void add(int u, int v)&#123;g[++ cnt] = (Edge)&#123;v, head[u]&#125;; head[u] = cnt;&#125;void add_sd(int u, int v)&#123;e[++ cnt_sd] = (Edge_sd)&#123;v, head_sd[u]&#125;; head_sd[u] = cnt_sd;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ dfsn; sta[++ tot] = u; instack[u] = 1; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(!dfn[v])&#123;tarjan(v); low[u] = min(low[u], low[v]);&#125; else if(instack[v]) low[u] = min(dfn[v], low[u]); &#125; if(dfn[u] == low[u])&#123; ans ++; while(sta[tot] != u)&#123; int gg = sta[tot]; instack[gg] = 0; belong[gg] = ans; tot --; &#125; tot --; instack[u] = 0; belong[u] = ans; &#125;&#125;int SPFA(int x)&#123; int ret; ret = dist[x] = dw[x]; q.push(x); vis[x] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = 0; for(int i = head_sd[u]; i; i = e[i].nxt)&#123; int v = e[i].to; if(dist[v] &lt; dist[u] + dw[v])&#123; dist[v] = dist[u] + dw[v]; ret = max(ret, dist[v]); if(!vis[v])&#123;q.push(v); vis[v] = 1;&#125; &#125; &#125; &#125; return ret;&#125;void doit()&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(!dfn[i]) tarjan(i); &#125;&#125;void pre()&#123; for(int i = 1; i &lt;= n; i ++) if(!belong[i]) belong[i] = ++ ans; for(int i = 1; i &lt;= n; i ++)&#123; int u1 = belong[i]; for(int j = head[i]; j; j = g[j].nxt)&#123; int v1 = belong[g[j].to]; if(u1 != v1 &amp;&amp; u1 &amp;&amp; v1)&#123;add_sd(u1, v1); in[v1] ++;&#125; &#125; &#125; for(int i = 1; i &lt;= n; i ++) dw[belong[i]] += w[i];&#125;void init()&#123; memset(dist, 0xc0, sizeof(dist)); n = read(), m = read(); for(int i = 1; i &lt;= n; i ++) w[i] = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(); add(u, v); &#125; doit(); pre(); int anss = 0; for(int i = 1; i &lt;= ans; i ++)&#123; if(!in[i]) anss = max(anss, SPFA(i)); &#125; //for(int i = 1; i &lt;= n; i ++) printf("%d ", belong[i]); //printf("\n"); printf("%d\n", anss);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.10.18刷题总结]]></title>
    <url>%2F2017%2F10%2F18%2F2017-10-18%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[其实今天也没有做多少道题，毕竟也只有一个晚上。 总结：首先，不得不承认，我之前一直不太会Dijsktra和Prim，然后今天在自习课上稍微学习了一下，然后晚上打了两个模板，然后休息的时候又打了一个LCA模板。之后呢，做了做一些水题，调了调之前比赛的题，然后一个晚上就这么过去了。 明日计划： 明天中午呢，时间不多，调调之前的题，然后打一下tarjan算法的模板。 明天下午肯定是要打模拟赛的，一定要拼全力！难也要打暴力，简单就要拿住分，不要用模拟赛都很难来吓唬自己。 明天晚上还有3h。明天的晚上肯定是要调下午的题，看情况，如果调完之后还有时间，那么我计划晚上（或中午）打一下tarjan算法的模板（毕竟有一段时间没打了，熟悉一下），然后在洛谷上做一做有关tarjan算法的题（目标：3-4道）供选题：洛谷1262，洛谷2002，洛谷2746，洛谷2863，bzoj1051，codevs1332。 2017.10.18题解 洛谷1078 题意：有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来 文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。 现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。 分析：这道题它的n最大只到100，而且它求的是一个s到t的最短路，所以说，我们很容易，而且很显然的就能想到这道题我们可以用floyd来解决，只不过它有一些限制条件，即排斥关系，这个用二维数组记一下，然后floyd的时候特判一下就好。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e3 + 15;const int MAXX = 2e9;int civ[MAXN], f[MAXN][MAXN];bool vis[MAXN][MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;void init()&#123; int n = read(), k = read(), m = read(), s = read(), t = read(); for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= n; j ++) f[i][j] = MAXX; for(int i = 1; i &lt;= n; i ++) civ[i] = read(); for(int i = 1; i &lt;= k; i ++)&#123; for(int j = 1; j &lt;= k; j ++) vis[i][j] = read(); &#125; for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(), dis = read(); if(!vis[civ[u]][civ[v]]) f[v][u] = dis; if(!vis[civ[v]][civ[u]]) f[u][v] = dis; &#125; for(int k = 1; k &lt;= n; k ++)&#123; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; if(vis[civ[i]][civ[j]]) continue; if(!vis[civ[k]][civ[i]] &amp;&amp; !vis[civ[j]][civ[k]] &amp;&amp; f[i][k] != MAXX &amp;&amp; f[k][j] != MAXX) f[i][j] = min(f[i][k] + f[k][j], f[i][j]); &#125; &#125; &#125; if(f[s][t] == MAXX) printf("-1\n"); else printf("%d\n", f[s][t]);&#125;int main()&#123; //fre(); init(); return 0;&#125; 注意：这道题的排斥关系很容易搞混，i排斥j不代表j就一定排斥i。更。。。的是，$a_{i,j}$表示的是i排斥外来文化j，也就是说，你到了j之后就不能到i了，而不是表示你到i之后不能到j了。所以说，二维数组的记录把常人所理解的i，j颠倒一下就好了。 洛谷1265 题意： 某国有n个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。 修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。 政府审批的规则如下： （1）如果两个或以上城市申请修建同一条公路，则让它们共同修建； （2）如果三个或以上的城市申请修建的公路成环。如下图，A申请修建公路AB，B申请修建公路BC，C申请修建公路CA。则政府将否决其中最短的一条公路的修建申请； （3）其他情况的申请一律同意。 一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相：连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。 当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。 你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。 分析：根据它的描述，我们就不难看出它的这个模拟过程就近似于一个prim算法的模拟过程，所以我们这道题的实质就是就最小生成树，由于这是一个稠密图，所以用prim显然更合适，据说kruskal会被卡掉5个点。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double LF;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 5e3 + 15;struct Node&#123;int x, y;&#125;a[MAXN];int n;LF dist[MAXN];bool vis[MAXN];LF ans = 0;LF cal(int x1, int y1, int x2, int y2)&#123; LF a1 = abs(x2 - x1), b1 = abs(y2 - y1); return sqrt(a1 * a1 + b1 * b1);&#125;void prim()&#123; vis[1] = 1; for(int i = 2; i &lt;= n; i ++)&#123; LF dd = cal(a[1].x, a[1].y, a[i].x, a[i].y); dist[i] = dd; &#125; for(int j = 1; j &lt; n; j ++)&#123; int u = j, v = -1; LF gg = 1e9 + 7; for(int i = 1; i &lt;= n; i ++)&#123; if(!vis[i] &amp;&amp; dist[i] &lt; gg)&#123;gg = dist[i]; v = i;&#125; &#125; vis[v] = 1; ans += gg; for(int i = 1; i &lt;= n; i ++)&#123; if(vis[i]) continue; LF dd = cal(a[v].x, a[v].y, a[i].x, a[i].y); if(dd &lt; dist[i]) dist[i] = dd; &#125; &#125;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;void init()&#123; n = read(); REP(i, n) a[i].x = read(), a[i].y = read(); prim(); printf("%.2lf\n", ans);&#125;int main()&#123; //fre(); init(); return 0;&#125; 洛谷2420 题意： 异或是一种神奇的运算,大部分人把它总结成不进位加法. 在生活中…xor运算也很常见。比如，对于一个问题的回答，是为1，否为0.那么： （A是否是男生 ）xor（ B是否是男生）＝A和B是否能够成为情侣 好了，现在我们来制造和处理一些复杂的情况。比如我们将给出一颗树，它很高兴自己有N个结点。树的每条边上有一个权值。我们要进行M次询问，对于每次询问，我们想知道某两点之间的路径上所有边权的异或值。 分析： 很显然，这是一道裸的LCA，不懂的看http://www.cnblogs.com/yyf0309/p/5972701.html 这道题只不过是需要加一维数组$px_{i,j}$表示i到i的$2^j$倍祖先的路径权值异或值。 求LCA的时候ans异或一下就好了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define REP(i, n) for(int i = 1; i &lt;= n; i ++)#define REPG(i, x) for(int i = head[x]; i; i = g[i].nxt)#define mem(x, y) memset(x, y, sizeof(x));using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;const int MAXN = 5e5 + 15;struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, p[MAXN][25], d[MAXN], xp[MAXN][25];int n, m, ans = 0;void add(int u, int v, int dis)&#123;g[++ cnt] = (Edge)&#123;v, head[u], dis&#125;; head[u] = cnt;&#125;void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125;void dfs(int now)&#123; for(int i = head[now]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v != p[now][0] &amp;&amp; !d[v])&#123; d[v] = d[now] + 1; p[v][0] = now; xp[v][0] = g[i].dis; dfs(v); &#125; &#125;&#125;int lca(int x, int y)&#123; if(d[x] &lt; d[y]) swap(x, y); int t = d[x] - d[y]; for(int i = 0; i &lt;= 21; i ++)&#123; if(t &amp; (1 &lt;&lt; i))&#123; ans ^= xp[x][i]; x = p[x][i]; &#125; &#125; for(int i = 21; i &gt;= 0; i --)&#123; if(p[x][i] != p[y][i])&#123; ans = ans ^ xp[x][i] ^ xp[y][i]; x = p[x][i]; y = p[y][i]; &#125; &#125; if(x == y) return ans; ans = ans ^ xp[x][0] ^ xp[y][0]; return ans;&#125;void doit()&#123; for(int j = 1; j &lt;= 21; j ++)&#123; for(int i = 1; i &lt;= n; i ++)&#123; if(p[i][j - 1])&#123; p[i][j] = p[p[i][j - 1]][j - 1]; xp[i][j] = xp[i][j - 1] ^ xp[p[i][j - 1]][j - 1]; &#125; &#125; &#125;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;void init()&#123; n = read(); for(int i = 1; i &lt; n; i ++)&#123;int u = read(), v = read(), dis = read(); add_edge(u, v, dis);&#125; dfs(1); doit(); m = read(); for(int i = 1; i &lt;= m; i ++)&#123; ans = 0; int x = read(), y = read(); printf("%d\n", lca(x, y)); &#125;&#125;int main()&#123; //fre(); init(); return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>最近公共祖先</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2835 刻录光盘 题解]]></title>
    <url>%2F2017%2F10%2F17%2F%E6%B4%9B%E8%B0%B72835-%E5%88%BB%E5%BD%95%E5%85%89%E7%9B%98-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这道题比较有（简）趣（单）。 题意： 给你一个图，求最大连通块的个数。 分析： 这道题也没什么好分析的吧。就是你记一下每个点的入度，然后看看有多少个点的入度为0，入度为0的点的个数即为ans。（注意：如果所有点的入度均大于0，那么ans=1） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e3 + 15;int in[MAXN];int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;void init()&#123; int n = read(), ans = 0; for(int i = 1; i &lt;= n; i ++)&#123; int x; scanf("%d", &amp;x); while(x != 0)&#123; in[x] ++; scanf("%d", &amp;x); //一定要用scanf！！！别用快读！！！ &#125; &#125; for(int i = 1; i &lt;= n; i ++) if(!in[i]) ans ++; if(!ans) ans = 1; printf("%d\n", ans);&#125;int main()&#123; //fre(); init(); return 0;&#125; 注意事项： 这道题有一点比较坑。第6个点我开始TLE了，然后发现是快读的问题，改成scanf就好了，莫名其妙，其实我也不知道这是怎么回事。知道的同学可以在评论或者某些地方跟我说一下，谢谢！]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1977 次小生成树 题解]]></title>
    <url>%2F2017%2F10%2F16%2Fbzoj1977-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[额。。。 这道题调了我两天，还用了别人的权限号，真的特别抱歉，主要是没跟他说，然后交了20多次才对。。。 题意： 这道题是说：让你求n个点的严格次小生成树，即所有权值和大于MST的权值和中最小的。 分析： 很显然，这道题就是一道次小生成树的问题。 首先次小生成树的求法就是先跑一边MST，然后暴力枚举每条不在MST上的边，然后更新。我们每次暴力枚举的是这条边，然后求这条边所连接的两个端点u,v在MST上的路径中的边权最大值，如果这个值等于当前的这条边的边权值w，那么很显然我们需要找到这条路径上的严格次大值，我们可以通过树上倍增的方式来求出路径上的边权最大值以及次大值，然后就没有然后了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL;typedef double DB; LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125; const int MAXN = 1e5 + 15;const int MAXM = 3e5 + 15;const int INF = 0x7fffffff; struct Node&#123;int a, b, c; bool vis;&#125;e[MAXM];struct Edge&#123;int to, nxt, dis;&#125;g[MAXN &lt;&lt; 1]; int head[MAXN], cnt = 0, tot = 0, gg = INF;LL ans = 0;int fa[MAXN], p[MAXN][20], d1[MAXN][20], d2[MAXN][20], dep[MAXN];int n, m; void add(int u, int v, int d)&#123; g[++ cnt].to = v; g[cnt].nxt = head[u]; g[cnt].dis = d; head[u] = cnt;&#125;void add_edge(int u, int v, int dis)&#123;add(u, v, dis); add(v, u, dis);&#125; int get(int x)&#123;return (fa[x] == x) ? x : fa[x] = get(fa[x]);&#125; bool cmp(Node x, Node y)&#123;return x.c &lt; y.c;&#125; void dfs(int x, int fafa)&#123; for(int i = 1; i &lt;= 16; i ++)&#123; if(dep[x] &lt; (1 &lt;&lt; i)) break; p[x][i] = p[p[x][i - 1]][i - 1]; d1[x][i] = max(d1[x][i - 1], d1[p[x][i - 1]][i - 1]); if(d1[x][i - 1] == d1[p[x][i - 1]][i - 1]) d2[x][i] = max(d2[x][i - 1], d2[p[x][i - 1]][i - 1]); else &#123; d2[x][i] = min(d1[x][i - 1], d1[p[x][i - 1]][i - 1]); d2[x][i] = max(d2[x][i], d2[x][i - 1]); d2[x][i] = max(d2[x][i], d2[p[x][i - 1]][i - 1]); &#125; &#125; for(int i = head[x]; i; i = g[i].nxt)&#123; int v = g[i].to; if(v != fafa)&#123; dep[v] = dep[x] + 1; d1[v][0] = g[i].dis; p[v][0] = x; dfs(v, x); &#125; &#125;&#125; int lca(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); int t = dep[x] - dep[y]; for(int i = 0; i &lt;= 16; i ++) if(t &amp; (1 &lt;&lt; i)) x = p[x][i]; for(int j = 16; j &gt;= 0; j --)&#123; if(p[x][j] != p[y][j])&#123; x = p[x][j]; y = p[y][j]; &#125; &#125; if(x == y) return x; return p[x][0];&#125; void kruskal()&#123; for(int i = 1; i &lt;= n; i ++) fa[i] = i; sort(e + 1, e + m + 1, cmp); for(int i = 1; i &lt;= m; i ++)&#123; int f1 = get(e[i].a), f2 = get(e[i].b); if(f1 != f2)&#123; fa[f1] = f2; ans += e[i].c; e[i].vis = 1; add_edge(e[i].a, e[i].b, e[i].c); tot ++; if(tot == n - 1) break; &#125; &#125;&#125; void cal(int x, int f, int v)&#123; int deep = dep[x] - dep[f]; int mx1 = 0, mx2 = 0; for(int i = 0; i &lt;= 16; i ++)&#123; if(deep &amp; (1 &lt;&lt; i))&#123; if(d1[x][i] &gt; mx1)&#123; mx2 = mx1; mx1 = d1[x][i]; &#125; mx2 = max(mx2, d2[x][i]); x = p[x][i]; &#125; &#125; if(mx1 != v) gg = min(gg, v - mx1); else gg = min(gg, v - mx2);&#125; void doit(int i, int x, int y, int v)&#123; int f = lca(x, y); cal(x, f, v); cal(y, f, v);&#125; int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125; void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123;e[i].a = read(), e[i].b = read(), e[i].c = read();&#125; kruskal(); dfs(1, 0); for(int i = 1; i &lt;= m; i ++) if(!e[i].vis) doit(i, e[i].a, e[i].b, e[i].c); printf("%lld\n", ans + gg);&#125; int main()&#123; init(); return 0;&#125; 注意事项： 这道题我可是被坑了很久的，所以还是有一些大家需要注意的地方： 1.ans一定要是long long的！要不然你算算就知道ans会爆int，然后就gg了。 2.数组一定要开够 3.倍增不要写错了。。。像我好像就是求LCA写错了。。。但是我之前一直这样写啊！！！所以很莫名其妙。。。]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1679 The Unique Tree 题解]]></title>
    <url>%2F2017%2F10%2F15%2FPOJ1679-The-Unique-Tree-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意： 这道题的题意大概就是说给你一个图，求其最小生成树的路径权值和是否唯一。 分析： 很显然，n个点的次小生成树的路径权值和是小于等于最小生成树的路径权值和的，所以我们只要求一下这n个点的最小生成树和次小生成树，比较一下它们的路径权值和是否相等即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long LL;typedef double DB;int Max(int a, int b)&#123;return a &gt; b ? a : b;&#125;int Min(int a, int b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 515;const int INF = 1e9 + 7;struct Node&#123; int l, r, w;&#125;e[MAXN * MAXN];struct sec_Edge&#123; int to, dis, nxt;&#125;g[MAXN &lt;&lt; 1];int head[MAXN], cnt = 0, fa[MAXN], f[MAXN][MAXN];int ans_max = 0, ans_maxx = INF, now, n, m;bool vis[MAXN * MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void add(int u, int v, int dis)&#123; g[++ cnt].to = v; g[cnt].dis = dis; g[cnt].nxt = head[u]; head[u] = cnt;&#125;int get(int x)&#123; return fa[x] == x ? x : fa[x] = get(fa[x]);&#125;bool cmp(Node x, Node y)&#123; return x.w &lt; y.w;&#125;void kruskal()&#123; sort(e + 1, e + m + 1, cmp); for(int i = 1; i &lt;= n; i ++) fa[i] = i; for(int i = 1; i &lt;= m; i ++)&#123; int f1 = get(e[i].l), f2 = get(e[i].r); if(f1 != f2)&#123; vis[i] = 1; ans_max += e[i].w; fa[f1] = f2; add(e[i].l, e[i].r, e[i].w); add(e[i].r, e[i].l, e[i].w); if(n - 1 == cnt / 2) return ; &#125; &#125;&#125;void dfs(int v, int fr, int maxe)&#123; f[now][v] = maxe; for(int i = head[v]; i; i = g[i].nxt)&#123; int k = g[i].to; if(k != fr) dfs(k, v, max(maxe, g[i].dis)); &#125;&#125;void init()&#123; int T = read(); while(T --)&#123; memset(head, 0, sizeof(head)); memset(f, 0, sizeof(f)); memset(vis, 0, sizeof(vis)); memset(fa, 0, sizeof(fa)); ans_max = 0, ans_maxx = INF, cnt = 0; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123;e[i].l = read(), e[i].r = read(), e[i].w = read();&#125; kruskal(); for(now = 1; now &lt;= n; now ++) dfs(now, 0, 0); for(int i = 1; i &lt;= m; i ++)&#123; if(!vis[i]) ans_maxx = min(ans_maxx, ans_max - f[e[i].l][e[i].r] + e[i].w); &#125; if(ans_max == ans_maxx) printf("Not Unique!\n"); else printf("%d\n", ans_max); &#125;&#125;int main()&#123; //fre(); init(); return 0;&#125; 注意事项： 这道题我交了12次才A。。。主要有两个低级错误： 1.POJ好像不让用bits/stdc++.h，害得我CE了三次。。。 2.数组一定要开够，我就开小了，然后MLE了8次。。。]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[次小生成树]]></title>
    <url>%2F2017%2F10%2F15%2F%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[首先， 我们肯定知道最小生成树的求法， 什么kruskal啊， prim啊， 随随便便就水了很多题不是吗？在面对次小生成树问题的时候， 可以选择枚举原MST中的每一条边进行删除， 然后跑MST的算法（当然， 可能有更好的暴力方法， 这里就不详细描述了）， 这样一来， 复杂度就到了O(nmlogm)的级别， 小一点的数据也是可以的。不过我们要追求更优的话， 就需要用到另一种方法。一个概念：最小瓶颈路在无向图中求一条连接两点的路径， 使路径上权值最大的边尽可能的小， 则这条路径称为最小瓶颈路。求法也很简单， 在原图中构建MST， 则在MST上两点间的路径即为最小瓶颈路了。证明也非常简单， 只要维护最大边最小的话， 可以将先前的所有边进行排序， 然后依次添加， 直到两点连通为止。 再看先前的操作， 不就是kruskal吗？具体过程：在熟悉了上面的概念以后， 接下来的过程就非常简单了。 这次我们枚举要添加哪一条边， 加上这条边的权值， 然后将这条边连接的两点的最小瓶颈路上的最大边权减去， 就得到了一棵新的生成树。 这就是“边交换”的过程， 毕竟次小生成树是由最小生成树删去一条边再添加一条新边得到的嘛， 这一点容易证明。 于是， 我们用O(m)的时间枚举新添加的边， 然后用O(1)的时间更新答案， 最后输出。 之前MST的复杂度为O(mlogm), 求最小瓶颈路上的最大权值为O(n²)， 总复杂度即为O(n²+mlogm)。 例题： https://vijos.org/p/1070/ “vijos 1070” http://poj.org/problem?id=1679/ “POJ 1679” 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 500 + 10#define M 150000#define INF 1000000000using namespace std;struct line&#123; int l, r, w;&#125;c[M];struct edge&#123; int fr, to, w, next;&#125;e[2*N];int n, m, num, now, ans1, ans2 = INF;int fa[N], p[N], d[N][N], used[M];bool cmp(line a, line b)&#123; return a.w &lt; b.w;&#125;int find(int x)&#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]);&#125;int read()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int x = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = 10*x + c - '0'; c = getchar(); &#125; return x;&#125;void add(int x, int y, int z)&#123; e[++num].fr = x; e[num].to = y; e[num].w = z; e[num].next = p[x]; p[x] = num;&#125;void init()&#123; n = read(), m = read(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].l = read(); c[i].r = read(); c[i].w = read(); &#125;&#125;void kruskal()&#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; sort(c+1, c+m+1, cmp); for (int i = 1; i &lt;= m; ++i) &#123; int fl = find(c[i].l), fr = find(c[i].r); if (fl != fr) &#123; used[i] = 1; fa[fl] = fr; ans1 += c[i].w; add(c[i].l, c[i].r, c[i].w); add(c[i].r, c[i].l, c[i].w); if (n - 1 == num / 2) return; &#125; &#125;&#125;//克鲁斯卡尔void dfs_mini(int x, int fr, int maxs)&#123; d[now][x] = maxs; for (int i = p[x]; i; i = e[i].next) &#123; int k = e[i].to; if (k != fr) dfs_mini(k, x, max(maxs, e[i].w)); &#125;&#125;//求最小瓶颈路上最大权值void deal()&#123; kruskal(); if (n - 1 == num / 2) printf("Cost: %d\n", ans1); else &#123; printf("Cost: -1\n"); printf("Cost: -1\n"); return; &#125; for (now = 1; now &lt;= n; ++now) dfs_mini(now, 0, 0); for (int i = 1; i &lt;= m; ++i) if (!used[i] &amp;&amp; ans1 - d[c[i].l][c[i].r] + c[i].w &lt; ans2) ans2 = ans1 - d[c[i].l][c[i].r] + c[i].w;//枚举并更新 if (ans2 != INF) printf("Cost: %d\n", ans2); else printf("Cost: -1\n");&#125;int main()&#123; init(); deal(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1941 飞扬的小鸟 题解]]></title>
    <url>%2F2017%2F10%2F09%2F%E6%B4%9B%E8%B0%B7P1941-%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天本蒟蒻又搞了一道DP题——飞扬的小鸟。题目：题目描述 Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。 为了简化问题，我们对游戏规则进行了简化和改编： 游戏界面是一个长为n ，高为 m 的二维平面，其中有k 个管道（忽略管道的宽度）。 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。 小鸟每个单位时间沿横坐标方向右移的距离为1 ，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度X ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度Y 。小鸟位于横坐标方向不同位置时，上升的高度X 和下降的高度Y 可能互不相同。 小鸟高度等于0 或者小鸟碰到管道时，游戏失败。小鸟高度为 m 时，无法再上升。现在，请你判断是否可以完成游戏。如果可以 ，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。 输入输出格式 输入格式：输入文件名为 bird.in 。 第1 行有3 个整数n ，m ，k ，分别表示游戏界面的长度，高度和水管的数量，每两个 整数之间用一个空格隔开； 接下来的n 行，每行2 个用一个空格隔开的整数X 和Y ，依次表示在横坐标位置0 ~n- 1 上玩家点击屏幕后，小鸟在下一位置上升的高度X ，以及在这个位置上玩家不点击屏幕时， 小鸟在下一位置下降的高度Y 。 接下来k 行，每行3 个整数P ，L ，H ，每两个整数之间用一个空格隔开。每行表示一 个管道，其中P 表示管道的横坐标，L 表示此管道缝隙的下边沿高度为L ，H 表示管道缝隙 上边沿的高度（输入数据保证P 各不相同，但不保证按照大小顺序给出）。 输出格式：输出文件名为bird.out 。 共两行。 第一行，包含一个整数，如果可以成功完成游戏，则输出1 ，否则输出0 。 第二行，包含一个整数，如果第一行为1 ，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。 输入输出样例 输入样例#1：10 10 63 99 91 21 31 21 12 12 11 62 21 2 75 1 56 3 57 5 88 7 99 1 3输出样例#1：16 输入样例#2：10 10 41 23 12 21 81 83 22 12 12 21 21 0 26 7 99 1 43 8 10输出样例#2：03说明 【输入输出样例说明】 如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。 【数据范围】 对于30% 的数据：5 ≤ n ≤ 10，5 ≤ m ≤ 10，k = 0 ，保证存在一组最优解使得同一单位时间最多点击屏幕3 次； 对于50% 的数据：5 ≤ n ≤ 2 0 ，5 ≤ m ≤ 10，保证存在一组最优解使得同一单位时间最多点击屏幕3 次； 对于70% 的数据：5 ≤ n ≤ 1000，5 ≤ m ≤ 1 0 0 ； 对于100%的数据：5 ≤ n ≤ 100 0 0 ，5 ≤ m ≤ 1 0 00，0 ≤ k &lt; n ，0&lt;X &lt; m ，0&lt;Y &lt;m，0&lt;P &lt;n，0 ≤ L &lt; H ≤ m ，L +1&lt; H 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double DB;const int N = 10050;const int M = 1050;int x[N], y[N];int n, m, p;int low[N], high[N];int f[N][M * 2];bool e[N];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;int Min(int a, int b)&#123;return a &lt; b ? a : b;&#125;int Max(int a, int b)&#123;return a &gt; b ? a : b;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;void GetData()&#123; n = read(), m = read(), p = read(); for(int i = 1; i &lt;= n; i ++) x[i] = read(), y[i] = read(); for(int i = 1; i &lt;= n; i ++)&#123; low[i] = 1; high[i] = m; &#125; for(int i = 1; i &lt;= p; i ++)&#123; int a = read(), b = read(), c = read(); low[a] = b + 1, high[a] = c - 1; e[a] = 1; &#125;&#125;void Do()&#123; memset(f, 0x3f, sizeof(f)); for(int j = 1; j &lt;= m; j ++) f[0][j] = 0; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = x[i] + 1; j &lt;= m + x[i]; j ++) f[i][j] = Min(f[i - 1][j - x[i]] + 1, f[i][j - x[i]] + 1); //上升 for(int j = m + 1; j &lt;= m + x[i]; j ++) f[i][m] = Min(f[i][m], f[i][j]); //特判 for(int j = 1; j + y[i] &lt;= m; j ++) f[i][j] = Min(f[i][j], f[i - 1][j + y[i]]); //下降 for(int j = 1; j &lt; low[i]; j ++) f[i][j] = f[0][0]; //+oo for(int j = high[i] + 1; j &lt;= m; j ++) f[i][j] = f[0][0]; //+oo //管道 &#125; int ans = f[0][0]; for(int j = 1; j &lt;= m; j ++) ans = Min(ans, f[n][j]); if(ans &lt; f[0][0]) printf("1\n%d\n", ans); else &#123; int i, j; for(i = n; i &gt;= 1; i--)&#123; for(j = 1; j &lt;= m; j ++)&#123; if(f[i][j] &lt; f[0][0]) break; &#125; if(j &lt;= m) break; &#125; ans = 0; for(j = 1; j &lt;= i; j ++) if(e[j]) ans ++; printf("0\n%d\n", ans); &#125;&#125;void init()&#123; GetData(); Do();&#125;int main()&#123;// fre(); init(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.10.1-2017.10.8总结]]></title>
    <url>%2F2017%2F10%2F09%2F2017-10-1-2017-10-8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[10.1-10.4总结显然，这四天是十一，最近过于疲惫的我请了3天的假，在家里好好休息了一番 （感觉在家休息也是做题学习啊） 10.5总结时隔多天再做模拟赛。。。然而也没有多少天，也就4天没做模拟赛而已。。。 今天交晚了，所以没成绩，不过我自己测了一下，应该是40分，尴尬。400分才做这么点分，实在有一点说不过去。 今天的t1看起来并没有那么难，事实证明我离正确答案已经很近了，但是并没有想到标答那一步，导致我这道题只有20分的暴力分&amp;拖延了交卷时间。t2很显然，它的暴力可以拿到50分，然而zz一般的我竟然选择放弃这道题的暴力，去想t1和t4，真的不知道该说什么好了。t3最开始以为就是一个裸的线段树，然而它的数据范围到了$1e9$，这就比较gg了。t4就比较惨淡，最开始我还想着是不是个dp，然后写了半天没跳出来，只得放弃。 因此，纵观今天的题与自己的分数，我觉得我的分数低主要是体现在实力不足上（咳咳，这貌似是每场都是低分的主要理由了吧），其次，还有很大一部分是分配时间以及心态上的问题，就比如t2本来还能拿个50分，却图正解然后正解没想出来，暴力也没打完。不过这一方面是我永远都改不掉的，这就比较gg。这几场比赛最开始都是在发愣，所以说上来先直截了当的打个暴力是坠吼的，然后拿到暴力分后再慢慢想（反正打暴力也花不了多少时间嘛）。题解见下。 今天下午fsf讲了特（我）别（都）特（听）别（不）难（懂）的图论。到现在（17:00）我在实现了第一道例题。。。]]></content>
      <categories>
        <category>总结</category>
        <category>心得与体会</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.9月总结]]></title>
    <url>%2F2017%2F10%2F09%2F2017-9%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[9.14总结​ 今天就比较gg。如果我没有记错的话，我已经有一段时间没有考上过150了。虽然说我这次考了192，但是（是个人都懂）这个成绩很烂。 ​ 今天这道题比较简单，比一般的比赛简单（要不然我这种juruo是不可能上100的）。第一题是一道暴力dp，第二题是道大模拟，第三个目测是dp，但本juruo不会做。 第一题还是很套路的。一看就知道是个二位状态，然后我们枚举最后一次所选的凳子，$f（i，j）$为我们选了i个凳子，最后一次选的第j个凳子的最后方案，那么我们很容易就得到状态转移方程式$f（i，j）=max（f（i，j），f（i-1，s）+sum）$，因为每个凳子只能选一次，所以得保证$s&lt;j$即可，然后找到$f[k]i$的最大值就好了。 ​ 第二题就更加简单。这道题就是一个分数之间的加法，（可能跟数据水有关系）开个long long就够了，但是切记求lcm的时候先除以最大公约数，然后再乘分母，要不然会爆。其他的按照题意模拟既可。 ​ 第三题乍一看是到dp（但它应该就是一道dp），然后想了想没有想出来，于是打算打个大暴力，但是由于我花在前两题的时间过多，于是第三题的暴力没有打完，于是暴0了。 ​ 总体的总结一下，我觉得我的时间分配可能还是有一些问题，比赛刚开始应该把题全都看一遍（比如这次t2就比t1简单了一节）；其次，我觉得我本场的最大的失误（灾难性失误）就是t2忘了判断分子为0如何输出的问题了，导致我这道题只拿了92分。这种失误也表现出了我的代码能力偏弱以及思维逻辑不够严谨等特点，所以我还是不能小看模拟题，适当的也要做一做复杂的模拟题。 9.21总结比赛网址：http://zybuluo.com/Falsyta/note/772691 （貌似只有我心情好才写总结） ​ 今天的题其实我看着觉得很难，其实它就是很难。。。 ​ t1就是求 (\sum_{i=1}^{m}\ \ n\ \ mod\ \ i)\ \ mod\ \ 10^{9}+7​ 看似很智障，其实就是很智障。 ​ 这道题就是将$n\ \ mod\ \ i$ 写成$n-\llcorner \frac{n}{i}\ \lrcorner \times i$ ​ 这样我们就可以枚举一下$\llcorner \frac{n}{i}\ \lrcorner$的值的情况。它一共会有$\sqrt{m}$种不同的值，然后显然这道题就做完了。 ​ ​ 下面我们看一下t2。 ​ 这道题肯定就是选$\frac{n}{2}+1$个数嘛，这样才能使两个总和尽量大。 ​ 因为我们需要使两个总和都尽量大，这时我莫名其妙的想起了国王的游戏（瞎想），然后果断的取了乘积前k大的（$k=\frac{n}{2}+1$），然后顺带就莫名其妙的A了。。。虽说我现在都不知道这个为什么是对的。 9.23模拟赛总结比赛网址：https://zybuluo.com/Falsyta/note/894732 ​ 今天这套题和21号的是一套题，不过比21号的难了太多了。。。难到随时想弃疗 ​ 于是t1我就瞎打了个爆搜（深搜），然后顺理成章的拿了50分。 ​ t2读了半天题，一直没有明白$3\ \ s$是什么鬼。然后恍然大悟，然后就没有然后了。明显是一道AC自动机，然后我并不会写，所以之后我还是需要看一下AC自动机的相关博客，稍微学习一下。 ​ t3听别人都说是智障题，当然结果反映它就是很智障。其实我也觉得很智障，不过我开始做这道题的时候只剩下了10min，于是我不动脑子瞎搞了一个看起来很对的拓扑排序的算法，于是乎它挂掉了，与此同时我发现了它是一道弱智的树形dp，可是为时已晚，就这样gg了。 ​ 最终只是拿到了50分。。。 ​ 下面我大概论述一下标算（我调出来的）： ​ t1其实就是一个爆搜，不过我们需要使用bfs，这个其实没什么好说的啊，直接搞就完了，肯定是要比dfs快的啊（也不知道当时我的脑子是怎么瓦特的）！ ​ t2就比较难，我并不会写，但是大概意思我是明白的滴。它是通过二进制建了$logm$ 个AC自动机，然后找size两桶的两个AC自动机合并，然后就没然后了。。。 ​ t3就是树形dp，分别用两个数组$f$和$g$记录一些东西。$f{i}$表示以$i$为根的子树需要有多少条边反向过来。$g{i}$表示以$i$为都城最少需要反向多少条边。然后$O(n)$DP一下应该就可以了。 9.23 ACM北京赛区网络赛总结​ 今天的ACM可是说是比上周的整体都要简单（其实也未必，上周都只做出来两道，今天也只做出来了两道，不过今天有一题有了正确的思路，就是没有时间继续往下想了）。 ​ 今天的A题十分的水，一看就是签到题。 ​ 显然，A题它就是一个大的模拟，没什么好说的，代码： ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1015;int p[MAXN];int ans = 2e9 + 15, ans1, ans2;bool vis[MAXN];inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void pd(int minn, int mins, int x, int y)&#123; if((minn + mins) &lt; ans)&#123; ans = minn + mins; ans1 = min(x, y); ans2 = max(x, y); &#125;&#125;void init()&#123; int n, m; while(scanf("%d %d", &amp;n, &amp;m) != EOF)&#123; ans = 2e9 + 15; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i ++) p[i] = read(); int q = read(), t; for(int i = 0; i &lt; q; i ++)&#123;t = read(); vis[t] = 1;&#125; for(int i = 0; i &lt; n; i ++)&#123; int tmp = 1, minn = 1e9 + 7, x = i, y; if(vis[i]) continue; for(int j = i + 1; j &lt; n; j ++)&#123; if(!vis[j])&#123; tmp ++; if(p[j] &lt; minn)&#123; minn = p[j]; y = j; &#125; &#125; if(tmp == m)&#123;pd(minn, p[x], x, y); break;&#125; &#125; &#125; printf("%d %d\n", ans1, ans2); &#125;&#125;int main()&#123; init(); return 0;&#125; ​ I题一看就知道是线段树，不过我们需要求出最大值和最小值，改动仅此而已（最开始我没看到可以重复，于是还算了次小和最小，于是搞得很乱）不过最终我们还是成功的做出来了这道题，不过这也耗尽了我们队员我的脑细胞。 ​ 接来下我们一直在搞G题，可是绞尽脑汁还是没有找到规律，可见我的智商低下啊。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double DB;const ll MAXN = 2 &lt;&lt; 17 + 1;const ll INF = 2 &lt;&lt; 31;struct Node&#123; ll maxx, maxs, minn, mins; void init()&#123; maxs = maxx = -INF; minn = mins = INF; &#125;&#125;s[MAXN];ll a[MAXN];inline ll Max(ll a, ll b)&#123;return a &gt; b ? a : b;&#125;inline ll Min(ll a, ll b)&#123;return a &lt; b ? a : b;&#125;void build(int p, int l, int r)&#123; if(l == r)&#123;s[p].maxs = s[p].maxx = s[p].minn = s[p].mins = a[l]; return ;&#125; int mid = (l + r) &gt;&gt; 1; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); int ls = p * 2, rs = p * 2 + 1; if(s[ls].maxx &gt; s[rs].maxx)&#123; s[p].maxx = s[ls].maxx; s[p].maxs = s[rs].maxx; &#125; else &#123; s[p].maxx = s[rs].maxx; s[p].maxs = s[ls].maxx; &#125; if(s[ls].minn &lt; s[rs].minn)&#123; s[p].minn = s[ls].minn; s[p].mins = s[rs].minn; &#125; else &#123; s[p].minn = s[rs].minn; s[p].mins = s[ls].minn; &#125;&#125;inline int read()&#123; ll r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void modify(int p, int l, int r, int x, int v)&#123; if(l == r)&#123;s[p].maxs = s[p].maxx = s[p].minn = s[p].mins = v; return ;&#125; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) modify(p * 2, l, mid, x, v); else modify(p * 2 + 1, mid + 1, r, x, v); int ls = p * 2, rs = p * 2 + 1; if(s[ls].maxx &gt; s[rs].maxx)&#123; s[p].maxx = s[ls].maxx; s[p].maxs = s[rs].maxx; &#125; else &#123; s[p].maxx = s[rs].maxx; s[p].maxs = s[ls].maxx; &#125; if(s[ls].minn &lt; s[rs].minn)&#123; s[p].minn = s[ls].minn; s[p].mins = s[rs].minn; &#125; else &#123; s[p].minn = s[rs].minn; s[p].mins = s[ls].minn; &#125;&#125;Node query(int p, int l, int r, int x, int y)&#123; Node ll, rr, res; ll.init(); rr.init(); res.init(); if(x &lt;= l &amp;&amp; r &lt;= y) return s[p]; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) ll = query(p * 2, l, mid, x, y); if(y &gt; mid) rr = query(p * 2 + 1, mid + 1, r, x, y); if(ll.maxx == -INF)&#123; res.maxx = rr.maxx; res.maxs = rr.maxs; res.minn = rr.minn; res.mins = rr.mins; &#125; else if(rr.maxx == -INF)&#123; res.maxx = ll.maxx; res.maxs = ll.maxs; res.minn = ll.minn; res.mins = ll.mins; &#125; else &#123; if(ll.maxx &gt; rr.maxx)&#123; res.maxx = ll.maxx; res.maxs = rr.maxx; &#125; else &#123; res.maxx = rr.maxx; res.maxs = ll.maxx; &#125; if(ll.minn &lt; rr.minn)&#123; res.minn = ll.minn; res.mins = rr.minn; &#125; else &#123; res.minn = rr.minn; res.mins = ll.minn; &#125; &#125; return res;&#125;void init()&#123; int T = read(); while(T --)&#123; memset(a, 0, sizeof(a)); ll n = read(); n = (1 &lt;&lt; n); for(int i = 1; i &lt;= 4 * n; i ++) s[i].init(); for(int i = 1; i &lt;= n; i ++) a[i] = read(); build(1, 1, n); /* for(int i = 1; i &lt; 4 * n ; i ++)&#123; cout&lt;&lt;i&lt;&lt;": "&lt;&lt;endl; cout&lt;&lt;s[i].maxx&lt;&lt;" "&lt;&lt;s[i].maxs&lt;&lt;" "&lt;&lt;s[i].mins&lt;&lt;" "&lt;&lt;s[i].minn&lt;&lt;endl; &#125; */ int q = read(); for(int i = 1; i &lt;= q; i ++)&#123; int e = read(); if(e == 1)&#123; int x = read() + 1, y = read() + 1; Node ans = query(1, 1, n, x, y); //cout&lt;&lt;ans.maxs&lt;&lt;" "&lt;&lt;ans.maxx&lt;&lt;" "&lt;&lt;ans.minn&lt;&lt;" "&lt;&lt;ans.mins&lt;&lt;endl; ll a1 = 1ll * ans.maxx * ans.maxs; ll a2 = 1ll * ans.mins * ans.minn; ll a3 = 1ll * ans.maxx * ans.minn; ll a4 = 1ll * ans.maxs * ans.mins; ll a5 = 1ll * ans.maxx * ans.mins; ll a6 = 1ll * ans.maxs * ans.minn; ll a7 = 1ll * ans.maxx * ans.maxx; ll a8 = 1ll * ans.maxs * ans.maxs; ll a9 = 1ll * ans.minn * ans.minn; ll a10 = 1ll * ans.mins * ans.mins; //if(ans.maxx == -INF)&#123;a1 = a3 = a4 = INF;&#125; //if(ans.minn == INF)&#123;a2 = a3 = a4 = INF;&#125; printf("%lld\n", Min(a1, Min(a2, Min(a3, Min(a4, Min(a5, Min(a6, Min(a7, Min(a8, Min(a9, a10)))))))))); &#125; else if(e == 2)&#123; int x = read() + 1, y = read(); modify(1, 1, n, x, y); &#125; &#125; &#125;&#125;int main()&#123; //fre(); init(); return 0;&#125;/*231 1 2 2 1 1 2 251 0 71 1 22 1 22 2 21 1 231 1 2 2 1 1 2 251 0 71 1 22 1 22 2 21 1 2141 6 3 7 -4 6 4 -6 3 6 6 -4 6 -8 4 661 0 152 5 71 4 72 7 42 12 11 2 14*/ ​ 不过比赛结束后通过神犇的cjr的讲解终于是知道了规律是怎么找出来的了。 ​ 其实这道题的规律是吧边界上的点与图的中间部分的点分开算，$n$和$m$都先减一，然后我们先求$d=gcd(n,m)$，接着$n = \frac{n}{d}\$ ，$m=\frac{m}{d}$， 于是乎我们可以 用$ans$来表示答案，$ans=n+m+(d-1)\times n \times m$ 这样就算出答案了。 ​ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;LL gcd(LL a, LL b)&#123;return !b ? a : gcd(b, a % b);&#125;void init()&#123; LL n, m; LL ans; while(scanf("%lld %lld", &amp;n, &amp;m) != EOF)&#123; ans = 0; n --; m --; LL d = gcd(n, m); LL gg1 = n / d, gg2 = m / d; ans = gg1 + gg2 + (d - 1) * gg1 * gg2; printf("%lld\n", ans); &#125;&#125;int main()&#123; init(); return 0;&#125; ​ 总的来说，今天的ACM我们已经尽力了，可能实力差距确实很大，所以我还是需要多加练习啊！ 9.24模拟赛总结今日题目链接：https://zybuluo.com/stevenzheng2002/note/895717 ​ 10分。。。 ​ 尴尬的10分，居然t1的40分暴力都打错了，真的是。。。无语了。 ​ 据说这套题很难（貌似并不是据说，就是很难），还有国家集训队的作业，所以考不高也很正常，但是暴力都没打过就有些说不过去了啊！ 9.24 ACM南宁赛区网络赛总结​ 这个。。。 ​ 今天出了些小偏差，貌似北京交通大学在跟我们共用一个号。。。然后我们就被别人带着飞了。。。每次刚看完题，那边就把这道题A了，十分interesting，这样导致我们自己A的题目数量只有2道（他们做太快了，若果慢的话，我们也能A）。 ​ 总体来说，今天的ACM没有像前两天那样特别智障的签到题，但是中等偏易的题比较多，得有个7道左右，所以今天排在400多都要A个8,9道，竞争十分激烈。 ​ 最后我们还是需要调一下这些题，毕竟好多不是自己A的（虽然会写）。 9.26总结​ 今天这个生日过得十分糟糕。。。本以为今天这套简单题能让我上200，没想到。。。t1就写挂了。 ​ 今天的题相较过去一段时间的题来说，简单多了不少，听其他人说只有t2的10%难拿，其他的都是水题。然而写了2h t2的我表示t3一眼都没看。。。 ​ 先说一下今天的题。t1确实很水，就是枚举你需要用多少辆车就行了，先把重量从大到小排个序，对于用$x$辆车，直接用深搜（爆搜）来检验是否合理即可。千万不要忘了剪枝！！！我因为没有剪枝挂了4个点。。。剪枝大概就是先求一个重量总和$sum$，然后车辆数从$sum \div\ w$开始算到n即可！ ​ t2其实也不是特别难，主要是10分的C类型比较难拿。颂芬数据直接跑一遍SPFA即可。30%的A类数据是裸的LCA，不多赘述；50%的B类数据就是环套树，判断一下选不选此边即可。 ​ 总的来讲，我的思维训练的还是不到位。t2能写出2h。。。而且做题前一定要计算一下复杂度，看看是不是差不多能过。然后还有就是读题一定要读清楚！！！读不清楚就多读两遍！！！比如我今天t2的B类数据我就理解成$n$个点组成一个大环了。。。 9.29总结​ 今天主要就做了LCA和dijsktra方面的题，共6道。感觉我调了很多“灵异”方面的问题。比如cout，printf输出的答案。 ​ 其实说是六道，一共也就相当于做了2道，因为有4道题都是模板题。我大概就说一下小z摘玉米和货车运输吧。 ​ 小z摘玉米就是一道比较弱的题。题意大概是就说一棵树，$q$次询问，每次询问$u$到$v$，求$u$到$v$的路径上的所有点的最大值与次大值之和（包括$u$和$v$）。 ​ 这道题其实几乎就是裸的LCA。只不过我们需要加两个数组$hx$，$hn$。$hx[i][j]$表示的是在$i$到$i$的$2^j$倍的祖先的所有点的点权的最大值（不包括$i$的$2^j$倍祖先），预处理也就不用我说了，然后这要就是在求lca的过程中随着x和y的往上更新，也顺便更新一下目前的最大值与次大值。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double DB;int Max1(int a, int b, int c, int g)&#123; int h[6]; h[1] = a, h[2] = b, h[3] = c, h[4] = g; sort(h + 1, h + 5); return h[4];&#125;int Max2(int a, int b, int c, int g)&#123; int h[6]; h[1] = a, h[2] = b, h[3] = c, h[4] = g; sort(h + 1, h + 5); return h[3];&#125;const int MAXN = 1e5 + 15;struct Node&#123; int to, nxt;&#125;g[MAXN * 2];int ans1 = -1, ans2 = -1;int cnt = 0, n;int a[MAXN], d[MAXN];int head[MAXN], p[MAXN][20];int hx[MAXN][20], hn[MAXN][20];void add(int u, int v)&#123; g[++ cnt] = (Node)&#123;v, head[u]&#125;; head[u] = cnt; g[++ cnt] = (Node)&#123;u, head[v]&#125;; head[v] = cnt;&#125;int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void init()&#123; memset(d, -1, sizeof(d)); for(int i = 1; i &lt;= n; i ++) hx[i][0] = a[i]; d[1] = 0;&#125;void dfs(int u)&#123; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(d[v] == -1)&#123; d[v] = d[u] + 1; p[v][0] = u; dfs(v); &#125; &#125;&#125;void pre()&#123; for(int i = 1; (1 &lt;&lt; i) &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; if(p[j][i - 1])&#123; p[j][i] = p[p[j][i - 1]][i - 1]; hx[j][i] = max(hx[j][i - 1], hx[p[j][i - 1]][i - 1]); hn[j][i] = Max2(hx[j][i - 1], hx[p[j][i - 1]][i - 1], hn[j][i - 1], hn[p[j][i - 1]][i - 1]); &#125; &#125; &#125;&#125;int lca(int x, int y)&#123; if(d[x] &lt; d[y]) swap(x, y); int i; for(i = 0; (1 &lt;&lt; i) &lt;= n; i ++); i --; for(int j = i; j &gt;= 0; j --) if(d[x] - (1 &lt;&lt; j) &gt;= d[y])&#123; ans1 = max(hx[x][j], ans1); ans2 = max(hn[x][j], ans2); x = p[x][j]; &#125; if(x == y) return x; for(int j = i; j &gt;= 0; j --)&#123; //cout&lt;&lt;x&lt;&lt;endl; if(p[x][j] != p[y][j])&#123; int tmp2 = Max2(hx[x][j], hn[x][j], hx[y][j], hn[y][j]); int tmp1 = Max1(hx[x][j], hn[x][j], hx[y][j], hn[y][j]); int gg2 = Max2(ans1, ans2, tmp1, tmp2); int gg1 = Max1(ans1, ans2, tmp1, tmp2); ans1 = gg1, ans2 = gg2; x = p[x][j]; y = p[y][j]; &#125; &#125; int tmp2 = Max2(hx[x][0], hn[x][0], hx[y][0], hn[y][0]); int tmp1 = Max1(hx[x][0], hn[x][0], hx[y][0], hn[y][0]); int gg2 = Max2(ans1, ans2, tmp1, tmp2); int gg1 = Max1(ans1, ans2, tmp1, tmp2); ans1 = gg1, ans2 = gg2; return p[x][0];&#125;void work()&#123; n = read(); for(int i = 1; i &lt;= n; i ++) a[i] = read(); for(int i = 1; i &lt; n; i ++)&#123; int u = read(), v = read(); add(u, v); &#125; init(); dfs(1); pre(); /* for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 0; (1 &lt;&lt; j) &lt;= n; j ++) printf("%d ", hn[i][j]); printf("\n"); &#125; */ int Q = read(); while(Q --)&#123; ans1 = 0, ans2 = 0; int u = read(), v = read(); int gr = lca(u, v); //cout&lt;&lt;ans1&lt;&lt;" "&lt;&lt;ans2&lt;&lt;endl; if(a[gr] &gt;= ans1)&#123; ans2 = ans1; ans1 = a[gr]; &#125; else if(a[gr] &gt;= ans2) ans2 = a[gr]; printf("%d\n", ans1 + ans2); &#125;&#125;int main()&#123; work(); return 0;&#125; 货车运输： ​ 这道题说的大概就是一棵树，$q$次询问，每次询问是$u$和$v$，求$u$到$v$的路径上的边权最小值。 ​ 这道题相对来讲比上一道题还简单，然而我却出了一些灵异事件，比如cout和printf输出的答案不太一样，结果花了我5.5h找到了错误：for里面的$i$我重复定义了。。。这tm就尴尬了。 ​ 这道题主要是在LCA模板上加一个$h$数组，$h[i][j]$表示点$i$到$i$的$2^j$倍祖先的路上的所有边的边权最小值。然后同上面一道题一样，在求lca的时候更新当前的$ans$。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef double DB;LL Max(LL a, LL b)&#123;return a &gt; b ? a : b;&#125;LL Min(LL a, LL b)&#123;return a &lt; b ? a : b;&#125;const int MAXN = 1e5 + 15;struct Node&#123; int from, to, dis;&#125;e[MAXN];struct Edge&#123; int to, nxt, dis;&#125;g[MAXN];int n, m;int cnt_edge = 0, ans;int fa[MAXN / 10];int head[MAXN / 10], cnt = 0;int p[MAXN / 10][20], h[MAXN / 10][20], d[MAXN/ 10];bool flag[MAXN / 10];void add(int u, int v, int dis)&#123; e[++ cnt_edge].from = u; e[cnt_edge].to = v; e[cnt_edge].dis = dis;&#125;void add_edge(int u, int v, int dis)&#123; g[++ cnt].to = v; g[cnt].nxt = head[u]; g[cnt].dis = dis; head[u] = cnt;&#125;int read()&#123; int r = 0, z = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') z = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;r = r * 10 + ch - '0'; ch = getchar();&#125; return r * z;&#125;void fre()&#123; freopen(".in", "r", stdin); freopen(".out", "w", stdout);&#125;int cmp(Node x, Node y) &#123;return x.dis &gt; y.dis;&#125;int getfa(int x)&#123; if(x == fa[x]) return fa[x]; return fa[x] = getfa(fa[x]);&#125;void kruskal()&#123; sort(e + 1, e + m + 1, cmp); for(int i = 1; i &lt;= n; i ++) fa[i] = i; int k = 0; for(int i = 1; i &lt;= m; i ++)&#123; int u = e[i].from, v = e[i].to, dis = e[i].dis; int f1 = getfa(u), f2 = getfa(v); if(f1 != f2)&#123; fa[f2] = f1; add_edge(u, v, dis); add_edge(v, u, dis); k ++; &#125; if(k == n - 1) break; &#125;&#125;void fuckit()&#123; memset(d, -1, sizeof(d)); for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 0; (1 &lt;&lt; j) &lt;= n; j ++) h[i][j] = 2e9; &#125; d[1] = 0;&#125;void dfs(int u)&#123; for(int i = head[u]; i; i = g[i].nxt)&#123; int v = g[i].to; if(d[v] == -1)&#123; d[v] = d[u] + 1; p[v][0] = u; h[v][0] = g[i].dis; flag[v] = 1; dfs(v); &#125; &#125;&#125;void work()&#123; for(int i = 0; (1 &lt;&lt; i) &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; if(p[j][i - 1])&#123; p[j][i] = p[p[j][i - 1]][i - 1]; h[j][i] = min(h[j][i - 1], h[p[j][i - 1]][i - 1]); &#125; &#125; &#125;&#125;int lca(int x, int y)&#123; int i; ans = 2e9; if(d[x] &lt; d[y]) swap(x, y); for(i = 0; (1 &lt;&lt; i) &lt;= d[x]; i ++); i --; for(int j = i; j &gt;= 0; j --)&#123; if(d[x] - (1 &lt;&lt; j) &gt;= d[y])&#123;ans = min(ans, h[x][j]); x = p[x][j];&#125; &#125; //cout&lt;&lt;x&lt;&lt;"*cout"&lt;&lt;y&lt;&lt;endl; //printf("%d %d\n", x, y); if(x == y) return x; for(int j = i; j &gt;= 0; j --)&#123; if(p[x][j] != p[y][j] &amp;&amp; p[x][j])&#123; ans = min(ans, h[x][j]); x = p[x][j]; ans = min(ans, h[y][j]); y = p[y][j]; &#125; &#125; return p[x][0];&#125;int cz(int u, int k)&#123; int i, res = 2e9 + 7; for(i = 0; (1 &lt;&lt; i) &lt;= k; i ++); i --; for(; i &gt;= 0; i --) if(k &amp; (1 &lt;&lt; i))&#123; res = min(res, h[u][i]); u = p[u][i]; k -= (1 &lt;&lt; i); &#125; return res;&#125;void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i ++)&#123; int u = read(), v = read(), dis = read(); add(u, v, dis); &#125; kruskal(); fuckit(); for(int i = 1; i &lt;= n; i ++)&#123; if(!flag[i])&#123;flag[i] = 1; dfs(i);&#125; &#125; work(); int q = read(); /* for(int i = 1; i &lt;= n; i ++) cout&lt;&lt;d[i]&lt;&lt;" "; cout&lt;&lt;endl; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 0; (1 &lt;&lt; j) &lt;= n; j ++) cout&lt;&lt;h[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125; for(int i = 1; i &lt;= n; i ++) printf("%d ", fa[i]); printf("\n"); */ while(q --)&#123; int a = read(), b = read(); if(getfa(a) != getfa(b)) printf("-1\n"); else &#123; int tmp = lca(a, b); //printf("%d\n", tmp); printf("%d\n", min(cz(a, d[a] - d[tmp]), cz(b, d[b] - d[tmp]))); &#125; &#125;&#125;int main()&#123; //fre(); init(); return 0;&#125; 九月份整体总结​ 这个月貌似天天都在练，好像没有歇过。。。这个月我已经比较累了，所以十一放假我请了三天假（貌似放假也不能放松啊）。这个九月份做了好多好多套模拟赛，大概一周4套，所以可能做了15套左右，加上这个月还有ACM，所以。。。身体已经经受不住了啊。。。不过看看小学弟还有dalao们还在拼命地练习，这让我感到十分羞愧，毕竟我跟dalao们还有很大的差距啊！！！ ​ 纵观整个九月份，我的模拟考成绩不算理想，虽说每套的题都比noip提高组略难。其实看看题解，我感觉我欠缺的方面确实还有很多。 ​ 1.知识广度不够，即会的知识过少。比如什么高端的树链剖分啊，高级的暴力啊，还有各种数论知识我都不会（尴尬），于是我只能在这短暂的一个半月时间里狂学。唉，差的确实太多了。还有80多天，要加油了！ ​ 2.知识深度不够。这正跟jls所说的模块方面的欠缺有关。其实我刷题刷的很少，导致我会某个知识点，但是真到比赛的时候，需要有一些变动，添加之类的我就不会了，这跟刷题少有着千丝万缕的联系，所以在接下来的这一个月，不仅要多学一些知识，更重要的是要多做题，要不然真到11.11的时候就gg了。。。 ​ 3.数学太差。这个。。。感觉一时间也不太好补，这方面的欠缺主要体现在找规律找不出来，数学题中的推导不会推之类的问题。像lzy这种随随便便参加数学竞赛都能拿个省一的人来说做信息中的数学题就是小菜一碟。虽说我的智商发展限制了我到达他那么厉害的程度，但是我仍然需要在这方面要有很大的提高，要不然考试也会吃很多亏的。 ​ 好了，说完了我在这一个月所发现的不足之处之后，我貌似好像就没什么优点了。。。好吧，我承认了我是一个什么都不会，什么都不行的，智商为$-\infty$的蒟蒻（也许我还没有达到一个做为人的基本标准。。。） ​ 不管怎样，就算菜到不可救药，我还是要努力啊，要不然连省一都拿不到的话就太tm尴尬了。。。]]></content>
      <categories>
        <category>总结</category>
        <category>心得与体会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树链剖分]]></title>
    <url>%2F2017%2F10%2F08%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[“在一棵树上进行路径的修改、求极值、求和”乍一看只要线段树就能轻松解决，实际上，仅凭线段树是不能搞定它的。我们需要用到一种貌似高级的复杂算法——树链剖分。​ 树链，就是树上的路径。剖分，就是把路径分类为重链和轻链。 记siz[v]表示以v为根的子树的节点数，dep[v]表示v的深度(根深度为1)，top[v]表示v所在的重链的顶端节点，fa[v]表示v的父亲，son[v]表示与v在同一重链上的v的儿子节点（姑且称为重儿子），w[v]表示v与其父亲节点的连边（姑且称为v的父边）在线段树中的位置。只要把这些东西求出来，就能用logn的时间完成原问题中的操作。 重儿子：siz[u]为v的子节点中siz值最大的，那么u就是v的重儿子。 轻儿子：v的其它子节点。 重边：点v与其重儿子的连边。 轻边：点v与其轻儿子的连边。 重链：由重边连成的路径。 轻链：轻边。 剖分后的树有如下性质： 性质1：如果(v,u)为轻边，则siz[u] 2 &lt; siz[v]； 性质2*：从根到某一点的路径上轻链、重链的个数都不大于logn。 算法实现： 我们可以用两个dfs来求出fa、dep、siz、son、top、w。 $dfs_1$：把fa、dep、siz、son求出来，比较简单，略过。 $ dfs_2$： ⒈对于v，当son[v]存在（即v不是叶子节点）时，显然有top[son[v]] = top[v]。线段树中，v的重边应当在v的父边的后面，记w[son[v]] = totw+1，totw表示最后加入的一条边在线段树中的位置。此时，为了使一条重链各边在线段树中连续分布，应当进行dfs_2(son[v])； ⒉对于v的各个轻儿子u，显然有top[u] = u，并且w[u] = totw+1，进行dfs_2过程。 这就求出了top和w。 将树中各边的权值在线段树中更新，建链和建线段树的过程就完成了。 修改操作：例如将u到v的路径上每条边的权值都加上某值x。 一般人需要先求LCA，然后慢慢修改u、v到公共祖先的边。而高手就不需要了。 记f1 = top[u]，f2 = top[v]。 当f1 &lt;&gt; f2时：不妨设dep[f1] &gt;= dep[f2]，那么就更新u到f1的父边的权值(logn)，并使u = fa[f1]。 当f1 = f2时：u与v在同一条重链上，若u与v不是同一点，就更新u到v路径上的边的权值(logn)，否则修改完成； 重复上述过程，直到修改完成。 求和、求极值操作：类似修改操作，但是不更新边权，而是对其求和、求极值。 就这样，原问题就解决了。鉴于鄙人语言表达能力有限，咱画图来看看：树链剖分 如右图所示，较粗的为重边，较细的为轻边。节点编号旁边有个红色点的表明该节点是其所在链的顶端节点。边旁的蓝色数字表示该边在线段树中的位置。图中1-4-9-13-14为一条重链。 当要修改11到10的路径时： 第一次迭代：u = 11，v = 10，f1 = 2，f2 = 10。此时dep[f1] &lt; dep[f2]，因此修改线段树中的5号点，v = 4, f2 = 1； 第二次迭代：dep[f1] &gt; dep[f2]，修改线段树中10—11号点。u = 2，f1 = 2； 第三次迭代：dep[f1] &gt; dep[f2]，修改线段树中9号点。u = 1，f1 = 1； 第四次迭代：f1 = f2且u = v，修改结束。 数据规模大时，递归可能会爆栈，而非递归dfs会很麻烦，所以可将两个dfs改为宽搜+循环。即先宽搜求出fa、dep，然后逆序循环求出siz、son，再顺序循环求出top和w。​​ 题目：spoj375、USACO December Contest Gold Divison, “grassplant”。 **spoj375据说不“缩行”情况下最短的程序是140+行，我的是128行。 附spoj375程序(C++)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 10010;struct Tedge&#123; int b, next; &#125; e[maxn &lt;&lt; 1];int tree[maxn];int zzz, n, z, edge, root, a, b, c;int d[maxn][3];int first[maxn], dep[maxn], w[maxn], fa[maxn], top[maxn], son[maxn], siz[maxn];char ch[10];void insert(int a, int b, int c)&#123; e[++edge].b = b; e[edge].next = first[a]; first[a] = edge;&#125;void dfs(int v)&#123; siz[v] = 1; son[v] = 0; for (int i = first[v]; i &gt; 0; i = e[i].next) if (e[i].b != fa[v]) &#123; fa[e[i].b] = v; dep[e[i].b] = dep[v]+1; dfs(e[i].b); if (siz[e[i].b] &gt; siz[son[v]]) son[v] = e[i].b; siz[v] += siz[e[i].b]; &#125;&#125;void build_tree(int v, int tp)&#123; w[v] = ++ z; top[v] = tp; if (son[v] != 0) build_tree(son[v], top[v]); for (int i = first[v]; i &gt; 0; i = e[i].next) if (e[i].b != son[v] &amp;&amp; e[i].b != fa[v]) build_tree(e[i].b, e[i].b);&#125;void update(int root, int lo, int hi, int loc, int x)&#123; if (loc &gt; hi || lo &gt; loc) return; if (lo == hi) &#123; tree[root] = x; return; &#125; int mid = (lo + hi) / 2, ls = root * 2, rs = ls + 1; update(ls, lo, mid, loc, x); update(rs, mid+1, hi, loc, x); tree[root] = max(tree[ls], tree[rs]);&#125;int maxi(int root, int lo, int hi, int l, int r)&#123; if (l &gt; hi || r &lt; lo) return 0; if (l &lt;= lo &amp;&amp; hi &lt;= r) return tree[root]; int mid = (lo + hi) / 2, ls = root * 2, rs = ls + 1; return max(maxi(ls, lo, mid, l, r), maxi(rs, mid+1, hi, l, r));&#125;inline int find(int va, int vb)&#123; int f1 = top[va], f2 = top[vb], tmp = 0; while (f1 != f2) &#123; if (dep[f1] &lt; dep[f2]) &#123; swap(f1, f2); swap(va, vb); &#125; tmp = max(tmp, maxi(1, 1, z, w[f1], w[va])); va = fa[f1]; f1 = top[va]; &#125; if (va == vb) return tmp; if (dep[va] &gt; dep[vb]) swap(va, vb); return max(tmp, maxi(1, 1, z, w[son[va]], w[vb])); //&#125;void init()&#123; scanf("%d", &amp;n); root = (n + 1) / 2; fa[root] = z = dep[root] = edge = 0; memset(siz, 0, sizeof(siz)); memset(first, 0, sizeof(first)); memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); d[i][0] = a; d[i][1] = b; d[i][2] = c; insert(a, b, c); insert(b, a, c); &#125; dfs(root); build_tree(root, root); // for (int i = 1; i &lt; n; i++) &#123; if (dep[d[i][0]] &gt; dep[d[i][1]]) swap(d[i][0], d[i][1]); update(1, 1, z, w[d[i][1]], d[i][2]); &#125;&#125;inline void read()&#123; ch[0] = ' '; while (ch[0] &lt; 'C' || ch[0] &gt; 'Q') scanf("%s", &amp;ch);&#125;void work()&#123; for (read(); ch[0] != 'D'; read()) &#123; scanf("%d%d", &amp;a, &amp;b); if (ch[0] == 'Q') printf("%d\n", find(a, b)); else update(1, 1, z, w[d[a][1]], b); &#125;&#125;int main()&#123; for (scanf("%d", &amp;zzz); zzz &gt; 0; zzz--) &#123; init(); work(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>讲解与实践</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
</search>
